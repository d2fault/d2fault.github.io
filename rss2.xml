<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>잡동사니 수집광</title>
    <link>https://d2fault.github.io/</link>
    
    <atom:link href="https://d2fault.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>잡학다식을 꿈꾸는 공간</description>
    <pubDate>Sun, 14 Jan 2024 05:44:24 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[Diary] 2023년 회고하기</title>
      <link>https://d2fault.github.io/2023/12/31/20231231-diary/</link>
      <guid>https://d2fault.github.io/2023/12/31/20231231-diary/</guid>
      <pubDate>Sun, 31 Dec 2023 12:03:03 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;뭐라고-시작하는-게-좋을까&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#뭐라고-시작하는-게-좋을까&quot;&gt;&lt;/a&gt; 뭐라고 시작하는 게 좋을까&lt;/h1&gt;
&lt;p&gt;첫 곡이 먼저냐, 예언이 먼저냐의 고민이랄까. 물론 둘 다 정답임</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="뭐라고-시작하는-게-좋을까"><a class="markdownIt-Anchor" href="#뭐라고-시작하는-게-좋을까"></a> 뭐라고 시작하는 게 좋을까</h1><p>첫 곡이 먼저냐, 예언이 먼저냐의 고민이랄까. 물론 둘 다 정답임을 안다. 새해 첫 곡을 선정해 들은 지 어언 10년이 넘었는데 반년도 안 되어 그 의미를 깨달은 해는 처음이다.</p><blockquote><p>처음 마주할 것들이 많으리라 예상되는 2023도 지지 않으며, 또 가끔 지며 다채롭게 채워 봐야지!</p></blockquote><p>이 문장을 적을 땐 몰랐죠… 지금도 모르고 싶어요…</p><div class="video-container"><iframe src="https://www.youtube.com/embed/fLO78eN0nQM" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>22년 11월, 정든 첫 회사를 떠나며 새로운 회사에서의 새출발을 응원하는 마음으로 선정한 김동률의 시작은</p><blockquote><p><em>아주 멀리까지 가보고 싶어</em><br /><em>그 곳에선 누구를 만날 수가 있을지</em><br /><em>아주 높이까지 오르고 싶어</em><br /><em>얼마나 더 먼 곳을 바라볼 수 있을지</em></p><p><em>(중략)</em></p><p><em>내가 자라고 정든 이 거리를</em><br /><em>난 가끔 그리워하겠지만</em><br /><em>이렇게 나는 떠나네 더 넓은 세상으로</em></p></blockquote><p>또 다른 시작을 선물했다.</p><br/><h1 id="빙글빙글-돌아간-상반기"><a class="markdownIt-Anchor" href="#빙글빙글-돌아간-상반기"></a> 빙글빙글 돌아간 상반기</h1><p>상황이 애매모호하게 돌아가고 있단 건 어렴풋이 느끼고 있었다. 그런 상황에서도 내가 할 수 있는 건 없기에 그저 주어진 것에 집중하려 노력했다. 제공하던 SDK 구조를 개선하기 위해 정기적으로 논의도 하고, 먼슬리 회고도 하고, 샘플 코드도 만들고, 디자인 모듈도 만들면서 나름 알찬 시간을 보냈다. 음, 그러니까 본질은, <strong>그 누구도 우리에게 일을 주지 않았지만</strong> 시간을 허투루 보내진 않았단 뜻이다. 스터디를 통해 플러터<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>입문도 하고, 이런 것들이 쌓여 함께하던 분들과 단시간에 친밀감<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>을 쌓을 수 있었다고 생각한다.</p><br/><h1 id="있었는데"><a class="markdownIt-Anchor" href="#있었는데"></a> 있었는데…</h1><p>그래도 분명 회사가 있었는데요, 있었거든요? 전 회사의 10% 규모래도 작은 건 아니거든요? 그런데 없어, 아니 없어지는 중이네요.</p><blockquote><p>온실 속 화초에서 정글로 걸어가는 건 마냥 설레는 일은 아니다. 앞으로 이전보다 더한 고난과 역경이 닥칠 수도 있다는 것도 알지만 궁금한 걸 어떡해? 정글로 간다고 해서 날 잡아먹을 육식 동물만 있진 않겠지.</p></blockquote><p>‘이만하면 웬만한 일 다 겪었다!’ 싶을 때 '힝, 속았지?'의 사건들이 종종 튀어나온다. 이번 일도 그 연장선이지, 뭐. &quot;진짜 망할 수도 있을 듯요. 와하하!&quot;라고 말하던 과거의 내 모습이 스쳐 가는 게 어쩌면 알면서 선택한 것 같기도.</p><p>그래서 후회하느냐? 아니. 낮은 확률이라 생각했을 뿐이지 고려하지 않은 상황은 아니다. 내 맷집 그렇게 약하지 않다고! 회사가 망한 건 처음이지만 뒤숭숭하고 소문 많은 분위기는 이미 신입사원 때 다~ 겪어낸 일이지 않겠습니까. 회사만 안 망했을 뿐이지 우리 팀이 폭파될 수 있단 걱정을 연말마다 해야 했던 n년차 직장인 짬바는 어디 안 가지롱.</p><p>그 상황<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>에서 내가 뭘 한다고 달라질 건 없었다. 공부가 손에 안 잡히는 거? 그것도 어쩔 수 없지. 불확실한 상황 속 단 하나의 확실함이 있다면 이 순간을 그리워할 날이 온다는 것이다. 미래의 난 ‘결국’ 일하고 있을 테니까. 그게 언젠지, 어딜지 모른다는 점만 빼면 월급도 나오지, 재택 중인데 일은 없지, 시간은 넘치지? 꿈꾸던 삶 아닌가요? 그렇게 생각하니 선택할 수 있는 건 딱 하나였다. <strong>지금을 즐기자.</strong></p><br/><h1 id="쉼표-찍기"><a class="markdownIt-Anchor" href="#쉼표-찍기"></a> 쉼표 찍기</h1><blockquote><p>많은 경험과 사람을 만나는 것에 집중했던 작년이라면 올해는 앞으로의 내 삶을 어떻게 가꿀지 정리하는 해가 되었으면 한다.</p></blockquote><p>작년 회고에 적은 다짐이 이렇게 실현되는구나. 내 세상<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>에서 한 발짝 떨어지기로 했다. 차박에 진심…까진 아니더라도 빈도가 가장 잦았던 해. 별게 별것이 아니게 될 때까지 낯선 곳을 찾아 머리를 비웠다. 그때 본 일몰과 윤슬, 돌멩이가 부딪히던 소리, 누군가 즐기던 불꽃이 선하다.</p><p>물론 차박만 다닌 건 아니다. 미친 듯 더웠던 전주, 할머니, 엄마와 함께 다녀온 무의도, 수다가 목적이었던 일산, 그리고 고요함이 마음에 든 진해<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>도 있었다.</p><br/><h2 id="이게-되네"><a class="markdownIt-Anchor" href="#이게-되네"></a> 이게 되네?</h2><p>구직자 포지션이 입사 예정자로 바뀌던 순간, 이대로 입사할 순 없단 생각이 들었다. 입사 전 해외 한번 찍어야지! 2박 3일 만에 방콕행 티켓을 끊고 숙소까지 예약하다니! 😨 비행기 타는 날 한숨도 못 자고 간 건 함정이지만 단기간에 몰입해서 해냈다는 것 자체로 뿌듯했다. 목적도, 목표도 없이 홀로 떠난 여행이라 그냥 많이 걷고, 구경하고, 쉰 게 전부였지만 아직까지도 조막만한 미니 파인애플의 맛이 혀끝에 맴돈다. 물론 1일 1마사지도 잊을 수 없음!</p><p>이 여행으로 체력도 지갑도 탈탈 털렸지만 후회는 없다. 그 둘은 채울 수 있지만 요 시간은 언제 다시 돌아올지 알 수 없으니.</p><br/><h1 id="또-다른-시작"><a class="markdownIt-Anchor" href="#또-다른-시작"></a> 또 다른 시작</h1><p>8월부터 새 회사에 출근했다. 그렇게 시작된 우당탕탕 적응기 시즌 2! 는 작년의 시작과 참 닮아 있었다. 성격 좋은 능력자들이라 나만 잘하면 될 것 같달까. 그런 마음과 생각이 부담이 되어 또 자신감이 맨틀을 뚫고 들어갈락 말락 할 때 누군가 내 상태를 알아챘다. 내 오랜 숙제인 자신감 부족<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>이 정통으로 꿰뚫린 일은 처음이었다.</p><p>그러게. 틀리면 고치면 되고, 잘못한 건 개선하면 되는데 난 무엇 때문에 부담에 짓눌려 살았지? 짧다면 짧고 길다면 긴 n년의 커리어를 진지하게 돌아봤다. 그 끝에 욕심이 있었다. 사람이니까 흠이 있을 수도 있고, 실수를 할 수도 있는데 ‘그러고 싶지 않은’ 마음이 발목을 잡았던 거다.</p><p>그래서 인정하기로 했다. 난 부족하지만 잘하고 싶고, 잘 해내고 싶은 사람이다. 과정에선 실수가 있을 수도, 잘못된 방향으로 갈 수도 있지만 되돌리면 그만이다. ‘고작’ 그거 하나 잘못했다고 세상이 뒤집히지 않는다. 이 생각을 항상 마음에 품고 살아야겠다고 다짐한다.</p><p>그리고 이 글을 적는 지금, 어쩌면 이런 내 모습을 알아본 사람이 또 있었을지도 모르겠단 생각을 했다. 고마웠습니다.</p><br/><h1 id="덕후는-멈추지-않아"><a class="markdownIt-Anchor" href="#덕후는-멈추지-않아"></a> 덕후는 멈추지 않아!</h1><p>휴덕은 있어도 탈덕은 없다는 말이 딱이다. 23년 1월 1일을 비투비 콘서트로 시작했으며, 10월 13일부터 15일은 임현식 콘서트로 불태웠다. 3일 올콘은 고민되는 일이었지만 (구)동방신기 덕질 중 깨달음이 있었으니, '떡밥은 줄 때 먹어야 한다!'는 거다. 3일 올콘에 올 스탠딩? 까짓거 별거 아니네!</p><p>작년 여름에 나올 것 같던 앨범이 아직까지 감감무소식이다. 무소식이 희소식이라는 말을 믿고 기다려 봐야지. DIVE INTO YOU, 콘서트 이름에 딱 맞는 공연이었다. 축축함도, 산뜻함도, 고독함도, 찬란함도 느껴지는 바다와 함께한 기분이랄까. 그 시간을 다시 곱씹으니 새삼 행복해지는 게 역시 좋은 선택이었다.</p><p>누구에게나 공개할 수 있는 그런 것 말고, 조용히 오래 즐기는 인문학적(?)인 덕질도 하나 있다. 올해는 요 부분에서 성장을 체감한 의미 있는 해였다. 코로나 이후로 늘 교류하던 사람들과만 교류했었는데 오랜만에 새로운 사람들을 만나게 되어 느끼고 배운 점이 많다. 가장 의미 있던 건 다음 레벨로의 점프를 위해 나름의 계산이 된다는 것이다. 지금까진 못 했던 건데! <s>존버는 승리한다고!</s></p><br/><h1 id="이제서야-조금-이해하는-것"><a class="markdownIt-Anchor" href="#이제서야-조금-이해하는-것"></a> 이제서야 조금 이해하는 것</h1><blockquote><p>“여기 일은 솔직히… 쉬워요.”<br />“늘 쉽다고 할 순 없지만, 대체적으로 쉬워요.”</p></blockquote><p>늘 어렵진 않아도 꽤 어렵다고 생각하던 우물 안 개구리는 충격에 휩싸였다. 🙃 개발 경력 차이만으론 설명할 수 없는 '뭔가’가 있겠다 싶었다. 무엇보다 속마음을 허투루 말하는 분이 아님을 알기에 더 그랬다.</p><p>그곳을 떠난 지 1년 남짓. 지금에서야 조금은 이해할 것 같기도.</p><p>책임 없이 넘어가는 일이 비일비재하다는 것, 내가 하는 일이 조금 잘못돼도 내 밥그릇이 엎어질 경우가 드물다는 것, 업무를 뺏기더라도 그뿐이라는 것 등 그분이 말한 '일’에는 여러 의미가 포함되어 있었다. 그러니까, '개발 경력 차이’보다는 '직장인으로 겪을 수 있는 경험 차이<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>’로부터 나온 결론이 아니었을까. 그러나 후회는 없다. 아마 과거로 돌아간대도 같은 선택을 할 거다.</p><br/><h1 id="맺음글"><a class="markdownIt-Anchor" href="#맺음글"></a> 맺음글</h1><p>불확실의 끝을 달리던 시기, '어떤 선택이 최선일지 모르겠어요.'라는 말에 '지나고 보니 내가 선택한다고 착각하고 사는 거더라고요. 될 일은 어떻게 해서든 되고, 안 될 일은 어찌해도 안 되니 너무 걱정하지 마세요.'라는 위로를 받은 적이 있다. 당시에 난 '선택한다는 착각 속’이었고, 다 지난 지금에서야 '이렇게 될 일’임을 깨달은 거겠지. <strong>역시 모든 과정은 지나고 난 후에야 비로소 제대로 평가할 수 있다.</strong></p><p>그래서 23년 목표는 얼마나 달성했나요?</p><blockquote><p>올해는 나를 다져가는 해로 만들겠다고 다짐한다. 가계부도 다시 쓰고, 투자 포트폴리오도 정리하고, 보험도 들고(어린이 보험 막차 타기), 영어 공부, 개발 공부(안드로이드가 아니더라도), 그리고 건강 챙기기가 있다. 영어는 작년부터 하고 싶다는 생각만 가지고 있었는데 올해는 꼭 꾸준히 해 봐야지! 많은 경험과 사람을 만나는 것에 집중했던 작년이라면 올해는 앞으로의 내 삶을 어떻게 가꿀지 정리하는 해가 되었으면 한다.</p></blockquote><p>가계부도 다시 쓰고, 포트폴리오 정리하면서 증권사 연금 저축 계좌로 옮기는 것까지 완료했고, 보험도 성공! 영어 공부는 꾸준히 하고 싶었는데 그러지 못해서 아쉬웠고, 개발 공부…는 하긴 했는데 만족스럽진 못했다. 건강은 못 지킴. 올해만큼 자주, 많이 아팠던 해가 있었나 싶다. 2023년은 대충 65점이군요.</p><p>2024년엔 23년에 챙기지 못했던 건강 잘 챙겼으면 좋겠고, 노션도 정리하고, 돈도 열심히 모으고, '쓰는 것’에 조금 더 시간을 투자했으면 한다. 아무도 보지 않을 글이라도, 혹은 누구나 볼 수 있는 블로그라도 그냥 '쓰는 행위 자체’에 조금 더 집중하는? 기왕이면 개발 관련 글이면 좋겠지만, 그게 아니더라도 괜찮을 듯. 24년엔 12권 이상의 책을 읽었으면 하고, 프롬프트<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>와 좀 더 친해지는 해가 되었으면 한다.</p><p>에이, <mark>그냥 믿고 가는 거지 뭐. 믿음은 현실이 되니까.</mark></p><br/><div class="video-container"><iframe src="https://www.youtube.com/embed/Qk41CCabbq8" frameborder="0" loading="lazy" allowfullscreen></iframe></div><br/><blockquote><p>다른 문을 열어 따라 갈 필요는 없어<br />넌 너의 길로 난 나의 길로 음<br />하루하루마다 색이 달라진 느낌<br />밝게 빛이 나는 길을 찾아<br />I’m on my way 넌 그냥 믿으면 돼<br />I’m on my way 보이는 그대로야</p><p>너는 누군가의 Dreams come true<br />제일 좋은 어느 날의 데자뷰<br />머물고픈 어딘가의 낯선 뷰<br />I’ll be far away</p><p>That’s my<br />Life is 아름다운 갤럭시<br />Be a writer, 장르로는 판타지<br />내일 내게 열리는 건 big big 스테이지<br />So that is who I am</p><p>Look at me now<br />어제랑 또 다른 짜릿한 나<br />두려운 모든 게 설레이게<br />I’m in sky high, OMG<br />사소한 건 다 아득해져 와<br />Look at me now<br />I’m on fire</p><p>I’m on my way 넌 그냥 믿으면 돼<br />I’m on my way 보이는 그대로야<br />너는 누군가의 Dreams come true<br />제일 좋은 어느 날의 데자뷰<br />머물고픈 어딘가의 낯선 뷰<br />I’ll be far away</p><p>That’s my<br />Life is 아름다운 갤럭시<br />Be a writer, 장르로는 판타지<br />내일 내게 열리는 건 big big 스테이지<br />So that is who I am</p><p>어느 깊은 밤 길을 잃어도<br />차라리 날아올라 그럼 네가<br />지나가는 대로 길이거든<br />1, 2, 3 Fly up</p><p>I hope you’d be someone’s dreams come true<br />제일 좋은 어느 날의 데자뷰<br />머물고픈 어딘가의 낯선 뷰<br />I’ll be far away</p><p>That’s my<br />Life is 아름다운 갤럭시<br />Be a writer, 장르로는 판타지<br />내일 내게 열리는 건 big big 스테이지<br />So that is who I am</p></blockquote><br/><br/><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>선언형 UI를 이해하는 데 많은 도움이 되었다. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>혼자만의 생각이면 안 되는데요…! <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>이것저것 참 많은 시도를 했는데 이렇게까지 뭐가 안 나오는 상황도 처음이었다. (포괄적인 의미의) 누구에게 물어도 비슷한 답변이 나오던 기묘함. <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>물론 구직자이니 포트폴리오 정리, 서류, 과제, 면접 등 일련의 과정엔 성실히 임했다. <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p>진해로 출발한 날 면접 봤단 사실을 까맣게 잊고 있었다. <a href="#fnref5" class="footnote-backref">↩︎</a></p></li><li id="fn6" class="footnote-item"><p>있다가도 없고 없다가도 있다지만, 대부분 부족할 때가 많다. 자신감이 좀 생겼다 싶을 때마다 큰 실수를 해서 바닥부터 쌓아 올린 게 몇 번은 된다. 그래서 그런지 자신감이 붙을 땐 누구보다 조심스러워진다. <a href="#fnref6" class="footnote-backref">↩︎</a></p></li><li id="fn7" class="footnote-item"><p>순서가 다를 뿐 나 또한 같은 일을 겪었으니까. <a href="#fnref7" class="footnote-backref">↩︎</a></p></li><li id="fn8" class="footnote-item"><p>지니와 오래 놀았지만 AI가 너무 발전해서 슬슬 밑천 드러나는 중. <a href="#fnref8" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://d2fault.github.io/categories/Anything/">Anything</category>
      
      <category domain="https://d2fault.github.io/categories/Anything/Diary/">Diary</category>
      
      
      <category domain="https://d2fault.github.io/tags/%ED%9A%8C%EA%B3%A0/">회고</category>
      
      
      <comments>https://d2fault.github.io/2023/12/31/20231231-diary/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] 안드로이드 개발자의 디자인 시스템(모듈) 개발기</title>
      <link>https://d2fault.github.io/2023/05/07/20230507-android-design-module-development-story/</link>
      <guid>https://d2fault.github.io/2023/05/07/20230507-android-design-module-development-story/</guid>
      <pubDate>Sun, 07 May 2023 08:18:16 GMT</pubDate>
      
      <description>안드로이드 디자인 모듈을 개발하며 생긴 많은 고민과 결론을 정리한다.</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="개요"><a class="markdownIt-Anchor" href="#개요"></a> 개요</h1><p>어쩌다 디자이너 없이 디자인 시스템을 구축하게 되었느냐 물으신다면 대답해 드리는 게 인지상정! 단연코 가장 큰 이유는 역시 ‘디자인의 통일성’이라고 할 수 있다. 팀의 특성상 Sample App이나 Test App 등, product라고 할 수 없지만 공식적으로 ‘제공’해야 하는 애플리케이션들이 많은 편이다. 이 앱들은 필요에 의해 지속적으로 제공되기도 하지만 단발성으로 제공되기도 하기에 디자인이 중구난방인 상황이 발생한다. 이 부분에서 ‘디자인에 대한 고민 없이, <strong>통일된 톤 앤 매너를 제공할 방법’으로 디자인 모듈의 필요성이 대두되었다.</strong></p><p>요약하자면 다음과 같다.</p><ul><li>Product는 아니나 임시로 제공되는 앱(SampleApp, Test App 등)의 디자인이 통일되었으면 좋겠다는 니즈</li><li>디자인에 들어가는 비용 최소화</li><li><s>(가능하다면) iOS 앱도 유사한 느낌으로 제공할 수 있는 발판 마련</s></li></ul><br/><h1 id="필요한-건-알겠고-어떻게-하지"><a class="markdownIt-Anchor" href="#필요한-건-알겠고-어떻게-하지"></a> 필요한 건 알겠고, 어떻게 하지…?</h1><p>막상 시작하려 보니 고민할 포인트가 산더미처럼 쌓여 있었다. 그중 날 가장 헷갈리게 만든 두 가지 항목을 소개하려 한다. (이 두 가지가 전부였던 것 같기도 하고…?)</p><h2 id="material-3-어디까지-포함해야-하는가"><a class="markdownIt-Anchor" href="#material-3-어디까지-포함해야-하는가"></a> Material 3, 어디까지 포함해야 하는가 🧐</h2><p>디자인 모듈이 언급되었을 때, 해당 모듈이 포함될 테스트 앱에 Material 3 또한 적용해 보기로 하였다. 처음에는 ‘그럴 수 있지’의 생각이었으나, 막상 디자인 모듈 설계와 Material 3을 놓고 진지하게 고민하다 보니 ‘여긴 어디, 나는 누구?’의 상태가 되었다.</p><p>이제 와서 생각해 보면 그때의 내가 바보였다. Material 3 또한 디자인 시스템의 일종이니 디자인 시스템을 설계하는 상황<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>에서는 충돌이 발생할 수밖에. 이럴 때엔 기준을 잘 잡아야 한다는 걸 알고 있었지만 <s>처음이다 보니</s> Material 3을 어디에 포함해야 하는지, 어디까지 넣어야 하는지의 기준 잡기가 쉽지 않았다.</p><p>처음에는, <s>찝찝함을 뒤로하고</s> 이미 만들어진 디자인 시스템인 Material 3에 우리 브랜드를 녹여 보았다. 음, 좋은 시도였다고 생각한다. 가장 빠르게 만들 수 있는 방법이었으니까. 그러나 적절한 방법은 아니다. Material 버전이 업데이트된다면? <strong>Material 시스템에 종속된다는 건 결국 Material 버전에 따라 누군가는 이 디자인 모듈을 계속 수정해야 한다는 것을 의미한다.</strong></p><p>너무 당연하지만, <strong>Material 3은 디자인 모듈이 아닌 모앱에 포함되어야 한다</strong>는 결론에 도달했다. 대신, Material 3 Theme을 쉽게 적용할 수 있도록 color set의 기본값을 지정하는 정도로 마무리했다. 재정의 Component 또한 <mark><strong>Material 3과의 종속성을 끊어내고 AppCompat에 의존하도록 변경하였다.</strong></mark></p><h2 id="네이밍-네이밍-네이밍"><a class="markdownIt-Anchor" href="#네이밍-네이밍-네이밍"></a> 네이밍, 네이밍, 네이밍!!! 🔥</h2><p>하, 진짜, 할 말은 많지만 하지 못할 정도로 네이밍과 멱살 잡고 싸웠다. color부터 icon, selector 등 파일 하나 만들 때마다 수없이 고민했다. 단연코 탑은 dimen! 중복되는 값들이 많아 padding, margin 대신 spacing으로 통일하였는데 '어떤 값을 사용해야 할지 모르겠다’는 피드백을 받았고, 이 피드백을 통해 사용자 입장을 더 깊이 생각해 볼 수 있었다.</p><p>모듈 사용자 입장에서는 몇 가지 단어를 적어 보고 추천되는 값을 기반으로 적용할 텐데, ‘spacing’ 이나 ‘padding’ 만으로는 이게 ‘어디에’ 사용될 값인지 알 수 없다는 게 가장 큰 문제였다. 적은 리소스로 최대한 많은 범위를 포함하고 싶어 애매하게 정한 네이밍이 사용성을 해치는 결과를 낳았다. 🥲</p><p>위 피드백에 덧붙여, UI 적용 케이스마다 정해진 값이 있으면 편할 것 같다는 의견을 함께 받았다. 곰곰이 생각해 보니 이 방향이 맞았다. 디자인 모듈 개발 목적 중 하나는 '비용 최소화’도 있었기 때문에, 사용자 입장에서 고민할 시간을 줄이는 것 또한 모듈의 목표가 되는 게 맞다.</p><p>둥글둥글 애매모호했던 표현을 조금 더 명확하게 다듬었다. 예를 들어,  <code>default_start_spacing</code> 과 같은 모호한 표현 대신 <code>default_list_item_inner_padding_start</code> 와 같이 <mark><strong>’사용 케이스’와 '어떤 값’인지 분명히 알 수 있도록 의도했다.</strong></mark></p><br/><h1 id="그래도-어쩌겠습니까-해내야죠"><a class="markdownIt-Anchor" href="#그래도-어쩌겠습니까-해내야죠"></a> 그래도 어쩌겠습니까, 해내야죠</h1><p>0부터 시작하는 일은 몇 번을 마주해도 어렵지만 약간의 요령이 생기긴 하나 보다. 엄두가 나지 않을 땐 <strong>쪼개고 쪼개고 또 쪼개서 할 수 있는 것부터 하려고 노력한다.</strong> 쪼개고 쪼개진 것들이 모이면 덩어리가 될 테니까!</p><h2 id="할-수-있는-것-먼저-처리하자"><a class="markdownIt-Anchor" href="#할-수-있는-것-먼저-처리하자"></a> 할 수 있는 것 먼저 처리하자</h2><ol><li><p>아이콘 리소스 집어넣기</p><ul><li>쉽고 빠르게 할 수 있는 단순 노동. 아이콘은 사내에 공식 배포된 리소스가 있었기에, svg로 다운로드 후 xml로 변환하여 넣어 주었다.</li><li>네이밍은 <code>ic_mail</code> 과 같이 접두사로 <code>ic</code> 를 사용했다.</li></ul></li><li><p>color 정의하기</p><ul><li>위 문단에서 언급한 것처럼 Material 3 기준 color setup 리소스와 함께 주로 사용되는 투명 색상과 기본적으로 사용되는 브랜드 컬러를 추가했다.</li></ul></li><li><p>폰트를 넣어 볼까?</p><ul><li>NO! 굳이 몸집 키울 이유가 없다. 폰트는 필요한 경우 모앱에서 넣기로 해!</li></ul></li></ol><h2 id="size-너도-문제야"><a class="markdownIt-Anchor" href="#size-너도-문제야"></a> Size, 너도 문제야</h2><p>끝없는 싸움이었다. 🫠 모든 사이즈 정의가 불가하기 때문에 바로 사용해야 하는 값들과 함께 여기저기 막 사용할 수 있는 사이즈를 몇 가지 지정했다. 간략히 나열하자면 <code>radius</code>, <code>button_text_size</code>, <code>image_size</code>, <code>text_size</code>, <code>line_height</code> 정도?</p><p>그 외 몇 가지를 더 추가했는데, 이 값은 Material 3 dimen을 보고 힌트를 얻었다.  <code>label</code> 이나 <code>headline</code> 등, 만만하게 막 쓸 수 있는 값들을 조금 더 추가했다. 그리고 이 값들로 커버할 수 없는 값은 <code>dimen</code> 이라는 친구로 통일했다. 예를 들어  <code>dimen_2</code> 는 <code>8dp</code> 를  의미한다. (실제 dp = 접미사 * 4)</p><h2 id="버튼-너라도-많이-만들어야겠다"><a class="markdownIt-Anchor" href="#버튼-너라도-많이-만들어야겠다"></a> 버튼, 너라도 많이 만들어야겠다</h2><p>Material 3을 기준으로 AppCompat을 상속하여 Custom Button set을 정의했다. 아래 리스트가 재정의한 버튼들이다.</p><ul><li><code>Button</code><ul><li><code>Button.Filled</code></li><li><code>Button.Fit</code></li></ul></li><li><code>Button.Rounded</code><ul><li><code>Button.Rounded.Filled</code></li></ul></li><li><code>Button.FullyRounded</code><ul><li><code>Button.FullyRounded.Filled</code></li></ul></li><li><code>TextButton</code> - <code>AppCompat</code>의 <code>Button.Borderless</code> 를 재정의함<ul><li><code>TextButton.Fit</code></li></ul></li><li><code>OutlinedButton</code><ul><li><code>OutlinedButton.Rounded</code></li><li><code>OutlinedButton.FullyRounded</code></li></ul></li><li><code>ImageButton</code><ul><li><code>ImageButton.Small</code></li><li><code>ImageButton.Medium</code></li><li><code>ImageButton.Large</code></li></ul></li></ul><p>버튼 정의시 배경과 <code>selector</code> 정의<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>가 필요하다. 이 부분은 캡쳐로 대신한다.</p><img src="/images/20230507-android_design_module_development_story/1.jpg" style="zoom:50%;" /><br/><h1 id="마무리하며"><a class="markdownIt-Anchor" href="#마무리하며"></a> 마무리하며</h1><p>작업이 끝났을 때 바로 회고하는 게 가장 좋다는 걸 알면서도 늘 게으름이 이긴다. 그나마 다행인 건 작업 중 적어둔 메모의 존재와 중간중간 거친 정리 과정이겠지? 미루고 미루던 디자인 모듈 개발기를 완성할 수 있어 뿌듯한 일요일이다. 🍀 거창하고 대단하다고 할 순 없지만… AppCompat이 나온(나올 수밖에 없었던) 배경과 디자인 시스템을 이해해 보는 소중한 경험이었다. 🫡</p><br/><h1 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h1><ul><li>[<a href="https://github.com/material-components/material-components-android/tree/master/docs/components">Github] Material Components - Android</a></li><li><a href="https://m3.material.io/theme-builder#/dynamic">Material3 Theme Builder</a></li><li><a href="https://m2.material.io/design/color/the-color-system.html#tools-for-picking-colors">Material2 Color Palette Generator</a></li><li><a href="https://m3.material.io/components">Material3 공식 가이드(컴포넌트 내 여백 등 참고함)</a></li><li><a href="https://chrisbanes.me/posts/appcompat-v21/">appcompat v21: material design for pre-Lollipop devices!</a></li></ul><br/><br/><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>심지어 Material 3 가이드를 참고하여 설계하는 중이었음 🫥 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>selector 정의 안 해도 되지만… 안 하면 onClick event 발생시 ripple 효과가 안 생김 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://d2fault.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://d2fault.github.io/categories/Programming/Android/">Android</category>
      
      
      <category domain="https://d2fault.github.io/tags/design/">design</category>
      
      <category domain="https://d2fault.github.io/tags/module/">module</category>
      
      
      <comments>https://d2fault.github.io/2023/05/07/20230507-android-design-module-development-story/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Diary] 2022년 회고하기</title>
      <link>https://d2fault.github.io/2022/12/31/20221231-diary/</link>
      <guid>https://d2fault.github.io/2022/12/31/20221231-diary/</guid>
      <pubDate>Sat, 31 Dec 2022 11:12:22 GMT</pubDate>
      
      <description>어쩌다 생긴 연말 루틴으로 12월만 되면 가슴 한켠에 숙제를 안고 살아가는 기분이나 적어서 얻는 이점을 포기할 수 없기에 올해도 포기하지 않고 달그락 달그락 갈무리해 본다.</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="회고-뭐-별거-있나요"><a class="markdownIt-Anchor" href="#회고-뭐-별거-있나요"></a> 회고 뭐, 별거 있나요</h1><p>까마득한 걸 보면 꽤나 오래전인 것 같다. 싸이월드 다이어리에 Goodbye 어쩌구, Hello 어쩌구 그런 문장을 적었던 게 시작이었으려나? 간단했던 문장이 넘버링한 여러 줄이 되고, 블로그 정착 후 줄글이 되었다. 어쩌다 생긴 연말 루틴으로 12월만 되면 가슴 한켠에 숙제를 안고 살아가는 기분이나 적어서 얻는 이점을 포기할 수 없기에 올해도 포기하지 않고 달그락 달그락 갈무리를 준비해 본다.</p><br><h1 id="작년-회고-살펴보기"><a class="markdownIt-Anchor" href="#작년-회고-살펴보기"></a> 작년 회고 살펴보기</h1><blockquote><p>어떤 선택을 하든 내가 최우선이 되었으면 하는 바람으로, 올해의 첫 곡으로 <mark><strong>비투비의 Dreamer</strong></mark> 를 선정했다.</p></blockquote><div class="video-container"><iframe src="https://www.youtube.com/embed/S2Ga1x7Uw6A" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>이 곡을 선정한 여러 이유 중 가장 큰 이유는 사그라든 열정의 불꽃이 다시 타오르길 바라는 마음이었다. 3으로 시작하는 나이는 처음이니 태초마을로 돌아가 다양한 시각으로 더 많은 걸 보고 느끼고 즐기고 싶었다. 결과보다 경험에 조금 더 집중하는 그런 것.</p><blockquote><p><em>앞이 보이지 않고 세상이 휘청거려도</em><br /><em>힘차게 we need to be stronger oh baby</em><br /><em>뜻대로 되지가 않고 자꾸 어긋난대도</em><br /><em>흘러가는 시간을 타고</em></p><p><em>Do what you wanna do</em><br /><em>다 마음대로 해 네 마음대로 (다 마음대로 해 어때)</em><br /><em>하고 싶은 대로 해 좋은 날에 (하고 싶은 대로 okay)</em><br /><em>우린 아직도 꿈을 꾸고 가슴이 뜨겁게 뛰는 걸</em><br /><em>I mean feel your heartbeat oh my baby</em><br /><em>Do what you wanna do</em></p><p><em>지금 시작해도 절대 안 늦었어 it’s not too late (it’s never too late)</em><br /><em>누가 뭐라 해도 do what you wanna do it’s ok (everything gonna be ok)</em></p></blockquote><p>매년 느끼는 거지만 새해 첫 곡의 의미는 참 대단하다. 매일 그 곡을 듣고 사는 것도 아니고, 가끔 생각날 때 듣는 정도인데 지나고 나면 어쩜 이렇게 한해가 가사처럼 지나가는 건지 알 수 없다. 끼워 맞추기도 10년이면 인정해 줘야 한다고! 그러니까 올해도 가사처럼 지나갔다는 뜻이다. <mark><strong>책임감과 부담을 조금 내려두고 순간에 집중하는, 때로는 ‘어떻게든 되겠지!’ 하는 막무가내의 멘탈로 잘 버텼다</strong></mark> 는 뜻이지.</p><br><h1 id="물보라를-일으켜"><a class="markdownIt-Anchor" href="#물보라를-일으켜"></a> 물보라를 일으켜 🌊</h1><p>내 감정이나 생각이 마음대로 제어되지 않을 때 글을 쓴다. 심장이 콱 막힌 것 같은 기분이 들 때 실마리를 찾아내는 과정이라고 해야 하나. 아무튼, 노션과 페이스북 비공개 피드에 내 조각들이 남아 있다. 회고 작성 전 이 기록들을 하나씩 살펴보곤 하는데 눈물이 날 뻔했다. 다이내믹 그 잡채. 하고 싶은 일이 해야만 하는 일이 되었을 때의 스트레스 기록, 이해할 수 없는 행동에 관한 기록, 원인을 찾으려고 무던히 노력했던 감정 기복의 소용돌이 등 올해도 꽤 많은 성장을 해낸 것 같다.</p><p>내 감정이 가장 격정적이었던 순간, 범람하는 천을 보며 마음과 비슷하단 생각을 했나 보다.</p><blockquote><p>너울치는 지금을 통제하지 않으려 해. 차라리 더 많이 느끼고, 생각하는 쪽을 택할래. 그럼 자연스럽게 정리되겠지. 그게 감정이든, 생각이든, 일이든, 사람이든.</p></blockquote><p>그리고 지금, 날 이렇게 만든 사건이 무엇이었는지 기억나지 않는 걸 보아 자연스럽게 정리된 게 맞는 듯하다.</p><h1 id="역대급-소비"><a class="markdownIt-Anchor" href="#역대급-소비"></a> 역대급 소비</h1><p>올해를 소비의 해로 정의해도 과언이 아니다.</p><ul><li>(10년 넘게 고민하다 지른) 카메라 두 대(R10, g7x mark iii)</li><li>인스탁스 미니 필름 (300장은 사지 않았을까?)</li><li>보테가베네타 백</li><li>가족 선물</li></ul><p>특히 카메라는 사서 아주 유용하게 사용하고 있다. 이럴 줄 알았으면 미리 살걸 약간의 후회감이 들기도 하고, 나한테는 똑딱이가 제격이란 생각이 들기도 하고… 제주도 여행에 R10과 함께 갔다가 힘들어서 사진이고 뭐고 포기하고 싶었다. 무엇보다 바디 손떨방이 없어 열심히 찍은 영상들이 멀미 유발 영상이 되어 버린 게 가장 아쉽다. (그래서 또 지른 g7x mark iii…) 일상을 담는 정도라면 하이브리드 카메라가 딱이다. 굳이 렌즈 교환식 그런 거 필요없어! 무거워! 찍고 싶은 순간에 내 손에 있는 카메라가 최고의 카메라임!</p><p>대학생 때 무슨 경진대회 상품으로 받은 인스탁스 미니90! 오래전 혼자 홍콩 여행했을 때 유용하게 쓴 후 사용한 적이 없었다. 배터리도 방전돼서 새로 구매한 건 안 비밀. 특별한 순간 단 한 장의 사진이라는 점이 너무 매력적이라 여행 갈 때마다 챙기게 된다. 덕분에 카메라 앞에서 뚝딱이던 표정과 포즈가 ‘조금은’ 개선되어 뿌듯하다.</p><p>연말정산 결과 보고 기겁했지만 덕분에 환급도 받고… 좋은 게 좋은 거라고 생각하기로 했다. ^^</p><h1 id="떠나요-집을"><a class="markdownIt-Anchor" href="#떠나요-집을"></a> 떠나요 ✈ 집을</h1><p>정리하고 보니 거의 두 달에 한 번은 떠난 꼴이다. 이유는 모르겠지만 어쩌다 보니 그렇게 됐습니다.</p><ul><li>강릉 벚꽃 여행</li><li>속초 여행</li><li>4박 5일 자동차 여행(남쪽)</li><li>제주도 여행 2회</li><li>서유럽 3국 패키지 여행(이탈리아, 스위스, 프랑스)</li></ul><p>아무래도 가장 기억에 남는 건 유럽이다. 유로 가장 비쌀 때 간 게 조금 속이 쓰리지만 시간은 다시 돌아오지 않으니까. 패키지의 장점과 단점을 명확하게 깨달았던 여행. 이탈리아는 생각보다 너무 더웠고, 스위스 풍경은 그림보다 더 그림 같았고, 프랑스는 무언의 여유로움이 있었다. 이 여행을 기점으로 영어 회화를 향한 열정(?)[<a href="http://localhost:4000/2022/12/31/20221231-diary/#fn1">1]</a>이 솟구치고[<a href="http://localhost:4000/2022/12/31/20221231-diary/#fn2">2]</a> 있다. 23년엔 휴양지에 가 보고 싶은데 그럴 수 있겠지?</p><h1 id="떠나요-매시업을"><a class="markdownIt-Anchor" href="#떠나요-매시업을"></a> 떠나요 ✈ 매시업을</h1><p>12기를 마지막으로 매시업을 떠나기로 결정했다. 정말 마지막에 마지막에 마지막까지 고민하다 내린 결론이다. 후련함과 미련이 뒤엉킨 마음이지만 다방면으로 고민되는 것들을 두고 내 욕심 하나로 가져가는 건 이기적이라 생각했다.</p><p>매시업을 하겠다고 결심했던 순간부터 12기가 끝난 그 순간까지 돌이켜보면 감사한 일도, 힘든 일도, 소중한 추억도 참 많았다 싶다. 코로나가 아니었다면 좋은 사람들과 더 끈끈한 인연을 만들 수 있었을까? 그래도 다행인 건, 우연한 계기로 본 지원서의 내 다짐과 지난 2년의 내 모습이 다르지 않았다는 거다. 느리더라도 포기하지 않고, 채우려고 노력하고, 열심히 아이디어도 내고, 조율도 해 보고, 여러 사람들과 잘 섞여도 보았던 그 시간들이 무척이나 그리울 것 같다.</p><p>매시업이 없더라도 <strong>다양함을 경험하고 성장하는 사람이 되겠다 다짐한다.</strong></p><h1 id="떠나요-회사를"><a class="markdownIt-Anchor" href="#떠나요-회사를"></a> 떠나요 ✈ 회사를</h1><p>올해의 가장 큰 변화. 약 5년을 몸담은 회사와 작별했다. 큰 꿈은 없었지만 희망을 갖고 입사했던, 나름의 애정을 가진 회사를 떠나며 다양한 기억과 추억이 떠오른다. 진지하게 퇴사를 고민하며 내 마음을 불편하게 한 건 차곡차곡 쌓은 인간관계와 늘 함께했던 업무를 두고 간다는 점이었다. 일에는 아무런 문제가 없었다. 동료분들 모두 각자의 프로젝트와 긴 시간을 함께했기에 업무 하기가 수월했다. 다만, 회사의 행보에 희망이 생기지 않았다.</p><p>여러 문제가 있었다. 어용 노조를 포함하여 차마 글로 적을 수 없는, 직접 겪어야 알 수 있는 것들. 그러나 아이러니하게도 그 조직 안에는 업무에 최선을 다하는, 척박한 상황에서도 성공해내는 멋진 사람들이 있다. 물론 한순간의 불만으로 퇴사를 결정한 것은 아니다. 입사할 때부터 갖고 있던 의문이 3년 차 때 극에 달했고, 행동을 통한 결과를 얻어낸 게 올해였을 뿐. 바뀔 거라 믿고 버틴 게 벌써 몇 년이다.</p><p>이 회사를 나갈 경우 나의 득실을 세 가지로 나누어 보았다. 얻는 것, 잃는 것, 그리고 기대되는 것. 잃는 것도 잃기엔 아까운, 상당히 가치있는 것들이었지만 얻는 것과 기대되는 것의 가치에 더 끌렸다. 그리고 그 가치는, 나의 성장이다. 이 또한 5년을 일하며 나름의 성장을 해왔기에 선택할 수 있었다고 생각한다. 그냥, 바깥 세상이 궁금했다.</p><p>온실 속 화초에서 정글로 걸어가는 건 마냥 설레는 일은 아니다. 앞으로 이전보다 더한 고난과 역경이 닥칠 수도 있다는 것도 알지만 궁금한 걸 어떡해? 정글로 간다고 해서 날 잡아먹을 육식 동물만 있진 않겠지. <mark><strong>어디서든 내 몫을 해내는 사람이고 싶다.</strong></mark></p><h1 id="새-회사-적응기"><a class="markdownIt-Anchor" href="#새-회사-적응기"></a> 새 회사 적응기</h1><p>적응하기 위해 정말 열심히 노력 중이다. 분위기, 업무, 근무 체계, 업무 방식 등 다른 점이 너무 많다. 정적인 환경에서 동적인 환경으로 바뀐 터라 포지셔닝에 관해 고민하고 있다. 사실 이 고민은 둘째고, 진짜 고민은 ‘아무도 지적하지 않는데 뭔가 증명해야 할 것 같은’ 마음이다. 매일같이 멘탈 붕괴와 재건이 반복된다. '누군가에겐 나도 대단할 때가 있겠지, 나도 유독 잘하는 부분이 있겠지’라고 되뇌여도 자꾸 무너지는 걸 어떡하니~</p><p>처음 겪는 일이라 생각했는데 문득 떠오른 순간이 있었다. 세상 사람 다 똑똑한데 나만 바보인 것 같은 기분을 느끼던 그 해에 나는 큰 성장을 이뤘다. 지금 이 버거움도 성장통의 일종이리라. 현명하게 잘 견뎌내겠다고 다짐해 본다.</p><p>내 의지로 할 수 있는 건 몸이 무너지지 않도록 하는 것 뿐. 아이러니하게도 <strong>같이 일하는 분들은 하나같이 너무 좋다.</strong> 잘 챙겨 주시고, 다정하고, 따뜻하다. 결국 이 스트레스는 모두 나에게서 기인한 것이란 의미이겠지? 몸으로 올 스트레스를 잘 털어내야겠다.</p><h1 id="문화-생활과-취미"><a class="markdownIt-Anchor" href="#문화-생활과-취미"></a> 문화 생활과 취미</h1><p>문화 생활 한 거라곤 넷플릭스 보기, 음악 듣기, 두 번의 사진전, 싸이 흠뻑쇼, 사운드베리페스타, 그리고 한 편의 뮤지컬[<a href="http://localhost:4000/2022/12/31/20221231-diary/#fn3">3]</a>이 전부이다…라고 적으려고 했는데 열거하고 보니 생각보다 많이 즐겼네? 그래도 문화보단 여행에 조금 더 집중했던 거로.</p><p>사운드베리페스타 이야기를 빼 놓을 수가 없다. 양일권으로 갔는데 이튿날에 비가 너무 많이 와서 힘들었다. 갑자기 태풍이요? 그래도 포기 안 하고 양일 다 간 내가 위너다. HYNN(박혜원)의 음악 스타일을 좋아하지 않음에도 불구하고 노래를 너무 잘해서 듣는 내내 정신이 혼미했다. 특히 ‘막차’ 라이브 때 처음 들은 곡임에도 불구하고 눈물 줄줄 흘렸던 건 비밀. 이직이 되냐 마냐, 하는 게 맞냐 아니냐 등을 두고 고민하던 때라 더욱 와닿았던 것 같다. 10cm 보고 덕통사고(원래 좋아하긴 했지만) 당해서 몇 주 내내 10cm 노래만 들었고, 소란의 무대 매너 끝내줬고, 상큼한 최예나, 음색이 좋았던 조유리, 낯가리던 이석훈, 목 상태가 아쉬웠던 볼빨간 사춘기, 늘 안정적인 잔나비, 목소리에 진심이 묻어나는 박재정 등 정말 많은 무대가 날 행복하게 했다. 윤하 언니… 비가 너무 와서 못 봤는데… 갈 걸 그랬어…</p><p>그리고 몇 년을 놓지 못하는 취미, 노래. 조금씩 흩어진 퍼즐을 하나씩 끌어다 맞추는 중이다. 퍼즐이 있다는 게 어디며, 이만큼 나아진 게 어디야. 갈 길이 멀지만 존버는 승리하니까! <strong>하다 보면 또 늘겠지.</strong></p><p>책을 거의 안 읽은 건 반성해야 한다. <strong>미디어 시청 시간을 좀 줄이는 게 좋겠다.</strong></p><h1 id="회고를-맺으며"><a class="markdownIt-Anchor" href="#회고를-맺으며"></a> 회고를 맺으며</h1><p>12월 중순부터 회고를 위해 달렸지만 올해도 밀렸다. 중요한 건 꺾이지 않는 다짐. 올해의 끝에서 작년의 다짐을 얼마나 지켜내었는지 확인해 보아야겠지?</p><blockquote><p>작년보다 조금 더 여유롭고, 건강하고, 기초를 탄탄히 하는 해가 되었으면 한다. 욕심 대신 순간을 소중하게 여기고, 나에게 주어진 기회들과 행복을 누리는 한해가 되길.</p></blockquote><p>여유를 갖고 다방면의 경험을 쌓는 해였고, 퇴라피로 건강을 ‘잠깐’ 되찾았으며, 기초를 탄탄히 하고자 했으나 빈 곳을 모두 채우는 건 쉽지 않은 일이었다. 점수를 따지면 70점? 위의 문장을 적으며 '2022년에는 이직할지도 모르겠다.'라는 생각을 했는데 그 일이 현실이 될 줄은 몰랐습니다. 우당탕탕 정신없는 한해였지만 그래도 어떻게 저떻게 잘 보낸 듯하다. (회고도 12월 중순부터 미리 쓰기 시작한 거 칭찬해!)</p><p>올해는 나를 다져가는 해로 만들겠다고 다짐한다. 가계부도 다시 쓰고, 투자 포트폴리오도 정리하고, 보험도 들고(어린이 보험 막차 타기), 영어 공부, 개발 공부(안드로이드가 아니더라도), 그리고 건강 챙기기가 있다. 영어는 작년부터 하고 싶다는 생각만 가지고 있었는데 올해는 꼭 꾸준히 해 봐야지! 많은 경험과 사람을 만나는 것에 집중했던 작년이라면 올해는 <mark><strong>앞으로의 내 삶을 어떻게 가꿀지 정리하는 해가 되었으면 한다.</strong></mark></p><p>이런 마음을 담아 친구들과 함께 들은 올해의 첫 곡은</p><p><br><div class="video-container"><iframe src="https://www.youtube.com/embed/fLO78eN0nQM" frameborder="0" loading="lazy" allowfullscreen></iframe></div></p><br><p><strong>김동률의 '출발’</strong> 이다.</p><blockquote><p>아주 멀리까지 가보고 싶어<br />그 곳에선 누구를 만날 수가 있을지<br />아주 높이까지 오르고 싶어<br />얼마나 더 먼곳을 바라볼 수 있을지</p><p>작은 물병 하나 먼지 낀 카메라<br />때 묻은 지도 가방 안에 넣고서<br />언덕을 넘어 숲 길을 헤치고<br />가벼운 발걸음 닿는대로<br />끝없이 이어진 길을 천천히 걸어가네</p><p>멍하니 앉아서 쉬기도 하고<br />가끔 길을 잃어도 서두르지 않는 법<br />언젠가는 나도 알게 되겠지<br />이 길이 곧 나에게 가르쳐 줄 테니까</p><p>촉촉한 땅바닥 앞서간 발자국<br />처음 보는 하늘 그래도 낯익은 길<br />언덕을 넘어 숲 길을 헤치고<br />가벼운 발걸음 닿는 대로<br />끝없이 이어진 길을 천천히 걸어가네</p><p>새로운 풍경에 가슴이 뛰고<br />별것 아닌 일에도 호들갑을 떨면서<br />나는 걸어가네 휘파람 불며<br />때로는 넘어져도 내 길을 걸어가네</p><p>작은 물병 하나 먼지 낀 카메라<br />때 묻은 지도 가방 안에 넣고서<br />언덕을 넘어 숲 길을 헤치고<br />가벼운 발걸음 닿는 대로<br />끝없이 이어진 길을 천천히 걸어가네</p><p>내가 자라고 정든 이 거리를<br />난 가끔 그리워 하겠지만<br />이렇게 나는 떠나네 더 넓은 세상으로</p></blockquote><p>처음 마주할 것들이 많으리라 예상되는 2023도 지지 않으며, 또 가끔 지며 다채롭게 채워 봐야지!</p><br><br>]]></content:encoded>
      
      
      <category domain="https://d2fault.github.io/categories/Anything/">Anything</category>
      
      <category domain="https://d2fault.github.io/categories/Anything/Diary/">Diary</category>
      
      
      <category domain="https://d2fault.github.io/tags/%ED%9A%8C%EA%B3%A0/">회고</category>
      
      
      <comments>https://d2fault.github.io/2022/12/31/20221231-diary/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[GoodNote] 2023 굿노트 다이어리, 프리노트 무료 배포</title>
      <link>https://d2fault.github.io/2022/12/25/20221225-2023-goodnote-diary-and-free-note-templates-for-free/</link>
      <guid>https://d2fault.github.io/2022/12/25/20221225-2023-goodnote-diary-and-free-note-templates-for-free/</guid>
      <pubDate>Sun, 25 Dec 2022 13:36:22 GMT</pubDate>
      
      <description>이 다이어리의 가장 큰 목적은 업무 플래너이기에 위클리만 제작하였으며, 시작하는 요일도 월요일로 만들었다. 사이즈는 일반적인 다이어리 크기인 A5로 설정하였고, 프린트가 필요할 경우 모아찍기로 두 페이지를 A4 한 장에 넣을 수 있도록 했다.</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="preview"><a class="markdownIt-Anchor" href="#preview"></a> Preview</h1><img src="/images/20221225-2023_goodnote_diary_template_for_free/1.jpeg" style="zoom:50%;" /><br><h1 id="설명"><a class="markdownIt-Anchor" href="#설명"></a> 설명</h1><p>올해 다이어리 표지 색상은 <mark>팬톤에서 선정한 2023 올해의 컬러인 ‘비바 마젠타’</mark> 로 선택했다. 벌써 세 번째 제작한 플래너로, <s>게으름과 여러 시행착오 끝에</s> 이제서야 첫 배포를 해 본다.</p><p>이 다이어리의 <mark><strong>가장 큰 목적은 '업무 플래너’이기에 위클리만 제작하였으며, 시작하는 요일도 월요일로 만들었다.</strong></mark> 사이즈는 일반적인 다이어리 크기인 A5로 설정하였고, 프린트가 필요할 경우 모아찍기로 두 페이지를 A4 한 장에 넣을 수 있도록 했다. 위클리가 모두 모눈인 이유는 딱히 없다. 개인적으로 모눈을 가장 선호하기에 그렇게 설정하였다.</p><p>맨 마지막 페이지에는 'DIARY’와 'MEMO’가 포함되어 있는데, 개인적으로 이 공간은 다이어리와 함께 배포되는 프리 노트를 이용하여 채운다. 위클리는 대부분 업무 관련 내용만 적고 다이어리 쪽에 프리 노트를 추가하여 사용한다. 맨 뒤쪽 메모의 경우 위클리 칸이 넘칠 경우<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 사용한다.</p><p>프리 노트는 크게 모눈, 무지, 라인으로 나누어 제작했다. 가장 자주 쓰는 것은 모눈 4분할이다. 프리노트의 라인 색상 또한 ‘비바 마젠타’ 계열의 붉고 옅은 톤으로 설정했다.</p><br><h1 id="이걸-굳이-왜-직접"><a class="markdownIt-Anchor" href="#이걸-굳이-왜-직접"></a> 이걸 굳이 왜 직접…?</h1><p><strong>만들고 싶지 않았다.</strong> 굿노트 무료 템플릿, 굿노트 심플, 굿노트 심플 노트 등 여러 키워드로 검색했는데 마땅한 템플릿을 찾지 못했을 뿐… 다꾸 용도 말고 딱 업무에 쓰기 좋은 노트를 찾을 수가 없어 전적으로 나에게 맞는 형식으로 직접 만들었다. 위클리는 딱 투두 리스트 정도만 작성할 수 있도록 간단하게 만들고, 길어지는 내용은 뒤쪽으로 뺄 수 있게 했다. <strong>(이 방식 또한 수많은 시행착오 끝 얻어낸 결론이다.)</strong></p><p>놀랍게도 이 템플릿은 <strong>모두 파워포인트로 만들었다.</strong></p><br><h1 id="사용-폰트"><a class="markdownIt-Anchor" href="#사용-폰트"></a> 사용 폰트</h1><ul><li><a href="https://fontsgeek.com/fonts/Franklin-Gothic-Medium-Regular">Franklin Gothic Medium</a></li><li><a href="https://fonts.google.com/specimen/Oswald">Oswald-Regular_Medium</a></li><li><a href="https://www.dafontfree.io/bahnschrift-font/">Bahnschrift Light SemiCondensed</a></li><li><a href="https://noonnu.cc/font_page/59">서울남산체 B</a></li><li><a href="https://noonnu.cc/font_page/60">서울한강체 B</a></li></ul><br><h1 id="다운로드"><a class="markdownIt-Anchor" href="#다운로드"></a> 다운로드</h1><ul><li><a href="/images/20221225-2023_goodnote_diary_template_for_free/2023_diary_d2fault.pdf">2023 다이어리 다운로드</a></li><li><a href="/images/20221225-2023_goodnote_diary_template_for_free/2023_free_note_d2fault.zip">2023 Free Note 다운로드</a></li></ul><br><p><mark><strong>무단 배포 및 임의 수정을 엄격히 제한<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>합니다.</strong></mark></p><br><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>아이디어 노트, 개발 노트, 회의록, 자산 관리 등 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>개발자가 머리 싸매고 잡은 디자인 막 카피하고 그러는 건 정말이지…말도 안 된다고 생각함.😐 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://d2fault.github.io/categories/Blog/">Blog</category>
      
      <category domain="https://d2fault.github.io/categories/Blog/Information/">Information</category>
      
      
      <category domain="https://d2fault.github.io/tags/goodnote/">goodnote</category>
      
      <category domain="https://d2fault.github.io/tags/%EA%B5%BF%EB%85%B8%ED%8A%B8/">굿노트</category>
      
      <category domain="https://d2fault.github.io/tags/%ED%85%9C%ED%94%8C%EB%A6%BF/">템플릿</category>
      
      
      <comments>https://d2fault.github.io/2022/12/25/20221225-2023-goodnote-diary-and-free-note-templates-for-free/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] ContentObserver 알아보기</title>
      <link>https://d2fault.github.io/2022/07/21/20220721-android-contentobserver/</link>
      <guid>https://d2fault.github.io/2022/07/21/20220721-android-contentobserver/</guid>
      <pubDate>Thu, 21 Jul 2022 13:02:33 GMT</pubDate>
      
      <description>타 패키지 내 콘텐츠 변경시 이벤트 수신 방법을 알아본다.</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="개요"><a class="markdownIt-Anchor" href="#개요"></a> 개요</h1><p>타 패키지의 DB 값을 <code>ContentProvider</code> 로 읽어오는 로직 개발 중 DB 값이 변경되었을 때의 이벤트를 수신하고 싶었다. 가장 쉽게 구현하는 방법으로는 DB 변경을 알려주는 <code>Intent</code> 규격을 하나 생성하는 것이겠지만, 구글링을 통해 내가 원하는 기능을 Android 플랫폼에서 자체적으로 제공한다는 사실을 알아냈다! (나만 몰랐던 이야기…?)</p><p>단, <code>ContentObserver</code>는 Oreo 이상에서만 동작한다. Oreo 미만 단말에서는 <code>Intent</code> 를 사용해야 하겠지요?</p><br><h1 id="contentobserver-가-뭔데"><a class="markdownIt-Anchor" href="#contentobserver-가-뭔데"></a> <code>ContentObserver</code> 가 뭔데?</h1><p>이름 그대로 ‘Content를 관찰’하다가 변경이 생겼을 때 알려주는 친구다. 즉, 우리는 변경을 관찰하고 싶은 <code>URI</code> 를 등록하기만 하면 된다. <code>BroadcastReceiver</code> 사용할 때와 동일하게 ‘등록’ 과정이 있기 때문에 모든 사용이 끝난 후에는 꼭! 메모리 누수 방지를 위한 <strong>등록 해제가 필수이다.</strong></p><br><h1 id="사용법"><a class="markdownIt-Anchor" href="#사용법"></a> 사용법</h1><h2 id="contentobserver-등록"><a class="markdownIt-Anchor" href="#contentobserver-등록"></a> <code>ContentObserver</code> 등록</h2><p><code>context</code> 로부터 <code>contentResolver</code> 에 접근할 수 있으며, 여기까지 접근하면 <code>registerContentObserver</code> 로 observer를 등록할 수 있다. 해제가 필수이기 때문에 등록한 <code>ContentObserver</code> 객체를 유지하고 있어야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ContentObserver 생성하여 변수에 유지함</span></span><br><span class="line"><span class="keyword">val</span> contentObserver = <span class="keyword">object</span> : ContentObserver(Handler()) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onChange</span><span class="params">(selfChange: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onChange(selfChange)</span><br><span class="line">        <span class="keyword">if</span> (selfChange) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 이 이벤트 발생시의 동작 정의</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// context에서 contentResolver에 접근하여 ContentObserver 등록</span></span><br><span class="line">with(context.contentResolver) &#123;</span><br><span class="line"><span class="comment">/* notifyForDescendants: Boolean */</span></span><br><span class="line"><span class="comment">//  true: 하위 경로의 변경도 관찰</span></span><br><span class="line"><span class="comment">//  false: URI 경로의 변경만 관찰</span></span><br><span class="line">registerContentObserver(URI, <span class="literal">true</span>, contentObserver)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="contentobserver-등록-해제"><a class="markdownIt-Anchor" href="#contentobserver-등록-해제"></a> <code>ContentObserver</code> 등록 해제</h2><p>유지하고 있던 <code>contentObserver</code> 를 이용하여 등록을 해제한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.contentResolver.run &#123;</span><br><span class="line">    unregisterContentObserver(contentObserver)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h1 id="유의-사항"><a class="markdownIt-Anchor" href="#유의-사항"></a> 유의 사항</h1><p>사실 위 과정은 변경하는 쪽에서 알려주지 않으면 말짱 도루묵이다. <strong>DB를 수정하는 부분에서 아래 코드를 꼭! 추가해 주어야 한다.</strong> (직접 해 봤는데 얘 없인 진짜 안 된다.)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.contentResolver.apply &#123; notifyChange(uri, <span class="literal">null</span>) &#125;</span><br></pre></td></tr></table></figure><br><h1 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h1><ul><li><a href="https://developer.android.com/reference/android/content/ContentResolver#registerContentObserver(android.net.Uri,%20boolean,%20android.database.ContentObserver)">Android 공식 Document: registContentResolver</a></li><li><a href="https://developer.android.com/reference/android/content/ContentResolver#unregisterContentObserver(android.database.ContentObserver)">Android 공식 Document: unregistContentResolver</a></li><li><a href="https://aroundck.tistory.com/129">ContentObserver 뭐하는 녀석인지 알아봅시다.</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://d2fault.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://d2fault.github.io/categories/Programming/Android/">Android</category>
      
      
      <category domain="https://d2fault.github.io/tags/contentprovider/">contentprovider</category>
      
      <category domain="https://d2fault.github.io/tags/contentobserver/">contentobserver</category>
      
      
      <comments>https://d2fault.github.io/2022/07/21/20220721-android-contentobserver/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] Process VS Task</title>
      <link>https://d2fault.github.io/2022/04/03/20220403-android-process-vs-task/</link>
      <guid>https://d2fault.github.io/2022/04/03/20220403-android-process-vs-task/</guid>
      <pubDate>Sun, 03 Apr 2022 07:27:55 GMT</pubDate>
      
      <description>안드로이드의 Process와 Task를 알아본다.</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="개요"><a class="markdownIt-Anchor" href="#개요"></a> 개요</h1><p>안드로이드 Activity의 <code>launchMode</code> 에 대해 공부하던 중에 <code>process</code> 와 <code>task</code> 개념을 확실하게 하기 위해 포스팅을 작성한다.</p><br><h1 id="process-task"><a class="markdownIt-Anchor" href="#process-task"></a> Process? Task?</h1><p>안드로이드 애플리케이션을 실행하면 Process가 생성된다. 이 Process는 애플리케이션마다 별도로 생성되며, 애플리케이션이 종료될 때 Process도 종료된다.</p><p>그렇다면 Task는 언제 생성될까? Task는 현재 생성된 Task가 없을 때에 생성되고, 이미 생성된 Task가 있다면 그 Task에 Activity 정보를 저장한다.</p><ul><li><code>Process</code><ul><li>애플리케이션의 독립적인 실행 단위</li></ul></li><li><code>Task</code><ul><li><strong>프로세스와 무관하게 실행되는 액티비티의 정보를 저장</strong>하는 공간</li></ul></li></ul><br><h1 id="task에-activity-정보를-언제-저장하는데"><a class="markdownIt-Anchor" href="#task에-activity-정보를-언제-저장하는데"></a> Task에 Activity 정보를 언제 저장하는데?</h1><p>예를 들어 보자. 메신저 앱에서 친구에게 사진을 보내고 싶을 때 우리는 '앨범’에서 사진을 선택하여 전송한다. 이때, 앨범 앱이 올라왔다가 내려가게 되는데 이 상황을 Task 기준으로 그림을 그려 보면 다음과 같다.</p><ol><li><p>메신저 앱이 띄워진 상태</p><img src="/images/20220403-android_process_vs_task/1.jpeg" style="zoom:20%;" /></li><li><p>‘사진 첨부’ 버튼을 눌러 앨범을 띄운 상태</p><img src="/images/20220403-android_process_vs_task/2.jpeg" style="zoom:20%;" /></li><li><p>사진을 선택하고 ‘확인’ 버튼을 눌러 메신저 앱에 돌아간 상태</p><img src="/images/20220403-android_process_vs_task/1.jpeg" style="zoom:20%;" /></li><li><p>사진을 다 보내고 애플리케이션을 종료하여 런처(홈 화면)로 돌아간 상태</p><img src="/images/20220403-android_process_vs_task/3.jpeg" style="zoom:20%;" /></li></ol><p>화면에 보이는 Activity에 따라 Task에 저장된 Activity 정보가 달라지는 것을 볼 수 있다. 단, <mark><strong>Task에 저장된 것이 ‘Activity’ 가 아닌 'Activity 정보’임을 유의해야 한다.</strong></mark></p><br>]]></content:encoded>
      
      
      <category domain="https://d2fault.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://d2fault.github.io/categories/Programming/Android/">Android</category>
      
      
      <category domain="https://d2fault.github.io/tags/process/">process</category>
      
      <category domain="https://d2fault.github.io/tags/task/">task</category>
      
      
      <comments>https://d2fault.github.io/2022/04/03/20220403-android-process-vs-task/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Book] 이것이 안드로이드다 with 코틀린</title>
      <link>https://d2fault.github.io/2022/02/20/20220220-book-review-this-is-android-with-kotlin/</link>
      <guid>https://d2fault.github.io/2022/02/20/20220220-book-review-this-is-android-with-kotlin/</guid>
      <pubDate>Sun, 20 Feb 2022 05:07:16 GMT</pubDate>
      
      <description>하나! 코틀린이 낯설다고요? 걱정하지 마세요, 코틀린 기본 문법부터 설명합니다. 안드로이드 앱 개발은 자바와 코틀린 이 두 가지 언어로 할 수 있는데요. 구글이 안드로이드 공식 언어로 코틀린을 채택한 뒤로 코틀린은 안드로이드를 학습하는 데 필수 언어가 되었습니다.</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="책-소개"><a class="markdownIt-Anchor" href="#책-소개"></a> 책 소개</h1><p><a href="http://book.naver.com/bookdb/book_detail.naver?bid=21396053"><img src="/images/20220220-book_review_this_is_android_with_kotlin/1.JPG" alt="" /></a></p><p>이미지를 클릭하시면 네이버 책으로 이동합니다.</p><br><h1 id="책-정보"><a class="markdownIt-Anchor" href="#책-정보"></a> 책 정보</h1><blockquote><p>하나! 코틀린이 낯설다고요? 걱정하지 마세요, 코틀린 기본 문법부터 설명합니다.<br />안드로이드 앱 개발은 자바와 코틀린 이 두 가지 언어로 할 수 있는데요. 구글이 안드로이드 공식 언어로 코틀린을 채택한 뒤로 코틀린은 안드로이드를 학습하는 데 필수 언어가 되었습니다. 이 책은 코틀린을 모르는 독자도 앱을 개발할 수 있도록 안드로이드 앱 개발에 필요한 코틀린 기본 문법부터 설명합니다. 앱 개발에 꼭 필요한 내용을 모두 담았습니다.</p><p>둘! 안드로이드 프로그래밍의 기초, UI 구성과 생명주기부터 설명합니다.<br />안드로이드 스튜디오를 설치하고 기본 화면 구성부터 설명합니다. 위젯과 레이아웃을 다루고, 액티비티와 컨테이너, 뷰를 통해서 화면 전체를 컨트롤하는 방법을 순서대로 설명합니다. 설명을 따라 작성하는 작은 프로젝트는 나중에 실전 프로젝트에 활용할 수 있습니다.</p><p>셋! 실무에서 사용하는 앱 개발에 필요한 개발 지식을 다룹니다.<br />앱 개발은 단순히 코틀린 언어를 익히고 안드로이드의 화면을 구성한다 해서 완성할 수 있는 게 아닙니다. 네트워크나 데이터베이스와 파일 입출력, 오픈 API 등 안드로이드 앱 개발에 필요한 다양한 개발 지식을 다루고 실습합니다.</p><p>넷! 실전 프로젝트를 포함한 70개의 예제로 다양한 기능을 실습합니다.<br />실생활에서 가장 많이 사용하는 사진, 카메라, 타이머, 메모장, 음악 플레이어, 오픈 API를 활용한 서울시 도서관 찾기 프로젝트 등을 제공합니다. 또한 3판에서는 파이어베이스를 활용한 실시간 채팅 앱과 맵 클러스터링 등 다양한 실습을 추가로 제공합니다. 여러 기능을 익히고 활용하여 맞춤형 앱을 개발해보세요.</p></blockquote><br><h1 id="리뷰"><a class="markdownIt-Anchor" href="#리뷰"></a> 리뷰</h1><h2 id="피할-수도-피해서도-안-되는-kotlin"><a class="markdownIt-Anchor" href="#피할-수도-피해서도-안-되는-kotlin"></a> 피할 수도, 피해서도 안 되는 Kotlin</h2><p>안드로이드 개발에 처음 입문한 건 2015년 초, MVC 패턴이 주를 이뤘고, 이벤트 버스와 버터나이프가 언급되며, 간간히 Eclipse와 Android Studio를 같이 쓰던 때였다. 그때를 생각하면 지금이 양반이다 싶지만, 만족스러운 성장을 했느냐를 묻는다면 당당히 그렇다고 답변할 순 없을 것 같다.</p><p>안드로이드에 Kotlin이 대세가 된 것도 벌써 몇 년이 지났다. 회사에서는 여전히 Java를 사용하고 있었기에, Kotlin을 사용할 수밖에 없는 환경에 나를 몰아넣기로 했다. 그렇게 시도한 것이 <code>1. MashUp(동아리)</code> 과 <code>2. 사내 프로젝트에 Kotlin 도입</code> 이었다. 매시업 덕분에 2020년에 드디어 Kotlin과 직접적<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>으로 마주할 수 있었다.</p><p>Kotlin과 안드로이드에 천천히 익숙해질 때쯤 사내 프로젝트<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>를 하나 맡게 되었다. 기획, 설계, 개발, 테스트, 배포, 가이드 제작까지 모두 직접(물론 혼자) 해야 하는 일이었다. 이미 이렇게 받은 일이 두 번째<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>이기에, 이번에는 새로운 도전을 해 보기로 했다. 이 프로젝트를 팀 내 첫 번째 순수 코틀린 프로젝트로 만들기로 결심<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>한 것이다. 그런데, 아무래도 Java에 익숙해져 있다 보니 코틀린에 손에 착 붙진 않았다. <mark><strong>가장 공들였던 부분이 바로 Null Safety, 지연 초기화, 스코프 함수, 그리고 확장 함수였다.</strong></mark></p><img src="/images/20220220-book_review_this_is_android_with_kotlin/2.jpg" style="zoom:50%;" /><p>이 부분은 Kotlin 언어 이해도에 따라 설계 효율성이 달라지는데, 위 사진처럼 Kotlin 언어에 대해서도 친절하고 자세히 적혀 있어서 내가 짠 코드를 다시 한번 되돌아볼 수 있는 계기가 되었다. 책에는 <a href="https://kotlinlang.org/docs/extensions.html">확장 함수</a> 내용이 포함되지 않아 아쉽긴 했지만, 확장 함수는 Kotlin의 특징 중 하나이기에 이 책에서 다루는 게 약간의 오버(?)처럼 느껴질 수도 있을 듯하다.</p><br><h2 id="안드로이드-서비스-개발자의-숙명-레이아웃view"><a class="markdownIt-Anchor" href="#안드로이드-서비스-개발자의-숙명-레이아웃view"></a> 안드로이드 서비스 개발자의 숙명, 레이아웃(View)</h2><p>다정함과 세심함에 놀랐던 파트이다. 이미 어느 정도 안드로이드 지식을 갖고 있는 나에게는 아는 내용이 대부분이었지만, 입문자도 어렵지 않게 따라갈 수 있도록 디테일을 잡았다.</p><img src="/images/20220220-book_review_this_is_android_with_kotlin/3.jpg" style="zoom:30%;" /><p>에디터 구성을 우선적으로 설명하고, 그 아래 ‘여기서 잠깐’ 파트를 만들어 난감할 수 있는 상황에 대한 해결법을 함께 제시했다는 점이 인상깊었다. 후배가 생긴 이후로 '어디서부터 얼마나, 어떻게 설명해야 하는지’에 대해 늘 고민하던 나에게 깨달음이 되었다.</p><p>그 뒤에 나오는 내용은 위젯을 어떻게 배치할 수 있는지, 그리고 각 위젯에서 자주 사용하는 속성에 관한 내용을 설명하고 있었는데, 차근차근 훑어보며 늘상 책상에 두고 읽고 싶다고 생각했다. 업무 특성 상 레이아웃과 그리 친하진 않은지라 위젯 속상은 매번 ‘이게 뭐가 있었는데, 뭐더라…’ 라고 생각하며 검색<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>하곤 했었다. 이젠 귀찮은 검색 대신 잊어버릴 때마다 책을 여러 번 읽기로 다짐했다.</p><br><h2 id="그-외에도"><a class="markdownIt-Anchor" href="#그-외에도"></a> 그 외에도</h2><p><strong>현업에서 개발할 때 자잘자잘하게 신경써야 하는 부분을 언급해 주어 고마운 책이었다.</strong> 특히, ‘권한 체크’ 가 필수인 몇 가지 항목들이 있는데, 위험 권한 승인 팝업을 띄우고 결과를 전달받는 예제 코드가 있다는 것이 꽤나 매력적<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>이었다. 무엇보다 후반부로 갈 수록 참고할 내용<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>이 많아져서, 두고두고 읽을 좋은 참고서를 만났다는 생각에 기분이 좋아졌다. 가장 좋았던 건, <strong>매 챕터마다 시작 전 간략하게 무엇을 할 것인지 목표를 설명한다</strong>는 점이다. 그 부분만 잠깐 읽어 보면 이 챕터의 내용이 필요한 것인지, 그렇지 않은 것인지 구분할 수 있다는 이점이 있었다.</p><br><h1 id="누구에게-추천할-것인가"><a class="markdownIt-Anchor" href="#누구에게-추천할-것인가"></a> 누구에게 추천할 것인가?</h1><p>한빛미디어에서 제안한 이 책의 추천 독자는 다음과 같다.</p><blockquote><p>* 이 책이 필요한 독자<br />· 코틀린은 처음이다.<br /><mark><strong>· 만들고 싶은 앱이 있다.</strong></mark><br />· 안드로이드 앱 개발자가 되고 싶다.<br />· 입사 후 의지와 상관없이 업무상 앱 개발을 담당하고 있다.<br />· 우연히 유튜브 강의로 접하고 본격적으로 앱 개발을 하고 싶다.</p></blockquote><p>위 리스트 모두에게 추천하고 싶지만, 꼭 봐야만 하는 딱 하나의 독자를 고르자면 <strong>만들고 싶은 앱이 있는 독자</strong>이다. 이 책은 가벼이 넘길 수 있는 문제도 세심하게 알려주는 친절함이 돋보이는 책이지만, 프로젝트 베이스로 진행되는 책은 아니다. 그 말인 즉, 명확한 목표가 없다면 많은 것을 얻지 못할 수 있다는 것. 그러나 역으로, 내가 만들고 싶은 앱이 있고 그 방법에 대한 것을 고민하는 중이라면 누구보다 많은 것을 얻어갈 수 있다고 생각한다.</p><p>추가로, <strong><u>코드 타이핑 없이 안드로이드 개발의 느낌을 살펴보고 싶다면 5장의 액티비티를 읽은 다음 4장의 위젯과 리소스 다루기를 읽어보는 것을 추천한다.</u></strong> 우선 책에 제시된 예제 코드들을 보며 흐름과 코드 구성을 한번 생각해 보고 여유가 될 때 4장의 위젯과 리소스를 직접 만들어 보아도 된다.</p><p>그리고 개인적으로는 언어’만’을 공부하는 것에 큰 흥미를 느끼지 못해서 코드로 부딪힌 다음 빈 지식을 도큐먼트를 읽으며 채우는 편이다. 그런 의미에서 개발의 기초 지식이 있는 분들은 <strong>초반의 Kotlin 언어 파트를 스킵하고 필요할 때마다 보는 것도 나쁘지 않은 선택이라고 생각한다.</strong></p><p>꿀팁을 하나 남기자면, 한빛미디어에서 <a href="https://www.youtube.com/playlist?list=PLVsNizTWUw7GMJ_jrWYsvIUHRq_XfjPA2">무료 동영상 강의</a>를 제공한다. 아직 영상을 보진 못했지만, 영상 리스트로 봤을 땐 기본 지식이 없지만 당장 현업에 사용해야 할 때 급하게 볼 수 있을 정도의 강의인 것 같아서 종종 애용하지 않을까 싶다.</p><br><p><em>위 서평은 한빛미디어 &lt;나는 리뷰어다&gt; 활동을 위해서 책을 제공받아 작성되었습니다.</em></p><br><br><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>언제나 시도하긴 했었다. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>안드로이드 라이브러리(SDK) 개발 관련 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>안드로이드 SDK 개발기는 <a href="https://d2fault.github.io/2021/10/31/20211031-how-to-architect-android-sdk/">이 포스팅</a>에 기록했다. <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>결심 이후 팀장님과 팀원들의 동의를 받아 시작했다. <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p>자주 안 쓰다 보니 자꾸 까먹는다. 키워드가 생각이 날 듯 말 듯할 때 적당히 검색해서 사용하기 신공… <a href="#fnref5" class="footnote-backref">↩︎</a></p></li><li id="fn6" class="footnote-item"><p>꼭 필요하지만 귀찮은 일이기에 베이스 코드를 미리 만들어 두면 도움이 될 듯하다. 어차피 늘상 사용해야 하는 것이기 때문. <a href="#fnref6" class="footnote-backref">↩︎</a></p></li><li id="fn7" class="footnote-item"><p>코루틴, Room, 서비스, 구글 지도, 네트워크, 파이어베이스 등 안드로이드 개발시 언젠가 한 번은 꼭 사용하게 되는 것들에 관한 내용이 풍부했다. <a href="#fnref7" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://d2fault.github.io/categories/Anything/">Anything</category>
      
      <category domain="https://d2fault.github.io/categories/Anything/Review/">Review</category>
      
      
      <category domain="https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/">리뷰</category>
      
      <category domain="https://d2fault.github.io/tags/android/">android</category>
      
      <category domain="https://d2fault.github.io/tags/%EC%B1%85/">책</category>
      
      
      <comments>https://d2fault.github.io/2022/02/20/20220220-book-review-this-is-android-with-kotlin/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Diary] 2021년 회고하기</title>
      <link>https://d2fault.github.io/2021/12/31/20211231-diary/</link>
      <guid>https://d2fault.github.io/2021/12/31/20211231-diary/</guid>
      <pubDate>Fri, 31 Dec 2021 13:36:42 GMT</pubDate>
      
      <description>2021년을 회고한다.</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="회고-전-변명"><a class="markdownIt-Anchor" href="#회고-전-변명"></a> 회고 전 변명</h1><p>2020 회고에는 회고 전 반성, 2021년 회고에는 회고 전 변명~! 같은 실수를 반복하는 인간이라지만 올해는 그러지 않기 위해 나름의 노력을 기울이긴 했다. 1월 초에 카페에 가서 회고에 쓸 내용 정리도 미리 해 놓았는데 하필 게으름이 발동할 게 뭐람. 정리만 해 두고 글을 쓰지 않은 내 죄이지 뭐. 그래도 한 가지 변명을 추가하자면, 연말 이사로 인해 정신이 하나도 없어서 그랬다. 10년 묵은 짐을 버리고 정리하고 치운다고 미리미리 고생했는데 치워도 치워도 끝이 없어서<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 여기가 지옥이구나, 싶었는걸. 포기하지 않은 게 어디야!</p><br><h1 id="2020년-회고-살펴보기"><a class="markdownIt-Anchor" href="#2020년-회고-살펴보기"></a> 2020년 회고 살펴보기</h1><p>2020년을 코로나로 아쉽게 보냈기 때문일까, 2021년은 그것보단 안정적이길 바라는 모습이 회고에 담겨 있었다.</p><blockquote><p>2021년은 사랑과 애정으로 따뜻함이 넘치는 한해가 되길 기도하며 <mark><strong>비투비포유의 Show your love</strong></mark> 을 새해 첫곡으로 선정했다.</p></blockquote><div class="video-container"><iframe src="https://www.youtube.com/embed/0FQ1Fk1RYJc" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>그러지 않았어야 했다. 이 곡을 듣지 않는 게 더 좋을 뻔했다.</p><blockquote><p><em>어둠이 내려 앞이 보이지 않아 길을 잃었어</em><br /><em>이 세상은 왜 아름답기보단 아프기만 한지?</em><br /><em>많은 사람이 넘어지고 많은 눈물이 넘쳐흘러</em><br /><em>우린 필요해요 서로에게 힘이 돼야 해, oh</em></p></blockquote><p>들으면서도 불안하긴 했어. 도입부 가사부터 희망, 행복이 아닌 아픔이잖아? Show your love를 듣고 Show my love로 행한 한해가 되어 버렸다. 유독 2021년은 마더 테레사의 마음으로 많이 울고, 많이 품고, 있는 사랑 없는 사랑 다 꺼내서 보듬어야만 편해질 수 있는 날들이 좀 많았던 것 같다.</p><br><h1 id="default-busy"><a class="markdownIt-Anchor" href="#default-busy"></a> default: <code>busy</code></h1><p>어느 순간부터 바쁘다는 이야기를 입과 손끝에 달고 사는 것 같아서 최대한 이 단어를 사용하지 않기 위해 노력하는 중이다. 이런 노력에도 불구하고 2021년은 내내 바쁘고, 바쁘고, 바빴다고밖에 표현할 수 없다는 게 조금은 서글프다. 회사 신규 프로젝트만 두 개(물론 기존 업무는 그대로)에, 동아리 활동까지 병행한다고 몸이 남아나질 않았다. 내 실력이 좋았다면 이렇게까지 슬프진 않았을 거라는 생각에 알게 모르게 현타도 많이 느꼈다. 그래도 1.5마리 토끼는 잡았으니 불행 중 다행!</p><br><h2 id="신규-프로젝트를-두-개나요-저-혼자요"><a class="markdownIt-Anchor" href="#신규-프로젝트를-두-개나요-저-혼자요"></a> 신규 프로젝트를 두 개나요? 저 혼자요?</h2><p>네, 혼자요. 첫 번째 프로젝트는 그나마 나까지 두 명. 두 번째 프로젝트는 정말 오롯이 혼자. 이제 와서 하는 이야기지만, 많이 힘들고 괴로웠다. 잘못한 게 없는데 혼나고, 왜 혼나는지도 모르고 혼나고… 치욕스러워 울고, 억울해서 울고, 어려워서 울고, 힘들어서 울고… 글을 적다 보니 재택 근무 중 내가 너무 답답하고 바보 같아서 그대로 침대에 누워 엉엉 울었던 순간이 문득 떠오른다.</p><p><img src="/images/20211231-diary/1.jpeg" alt="" /></p><p>어차피 미래의 내가 해야 하는 일이었고, 해내지 못하리란 생각은 없었지만… 그땐 그냥 졌다. 때론 다 내려놓고 지는 게 추진력을 얻기 위한 방법이 되기도 하니까. <a href="https://d2fault.github.io/2021/10/31/20211031-how-to-architect-android-sdk/">결론적으로 해냈으니(그것도 꽤나 잘) 됐다.</a></p><br><h2 id="두-번째-토끼-매시업"><a class="markdownIt-Anchor" href="#두-번째-토끼-매시업"></a> 두 번째 토끼, 매시업</h2><p>내 마음속 첫 번째 토끼이나, 현실적인 이유로 늘 두 번째 토끼가 되고 말아 늘 미안하고 고마운 마음 뿐이다. 부족한 실력임에도(물론 성장하곤 있다지만) 친절하게 알려주고, 도와주는 친구들이 있어 이만큼 버틸 수 있었다. 바쁜 건 내 사정이기에, 최소한 피해는 주지 않으려 많이 노력했지만 노력한 만큼의 아웃풋이 나오지 않아 더 미안하고 속상했다.</p><h3 id="계속-하고-싶었지만-그럴-수-없었던-것"><a class="markdownIt-Anchor" href="#계속-하고-싶었지만-그럴-수-없었던-것"></a> 계속 하고 싶었지만 그럴 수 없었던 것</h3><p>10기 팀 토닥토닥에서 만든 속닥속닥은 계속 갖고 가고 싶은 프로젝트였지만 그러지 못했다. 과중한 업무로 인한 야근으로 시간을 내기 어려웠고, 와중에 다음 기수까지 시작되어 이 프로젝트를 지속하는 것은 무리라는 생각이 들었다. 너무나도 귀여운 디자인과 많은 애정을 갖고 만든(기여도가 그리 높진 않았지만…) 프로젝트인 만큼 놓기가 어려웠다. 마음이 애려요. ㅠ_ㅠ</p><h3 id="끝까지-해내려-노력했던-것"><a class="markdownIt-Anchor" href="#끝까지-해내려-노력했던-것"></a> 끝까지 해내려 노력했던 것</h3><p>11기 팀 헬타버스의 헬시업은 생각보다 복잡해저버린 유저 시나리오로 인해 꽤 잦은 회의를 했던 것 같다. 개발 중에 이상한 게 생기면 당일 회의도 했었고, 또 각 파트끼리도 많은 이야기를 나눈 프로젝트였다. 초반에 비해 프로젝트 마무리 단계에서의 흥미가 많이 사라졌던 점이 가장 아쉽다. 목표했던 기여도(50%)에 미치진 못했지만 그래도 '내가 할 수 있는 일’을 했다는 뿌듯함을 느꼈고, 내 업무의 의미를 깨우친 계기가 되어 나에게 큰 의미가 되었다. 다음 기수에 볼 수 없는 친구들이 있다는 걸 조금 일찍 알았다면 더 좋았을 거다. 아마 나는 그 친구들을 종종 생각할 거야. (갑자기 분위기 고백)</p><br><h2 id="어-취미의-상태가"><a class="markdownIt-Anchor" href="#어-취미의-상태가"></a> 어? 취미의 상태가?</h2><p>역시 사람이 바쁘면 취미에 투자하는 시간부터 줄어드나 보다. 2019년 말에 미쳐 있었던 메이플 스토리는 확실하게 보내 버렸고, 20년 초에 찍먹했던 로스트아크도 조금 하다가 말았다. 그나마 남은 게 롤? 꽤나 진심으로 몇 달을 했던 것 같은데, 이마저도 연말엔 손도 못 댔다.</p><p>운동도 마찬가지다. 사회적 거리두기와의 밀고 당기기 덕분에 헬스장 운영 시간이 하루가 멀다하고 들쑥날쑥했고, 연초에 발목을 크게 접지른 덕분에 흥미를 잃었으며, 불가능해진 정시 퇴근으로 인해 운동 시간을 내기가 어려웠다. 설령 시간이 난다 한들 갈 힘이 없었다. 모든 힘을 다 쏟고 왔는데 무슨 힘으로 운동을 해요!</p><p>그래서 더 방에 처박혔나 보다. 넷플릭스와 유튜브를 반복하며 문화 생활을 즐겼다. 가장 기억에 남는 드라마는 <code>선배, 그 립스틱 바르지 마요</code> 와 <code>그냥 사랑하는 사이</code> 를 꼽겠다. 둘 다 원진아 배우가 주연으로 나온 작품인데, 그 립스틱 바르지 말라는 드라마 보다가 원진아의 매력에 스며들어 그런 것임! (실제로 <code>그냥 사랑하는 사이</code> 가 추천 영상으로 떴을 때 주연이 원진아라는 이유로 주저않고 선택했다.)</p><p>그나마 취미다운 취미로 남은 건 보컬. 만 2년을 꼬박 채웠다. 회사 일이 너무 바빠 한 달 정도 쉬었던 것 빼고는 거의 매 주 1시간씩 수업에 참여하고 있다. 아직 많이 부족하지만 이전에 비하면 양반이지. 너무 오래 다녀서 선생님이 징그럽다고 하셨다. (애정 섞인 징그러움이라고 믿을게요…?) 하면 할수록 실력이 늘긴 늘어서 신기하고, 욕심나고, 더 잘하고 싶다. <sup>_</sup></p><br><h2 id="가장-큰-이벤트"><a class="markdownIt-Anchor" href="#가장-큰-이벤트"></a> 가장 큰 이벤트</h2><p>이사. 드디어 이사. 몇 년 전부터 이야기만 나오던 이사를 2021년 12월 15일!!! 드디어 했다. 10년 묵은 짐 버린다고 고생도 많이 했고, 와서도 정리한다고 한참을 괴로워했다. 이삿날이 수요일이라 휴가 쓰기도 애매하고, 또 이사 있던 주 주말에는 해운대 여행 간다고 정신이 하나도 없었던 건 함정이다. 짐 정리도 안 됐는데 짐을 챙겨서 가려니 정신이 하나도 없었지만 그때 본 바다가 아직도 눈앞에 아른거린다. 바다 최고야, 늘 짜릿해.</p><br><h1 id="회고를-마무리하며"><a class="markdownIt-Anchor" href="#회고를-마무리하며"></a> 회고를 마무리하며</h1><p>이 회고가 쓰여져야 했던 건 21년 12월 31일, 회고 아웃라인 작성은 22년 1월 1~2일, 회고 초안 작성은 22년 3월 1일, 그리고 코로나 확진으로 인해 회고 업로드는 오늘(22년 3월 9일)이 되었다. 집에만 있으래서 집에만 있었는데 집에서 걸린 건 그냥 운이 없었다고밖에 생각되지 않는다.</p><p>2022년을 시작하며 스물이 떠올랐다. 나는 과연 그때보다 더 나은 사람일까. 그리고 곧 다가올 마흔이 두려워졌다. 그땐 지금보다 더 많은 것을 이루고, 많은 것을 알고 싶다는 욕심 때문이겠지.</p><blockquote><p>가장 먼저, 운동 놓지 않고 꾸준히 하기를 꼽고 싶다. 운동으로 얻은 이점이 많아. 잠깐 쉴 수는 있겠지만 그만두지 않았으면 한다. <strong>노래, 책, 운동</strong>은 올해도 안고 가는 걸로. 약간의 욕심을 부리자면 <strong>오토 트레이딩 시스템</strong>을 만들어 보고 싶기는 한데… <strong>블로그 리뉴얼</strong>을 먼저 끝내고 <strong>꾸준히 포스팅</strong>하는 게 우선이라고 봅니다. <strong>안드로이드 개발 실력</strong>은 지금보다 150% 올리고 싶습니다. (주관적인 수치 주의)</p></blockquote><p>운동을 안 놓고 하긴 했다. 노래는 꾸준히 했고, 책은 많이 줄었지만 그래도 보긴 봤다. 오토 트레이딩 시스템은 생각만으로 그쳤고, 블로그 리뉴얼은 마무리하긴 했는데 적용하지 못했고, 포스팅도 꽤 많이 하긴 했으나 만족스럽진 못했다. (그래도 이전 포스팅에 비해 수준이 약간은 올라간 느낌이라 기분은 좋음) 개발 실력은 많이 늘었다. 고생한 만큼 늘었다. 대충 7점 만점에 4점 정도네.</p><p>올해 목표는 작년보다 심플하다. 작년보다 조금 더 여유롭고, 건강하고, 기초를 탄탄히 하는 해가 되었으면 한다. 욕심 대신 순간을 소중하게 여기고, 나에게 주어진 기회들과 행복을 누리는 한해가 되길.</p><br><div class="video-container"><iframe src="https://www.youtube.com/embed/S2Ga1x7Uw6A" frameborder="0" loading="lazy" allowfullscreen></iframe></div><br><p>어떤 선택을 하든 내가 최우선이 되었으면 하는 바람으로, 올해의 첫곡으로 <mark><strong>비투비의 Dreamer</strong></mark> 를 선정했다.</p><blockquote><p>Ey listen up<br />Do what you wanna do<br />It’s your life<br />Dreamers don’t die</p><p>Do what you wanna do<br />다 마음대로 해 네 마음대로 (다 마음대로 해 어때)<br />하고 싶은 대로 해 좋은 날에 (하고 싶은 대로 okay)<br />우린 아직도 꿈을 꾸고 가슴이 뜨겁게 뛰는 걸<br />I mean feel your heartbeat oh my baby<br />Do what you wanna do</p><p>오늘따라 하늘이 높네 기분도 날아갈 듯해 (watcha wanna do, wanna do)<br />상쾌한 내음 한 모금해 뭐라도 해야 할 듯해 (watcha wanna do)<br />Um wanna do do 어쩐지 하나도 두렵지 않음<br />Let’s do it do it dreams come true</p><p>앞이 보이지 않고 세상이 휘청거려도<br />힘차게 we need to be stronger oh baby<br />뜻대로 되지가 않고 자꾸 어긋난대도<br />흘러가는 시간을 타고</p><p>Do what you wanna do<br />다 마음대로 해 네 마음대로 (다 마음대로 해 어때)<br />하고 싶은 대로 해 좋은 날에 (하고 싶은 대로 okay)<br />우린 아직도 꿈을 꾸고 가슴이 뜨겁게 뛰는 걸<br />I mean feel your heartbeat oh my baby<br />Do what you wanna do</p><p>지금 시작해도 절대 안 늦었어 it’s not too late (it’s never too late)<br />누가 뭐라 해도 do what you wanna do it’s ok (everything gonna be ok)<br />네 인생이니까 take control (take control)<br />Right left forward back yeah wherever you wanna go (wherever)<br />Do what you have to do until you can do what you wanna do<br />네 자신을 믿고 don’t be afraid (hey)</p><p>앞이 보이지 않고 세상이 휘청거려도<br />힘차게 we need to be stronger oh baby<br />You’re the star of your life 아무도 대신 못 해<br />영원히 다시 오지 않을 이 밤을 위하여</p><p>Do what you wanna do<br />다 마음대로 해 네 마음대로 (다 마음대로 해 어때)<br />하고 싶은 대로 해 좋은 날에 (하고 싶은 대로 okay)<br />우린 아직도 꿈을 꾸고 가슴이 뜨겁게 뛰는 걸<br />I mean feel your heartbeat on my baby<br />Do what you wanna do</p><p>Do what you wanna do<br />Do what you wanna do<br />다 마음 가는 대로 해 어때<br />모든 마음대로 하고 싶은 대로 해 okay<br />Let’s do it do it do it<br />미치고 싶고 숨쉬고 싶고<br />아직도 난 꿈꾸고 싶어<br />아직도 난 아직도 찬란히 빛나고 있어 okay</p><p>Do what you wanna do<br />Do what you wanna do<br />다 마음 가는 대로 해 어때<br />모든 마음대로 하고 싶은 대로 해 okay<br />Let’s do it do it do it<br />미치고 싶고 숨쉬고 싶고<br />아직도 난 꿈꾸고 싶어<br />아직도 난 아직도 찬란히 빛나고 있어 okay</p><p>Whatever you want<br />Do it</p></blockquote><br><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>2022.03.01 현재까지도 남아 있는 짐덩이가 아주 많다. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://d2fault.github.io/categories/Anything/">Anything</category>
      
      <category domain="https://d2fault.github.io/categories/Anything/Diary/">Diary</category>
      
      
      <category domain="https://d2fault.github.io/tags/%ED%9A%8C%EA%B3%A0/">회고</category>
      
      
      <comments>https://d2fault.github.io/2021/12/31/20211231-diary/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] SDK를 어떻게 설계하고 개발했는가</title>
      <link>https://d2fault.github.io/2021/10/31/20211031-how-to-architect-android-sdk/</link>
      <guid>https://d2fault.github.io/2021/10/31/20211031-how-to-architect-android-sdk/</guid>
      <pubDate>Sun, 31 Oct 2021 13:01:54 GMT</pubDate>
      
      <description>안드로이드 SDK를 기획, 설계, 개발, 테스트한 썰 푼다.</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="개요"><a class="markdownIt-Anchor" href="#개요"></a> 개요</h1><p>기존에 내가 하던 업무는 하이브리드 앱 개발을 위한 API를 설계하고, 제공하는 것이었다. 어쨌거나 유지보수이기 때문에 일은 늘 비슷했다. <s>(어떻게든 구조를 개선해 보고자 노력했지만 혼자만의 노력이었다는 후문이^_ㅠ)</s> 그러던 중 굉장히 갑작스럽게 SDK를 기획, 설계, 개발, 테스트까지 해야 하는 상황이 되었다. 그것도 상반기에 하나, 하반기에 하나 총 두 건이나… 유경험자나 인력은 당연히 없었기 때문에 <strong>바닥부터 시작해야 했다.</strong></p><p>그래서 이 글은, SDK를 위해 북도 치고 장구도 친 삽질기이다.</p><br><h1 id="설계부터-막막해요"><a class="markdownIt-Anchor" href="#설계부터-막막해요"></a> 설계부터 막막해요</h1><p>안드로이드 개발자라면 새로운 프로젝트 설계 시 이미 만들어진 패턴(MVC, MVP, MVVM 등) 중 프로젝트에 적합한 패턴을 적용한다. 그리고 나 또한, 첫 번째 SDK를 설계할 때 MVVM 패턴을 적용하고자 했다. 결론은, “어떻게 저떻게 돌아는 가지만 이게 최선일까?” 의 SDK가 되고 말했다. 구조 설계에만 꽤 오랜 시간(약 1.5달)을 썼는데도 불구하고 왜 이런 결과물이 산출되었을까? 내가 제공하고자 하는 SDK의 기능이 MVVM 패턴과 똑 떨어지지 않았기 때문이다.</p><h2 id="첫-번째-sdk-설계하기"><a class="markdownIt-Anchor" href="#첫-번째-sdk-설계하기"></a> 첫 번째 SDK 설계하기</h2><p>이 SDK의 경우 특히 ‘통신’ 부분에 신경을 써야 했다. 요구 조건은 다음과 같다.</p><ol><li>이 SDK는 커스텀 웹뷰를 제공한다.</li><li>웹뷰에 URL을 load하는 것은 SDK이다. (SDK에서 loadUrl을 호출한다. 네이티브 앱은 WebView를 import만 함.)</li><li>웹뷰에 load된 웹 사이트는 SDK가 제공하는 API를 호출하고, 응답을 받아야 한다.</li><li>단말 내에 설치된 다른 앱과 Intent로 통신해야 한다.</li><li>특정 API의 경우 서버와 통신해야 하며, 그 결과를 웹에게 전달해야 한다.</li></ol><img src="/images/20211031-how_to_architect_android_sdk/1.png" style="zoom:50%;" /><p>SDK에 붙은 화살표가 무려 세 개! 이 구조에서 MVVM이라, 거의 우겨넣은 것과 다름이 없었다. 어쨌거나 <mark><strong>기존 구조에서 사용하든 무한 callback 대신, ViewModel에 정의해 둔 LiveData의 값을 바꾸어 호출에 따른 응답을 전달하도록 구조를 개선한 것은 꽤 의미있는 시도였다.</strong></mark> 그러나 이것도 LiveData대신 RxJava를 사용하는 것이 더 낫지 않았을까 싶다.</p><br><h2 id="두-번째-sdk-설계하기"><a class="markdownIt-Anchor" href="#두-번째-sdk-설계하기"></a> 두 번째 SDK 설계하기</h2><p>이 SDK의 경우 최근에 설계하고 개발 중인 건으로 디테일한 정보를 오픈할 수는 없지만, 간략하게나마 요구 조건을 살펴보자.</p><ol><li>Native App은 하고자 하는 동작을 함수로 호출할 수 있다.</li><li>SDK는 이미 설치된 다른 여러 앱들과 Intent로 통신한다.</li><li>SDK는 호출된 함수의 결과를 callback으로 전달해 주어야 한다.</li><li>추후 init key check 과정이나 로깅이 필요할 경우, 서버와 통신해야 할 수도 있다.</li></ol><p>두 번째 SDK의 특징은 어떠한 View도 제공하지 않는다는 것이다. 흔히 사용하는 패턴을 적용할 수 없었기에 내맘대로 구조를 잡고 패키지를 분리했다. Native App에서 호출하는 함수가 담긴 class는 <code>service</code> 패키지에, 상수는 <code>constants</code> 패키지에, Intent receiver는 <code>receiver</code> 패키지에 위치시켰다.</p><p>그런데 <strong><u>Native App에게 이 기능을 '어떻게 제공’해야 하는지는 아무리 고민해도 결론이 안 났다.</u></strong> 난관에 봉착했다.</p><br><h1 id="힌트-찾아-삼만리"><a class="markdownIt-Anchor" href="#힌트-찾아-삼만리"></a> 힌트 찾아 삼만리</h1><p>보통 SDK는 aar 형태로 배포하기 때문에 타인의 코드를 참고하는 게 쉽지 않다. 이가 없으면 잇몸이라고, 순간적으로 모두에게 열려 있는 도큐먼트가 떠올랐다. 유레카! 역시 답은 <a href="https://developers.kakao.com/docs/latest/ko/getting-started/sdk-android">카카오 API 가이드 문서에 있었다.</a></p><img src="/images/20211031-how_to_architect_android_sdk/2.png" style="zoom:50%;" /><p><code>LinkClient.instance.isKakaoLinkAvailable(context)</code> 과 <code>LinkClient.instance.customTemplate(context, templateId)</code> 를 보고 머리를 탁 쳤…지만 코틀린 조무래기 입장에서는 저 형태를 어떻게 만들어내야 할지도 고민이었다. 그 순간 갑자기 <strong>매셥 안드팀의 점냥(재료)님이</strong> 떠올랐습니다. ^^ (늘 이렇게 고민하는 상황이 되면 누군가를 붙잡고 이야기를 막 쏟아내는데 그러다 보면 답이 나와서 신기하다. 되도 않는 이야기 늘 들어주시는 주변 분들께 감사를 전합니다.)</p><br><img src="/images/20211031-how_to_architect_android_sdk/3.png" style="zoom:40%;" /><br><p>카카오 API 도큐먼트와 점냥님의 도움으로 SDK 제공 부분까지 설계할 수 있었다.</p><br><h1 id="번외-이-값은-숨기고-싶은데"><a class="markdownIt-Anchor" href="#번외-이-값은-숨기고-싶은데"></a> (번외) 이 값은 숨기고 싶은데?</h1><p>SDK를 포함한 테스트 앱 개발 중 SDK에서만 사용하고 싶은 함수나 값들이 테스트 앱에서도 접근이 되는 것을 확인했다. 테스트 앱에서 접근을 막으려면  <code>public</code> 도, <code>private</code> 도 아닌 그 사이의 접근 제어자가 필요했는데 코틀린이 이걸? <code>internal</code> 을 사용하니 모든 게 깔끔하게 해결됐다. 예를 들어, class 생성시  <code>internal</code> 을 붙이면 해당 class는 같은 모듈(SDK) 에서만 접근이 가능하다.</p><p>아직까진 Java가 더 익숙하기에 Java로 개발했으면 어떻게 설계했을까 생각해 보았는데, class 내에 <code>protected</code> 를 열심히 선언해 주지 않았을까 싶다. (그런데 class 전체를 숨기고 싶을 땐 어떻게 해야 하지? <s>Java 눈 감아</s>)</p><br><h1 id="무엇을-느꼈나요"><a class="markdownIt-Anchor" href="#무엇을-느꼈나요"></a> 무엇을 느꼈나요?</h1><p>두 SDK를 직접 기획, 설계, 개발, 테스트까지 도맡아 하며 알게 모르게 실력이 향상되었나 보다. 처음으로 SDK 설계할 땐 “아직 4년차인데 내가 할 수 있을까?” 라는 생각이 지배적이었다면, 두 번째는 구조부터 떠올랐을 정도의 성장이랄까. 이번 개발 건으로 SDK에 흥미를 느꼈고, 기왕이면 이 커리어를 계속 갖고 가고 싶다는 생각을 했다.</p><p>그리고 무엇보다, 유저 친화적인 설계를 위해 노력한 내 자신 칭찬해. 사용하는 입장에서 제공하는 입장이 되어 보니 카카오가 SDK를 리뉴얼한 이유를 깨달았다. 사용할 땐 '아, 수정 개발 귀찮게! 카카오는 이걸 왜 다 바꾼 거야?'의 스탠스였다면, 지금은 <mark><strong>부정적인 반응을 예상했음에도 불구하고 과감하게 뒤엎은 카카오를 리스펙한다.</strong></mark> 더 멀리, 더 오래 가기 위한 결단이었겠지. (사실, 네이버가 아닌 카카오 API 도큐먼트를 참고한 이유도 리뉴얼 사실을 알고 있었기 때문이다. ^^;)</p><p>아쉬운 건, 함께 논의할 사람이 없다는 점이다. 다행스럽게도 주변에 안드로이드 개발자가 많아서(매셥 짱!) 궁금한 게 생길 때마다 함께 답을 찾아가곤 있지만 아무래도 업무이다 보니 디테일한 내용을 공유할 수는 없었다. 머리 맞대고 함께 성장할 사람이 있으면 좋겠다. 혹은 사수라도.</p><p>마지막으로, <mark><strong>디자인 패턴에 대해 열린 마음을 가지게 되었다.</strong></mark> 패턴이라고 할 게 없는 앱을 유지보수하며 늘 패턴에 목말라 있었다. 지금에 와서 생각해 보면, 다들 사용하는 것을 사용하지 않는 것에 대한 불안감 때문이 아니었나 싶다. MVVM을 적용해 보고 그에 어긋나는 부분을 발견하며 이것이 최선이 아님을 몸소 깨닫다 보니 패턴은 만능이나 절대적인 게 아닌 취사선택의 대상임이 더욱 확실해졌다. 때로는 <strong>구글에서 제안한 아키텍쳐보다 내가 고안(?)한 아키텍쳐가 더 나을 수 있음을…!</strong></p><br><h1 id="마무리하며"><a class="markdownIt-Anchor" href="#마무리하며"></a> 마무리하며</h1><p>하고 싶은 말은 많았지만 막상 업무에 직결되는 이야기를 덜어내니 공유할 수 있는 내용이 별로 없어서 아쉽다. 요즘은 1차 릴리즈 목표치의 70% 정도 개발을 완료해 두었고, 테스트 앱을 만들고 있다. 이용 가이드도 직접 만들어야 하기 때문에 할 일이 태산이긴 하지만 그래도 <mark><strong>4년차에 SDK 개발을 리딩(?)한 커리어가 흔한 커리어는 아니라는 생각으로 즐겁게 개발하고 있다.</strong></mark></p><p>그리고 무엇보다, 팀 내 최초 Kotlin 프로젝트를 생성했다는 것만으로도 뿌듯하고 감격스럽다. 이 시도로 kotlin과 많이 친해졌다. 초기 코드와 지금 코드를 비교하면 엄청난 변화를 느낄 수 있다고요! <strong>어제 짠 코드가 오늘 부끄럽다면 잘하고 있다는 거니까.</strong> <s>(요새는 범위 지정 함수와 확장 함수를 눈여겨보는 중이다. 아직까진 kotlin 코드에서 Java가 느껴져요. ㅠ)</s></p><br>]]></content:encoded>
      
      
      <category domain="https://d2fault.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://d2fault.github.io/categories/Programming/Android/">Android</category>
      
      
      <category domain="https://d2fault.github.io/tags/kotlin/">kotlin</category>
      
      <category domain="https://d2fault.github.io/tags/android/">android</category>
      
      <category domain="https://d2fault.github.io/tags/sdk/">sdk</category>
      
      <category domain="https://d2fault.github.io/tags/architect/">architect</category>
      
      
      <comments>https://d2fault.github.io/2021/10/31/20211031-how-to-architect-android-sdk/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] Fullscreen(Full Window, 전체 화면) Custom Dialog 만들기</title>
      <link>https://d2fault.github.io/2021/08/29/20210829-fullscreen-custom-dialog/</link>
      <guid>https://d2fault.github.io/2021/08/29/20210829-fullscreen-custom-dialog/</guid>
      <pubDate>Sun, 29 Aug 2021 14:01:35 GMT</pubDate>
      
      <description>이번 포스팅에서는 전체 화면으로 Dialog를 띄우는 방법에 대해 알아볼 것이다. 전체 화면으로 동작하는 Dialog를 만드는 방법으로는 크게 두 가지가 있다.</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="개요"><a class="markdownIt-Anchor" href="#개요"></a> 개요</h1><p>이번 포스팅에서는 전체 화면으로 Dialog를 띄우는 방법에 대해 알아볼 것이다. 전체 화면으로 동작하는 Dialog를 만드는 방법으로는 크게 두 가지가 있다.</p><ol><li>Dialog처럼 보이는 Activity를 만들어 띄우기</li><li>Dialog를 Customizing하여 Fullscreen으로 띄우기</li></ol><p>둘 중 어떤 것이 베스트라고 할 수는 없지만, 기왕이면 '다이얼로그’라는 이름답게 2번 방식을 따라 보기로 했다. 최초 작성 코드 언어는 java였으나 kotlin으로 변경하였고, <code>findViewById</code> 대신 <code>ViewBinding</code> 을 적용하였다.</p><br><h2 id="완성본-미리-보기"><a class="markdownIt-Anchor" href="#완성본-미리-보기"></a> 완성본 미리 보기</h2><p>SHOW DIALOG 버튼 클릭시 Fullscreen으로 동작하는 Dialog가 출력되고, SUBMIT/CANCEL 버튼 클릭 이벤트와 동시에 Toast가 출력되는 예제 앱이다.</p><img src="/images/20210829-fullscreen_custom_dialog/1.gif" style="zoom:50%;"/><br><h1 id="코드-작성"><a class="markdownIt-Anchor" href="#코드-작성"></a> 코드 작성</h1><p><code>MyCustomDialog</code> 라는 이름의 Project를 empty activity로 생성하고, <code>build.gradle</code> 에 <code>viewBinding</code> 사용 선언을 우선 해 주어야 한다.</p><figure class="highlight groovy"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    viewBinding &#123;</span><br><span class="line">    enabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>app 수준의 <code>build.gradle</code> 에 위 코드를 추가하고 sync 버튼을 눌러 준다.</p><br><h2 id="레이아웃-작업하기"><a class="markdownIt-Anchor" href="#레이아웃-작업하기"></a> 레이아웃 작업하기</h2><p><code>activity_main.xml</code> 파일 정 가운데에 SHOW_DIALOG 버튼을 생성한다.</p><figure class="highlight xml"><figcaption><span>activity_main.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=&quot;@+id/showDialogButton&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;SHOW DIALOG&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf=&quot;parent&quot;</span><br><span class="line">        tools:ignore=&quot;HardcodedText&quot; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><br><p><code>dialog_full_activity.xml</code> 파일을 <code>res/layout</code> 에 생성한 다음 아래 코드를 넣어 준다.</p><figure class="highlight xml"><figcaption><span>dialog_full_activity.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;#E6003049&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;androidx.constraintlayout.widget.ConstraintLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:padding=&quot;20dp&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintHorizontal_bias=&quot;1.0&quot;</span><br><span class="line">        app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintVertical_bias=&quot;0.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/titleTextView&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_marginBottom=&quot;21dp&quot;</span><br><span class="line">            android:lineSpacingExtra=&quot;4sp&quot;</span><br><span class="line">            android:textColor=&quot;#ee6c4d&quot;</span><br><span class="line">            android:textSize=&quot;16.5sp&quot;</span><br><span class="line">            app:layout_constraintBottom_toTopOf=&quot;@id/messageTextView&quot;</span><br><span class="line">            app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">            app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">            tools:text=&quot;@string/default_dialog_title&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/messageTextView&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:lineSpacingExtra=&quot;4sp&quot;</span><br><span class="line">            android:textColor=&quot;#FFFFFF&quot;</span><br><span class="line">            android:textSize=&quot;22.5sp&quot;</span><br><span class="line">            app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">            app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">            app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">            app:layout_constraintTop_toTopOf=&quot;parent&quot;</span><br><span class="line">            tools:text=&quot;@string/default_dialog_message&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Button</span><br><span class="line">            android:id=&quot;@+id/submitButton&quot;</span><br><span class="line">            android:layout_width=&quot;138dp&quot;</span><br><span class="line">            android:layout_height=&quot;0dp&quot;</span><br><span class="line">            android:layout_marginTop=&quot;30dp&quot;</span><br><span class="line">            android:layout_marginEnd=&quot;3.75dp&quot;</span><br><span class="line">            android:backgroundTint=&quot;#012a4a&quot;</span><br><span class="line">            android:letterSpacing=&quot;-0.05&quot;</span><br><span class="line">            android:lineSpacingExtra=&quot;1.3sp&quot;</span><br><span class="line">            android:text=&quot;@string/default_dialog_submit_caption&quot;</span><br><span class="line">            android:textColor=&quot;#ffffff&quot;</span><br><span class="line">            android:textSize=&quot;13.5sp&quot;</span><br><span class="line">            app:layout_constraintEnd_toStartOf=&quot;@id/cancelButton&quot;</span><br><span class="line">            app:layout_constraintHorizontal_chainStyle=&quot;packed&quot;</span><br><span class="line">            app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">            app:layout_constraintTop_toBottomOf=&quot;@+id/messageTextView&quot;</span><br><span class="line">            app:layout_constraintVertical_chainStyle=&quot;packed&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Button</span><br><span class="line">            android:id=&quot;@+id/cancelButton&quot;</span><br><span class="line">            android:layout_width=&quot;138dp&quot;</span><br><span class="line">            android:layout_height=&quot;0dp&quot;</span><br><span class="line">            android:layout_marginStart=&quot;3.75dp&quot;</span><br><span class="line">            android:layout_marginTop=&quot;30dp&quot;</span><br><span class="line">            android:backgroundTint=&quot;#012a4a&quot;</span><br><span class="line">            android:letterSpacing=&quot;-0.05&quot;</span><br><span class="line">            android:lineSpacingExtra=&quot;1.3sp&quot;</span><br><span class="line">            android:text=&quot;@string/default_dialog_cancel_caption&quot;</span><br><span class="line">            android:textColor=&quot;#ffffff&quot;</span><br><span class="line">            android:textSize=&quot;13.5sp&quot;</span><br><span class="line">            app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">            app:layout_constraintStart_toEndOf=&quot;@+id/submitButton&quot;</span><br><span class="line">            app:layout_constraintTop_toBottomOf=&quot;@+id/messageTextView&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이대로 실행할 경우 error가 발생한다. <code>strings.xml</code> 에 필요한 값이 누락되어 있기 때문이다. <code>res/values/strings.xml</code> 파일을 다음과 같이 수정해 보자.</p><figure class="highlight xml"><figcaption><span>strings.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;app_name&quot;</span>&gt;</span>MyCustomDialog<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Fullscreen custom dialog --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;default_dialog_title&quot;</span>&gt;</span>다이얼로그 타이틀<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;default_dialog_message&quot;</span>&gt;</span>다이얼로그 메시지<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;default_dialog_submit_caption&quot;</span>&gt;</span>확인<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;default_dialog_cancel_caption&quot;</span>&gt;</span>취소<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>모든 레이아웃 작업이 간단히 끝났다.</p><br><h2 id="customdialogmaker-생성하기"><a class="markdownIt-Anchor" href="#customdialogmaker-생성하기"></a> CustomDialogMaker 생성하기</h2><p>CustomDialogMaker는 object로, Fullscreen Dialog를 쉽게 생성할 수 있도록 만들어 주는 일종의 유틸이다. <code>getDialog</code> 를 통해 어느 곳에서나 Custom Dialog 내 text를 수정하여 출력하는 기능을 제공한다.</p><p>우선, <code>CustomDialogMaker.kt</code> 에서 확인 버튼과 취소 버튼 각각의 이벤트를 전달할 수 있도록 <code>interface</code> 를 생성하자.</p><figure class="highlight kotlin"><figcaption><span>CustomDialogListener.kt</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CustomDialogListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClickSubmitButton</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClickCancelButton</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>각 버튼의 클릭 이벤트가 들어왔을 때 각각 이벤트에 따라 위 작성된 <code>interface</code> 를 target으로 실질적 구현부(ex-Activity)에서 이벤트를 수신하도록 했다. 말로 풀어 쓰니 어려운데, 아래 코드(<code>CustomDialogMaker.kt</code>)를 확인하자.</p><figure class="highlight kotlin"><figcaption><span>CustomDialogMaker.kt</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> CustomDialogMaker &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getDialog</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        context: <span class="type">Context</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        title: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        message: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        submitCaption: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        cancelCaption: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        target: <span class="type">CustomDialogListener</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> dialog = Dialog(context, R.style.FullWindowDialog)</span><br><span class="line">        <span class="keyword">val</span> dialogBinding = DialogFullActivityBinding.inflate(dialog.layoutInflater)</span><br><span class="line">        dialog.setContentView(dialogBinding.root)</span><br><span class="line"></span><br><span class="line">        dialogBinding.titleTextView.text = title</span><br><span class="line">        dialogBinding.messageTextView.text = message</span><br><span class="line">        dialogBinding.submitButton.text = submitCaption</span><br><span class="line">        dialogBinding.cancelButton.text = cancelCaption</span><br><span class="line"></span><br><span class="line">        dialogBinding.submitButton.setOnClickListener &#123;</span><br><span class="line">            target.onClickSubmitButton()</span><br><span class="line">            dialog.dismiss()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dialogBinding.cancelButton.setOnClickListener &#123;</span><br><span class="line">            target.onClickCancelButton()</span><br><span class="line">            dialog.dismiss()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dialog.show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CustomDialogMaker.getDialog(인자)</code> 로 호출할 때, 이것을 호출한 곳에서 <code>onClickSubmitButton()</code>, <code>onClickCancelButton()</code> 이벤트를 처리하도록 한 코드이다. <code>findViewById</code> 대신 <code>viewBinding</code> 을 이용하여 코드를 경량화하였다.</p><br><h2 id="mainactivity-수정하기"><a class="markdownIt-Anchor" href="#mainactivity-수정하기"></a> MainActivity 수정하기</h2><p><code>MainActivity.kt</code> 파일에서는 ViewBinding 대신 <code>findViewById</code> 를 이용하여 <code>showDialogButton</code> 에 <code>onClickListener</code> 를 추가하였고, 버튼 클릭시 <code>Dialog</code> 가 출력되도록 코드를 작성하였다.</p><figure class="highlight kotlin"><figcaption><span>MainActivity.kt</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> showDialogButton = findViewById&lt;Button&gt;(R.id.showDialogButton)</span><br><span class="line"></span><br><span class="line">        showDialogButton.setOnClickListener &#123;</span><br><span class="line">            CustomDialogMaker.getDialog(</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                <span class="string">&quot;title&quot;</span>,</span><br><span class="line">                <span class="string">&quot;message&quot;</span>,</span><br><span class="line">                <span class="string">&quot;submit&quot;</span>,</span><br><span class="line">                <span class="string">&quot;cancel&quot;</span>,</span><br><span class="line">                <span class="keyword">object</span> : CustomDialogListener &#123;</span><br><span class="line">                    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClickSubmitButton</span><span class="params">()</span></span> &#123;</span><br><span class="line">                        Toast.makeText(applicationContext, <span class="string">&quot;SUBMIT!&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClickCancelButton</span><span class="params">()</span></span> &#123;</span><br><span class="line">                        Toast.makeText(applicationContext, <span class="string">&quot;CANCEL!&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예시와 같이 <code>CustomDialogMaker.getDialog(values..)</code> 를 통해 <code>CustomDialog</code> 를 손쉽게 가져다 사용할 수 있었다.</p><br><h1 id="마무리하며"><a class="markdownIt-Anchor" href="#마무리하며"></a> 마무리하며</h1><p>위 형태가 베스트 케이스인지에 대해선 확신이 없으나, Custom Dialog의 전반적인 Layout은 유지하고 싶으나 Button의 text나 title, message의 변경이 필요할 때 사용하기 위해 작성하였다. dialog builder를 이용하여 생성하는 방법이 가장 쉬우나, 그 경우에는 fullscreen을 어떻게 세팅해 주어야 할지 감이 오지 않았다. 혹, 이 글을 읽는 분들 중 <mark><strong>dialog builder를 이용해 fullscreen을 설정하는 방법을 아는 분이 계신다면 댓글로 아이디어 공유 부탁드립니다.</strong></mark></p><p>전체 코드는 <a href="https://github.com/d2fault/android-fullscreen-dialog-sample">github repository</a> 에 업로드하였다. java/kotlin 두 가지 버전으로 작성하였으며, branch를 이동하여 확인할 수 있다.</p><br>]]></content:encoded>
      
      
      <category domain="https://d2fault.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://d2fault.github.io/categories/Programming/Android/">Android</category>
      
      
      <category domain="https://d2fault.github.io/tags/kotlin/">kotlin</category>
      
      <category domain="https://d2fault.github.io/tags/android/">android</category>
      
      <category domain="https://d2fault.github.io/tags/java/">java</category>
      
      <category domain="https://d2fault.github.io/tags/customdialog/">customdialog</category>
      
      <category domain="https://d2fault.github.io/tags/fullscreen/">fullscreen</category>
      
      
      <comments>https://d2fault.github.io/2021/08/29/20210829-fullscreen-custom-dialog/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] AudioFocus 알아보기(2) - 커스텀과 확장</title>
      <link>https://d2fault.github.io/2021/07/26/20210726-android-audio-focus-2/</link>
      <guid>https://d2fault.github.io/2021/07/26/20210726-android-audio-focus-2/</guid>
      <pubDate>Mon, 26 Jul 2021 12:56:55 GMT</pubDate>
      
      <description>지난 포스트 에서 작성한 코드인 AudioFocusHelper.java 에 약간의 기능을 덧붙이고, Build.VERSION_CODES.O 미만인 단말에서도 동작할 수 있도록 수정해 볼 것이다. 말은 거창하지만 그리 많이 수정할 예정은 아니다.</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="개요"><a class="markdownIt-Anchor" href="#개요"></a> 개요</h1><p><a href="https://d2fault.github.io/2021/07/19/20210710-android-audio-focus-1/">지난 포스트</a> 에서 작성한 코드인 <code>AudioFocusHelper.java</code> 에 약간의 기능을 덧붙이고, <code>Build.VERSION_CODES.O</code> 미만인 단말에서도 동작할 수 있도록 수정해 볼 것이다. 말은 거창하지만 그리 많이 수정할 것은 아니다.</p><br><h1 id="무엇을-수정할-것인가"><a class="markdownIt-Anchor" href="#무엇을-수정할-것인가"></a> 무엇을 수정할 것인가</h1><p>우선, <code>AudioFocus</code> 가 <code>Build.VERSION_CODES.O</code> 미만인 단말에서도 잘 동작해야 하기 때문에 이 부분의 코드를 고쳐보려 한다. 그전에, 지난 포스팅에서 작성한 코드에 TODO를 먼저 붙여 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioFocusHelper</span> <span class="keyword">implements</span> <span class="title">AudioManager</span>.<span class="title">OnAudioFocusChangeListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = AudioFocusHelper.class.getSimpleName();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AudioManager audioManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AudioFocusRequest audioFocusRequest;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AudioFocusHelper</span><span class="params">(<span class="meta">@Nonnull</span> Context context)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Create AudioFocusHelper&quot;</span>);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 1. Build.VERSION_CODES.O 미만인 단말에서의 생성자 세팅 추가</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);</span><br><span class="line">            AudioAttributes mAudioAttributes = <span class="keyword">new</span> AudioAttributes.Builder()</span><br><span class="line">                    .setUsage(AudioAttributes.USAGE_MEDIA)</span><br><span class="line">                    .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)</span><br><span class="line">                    .build();</span><br><span class="line">            audioFocusRequest = <span class="keyword">new</span> AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN)</span><br><span class="line">                    .setAudioAttributes(mAudioAttributes)</span><br><span class="line">                    .setAcceptsDelayedFocusGain(<span class="keyword">true</span>)</span><br><span class="line">                    .setOnAudioFocusChangeListener(<span class="keyword">this</span>)</span><br><span class="line">                    .setWillPauseWhenDucked(<span class="keyword">true</span>)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestAudioFocus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; called requestAudioFocus() / Build.VERSION: &quot;</span> + Build.VERSION.SDK_INT);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 2. Build.VERSION_CODES.O 미만 단말에서의 AudioFocus Request 기능 추가</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; requestAudioFocus&quot;</span>);</span><br><span class="line">            audioManager.requestAudioFocus(audioFocusRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 3. abandonAudioFocus() function 추가</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAudioFocusChange</span><span class="params">(<span class="keyword">int</span> focusChange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (focusChange) &#123;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_GAIN:</span><br><span class="line">                <span class="comment">// 이제부터 AudioFocus는 우리 앱의 소유!</span></span><br><span class="line">                Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; AUDIOFOCUS_GAIN&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_GAIN_TRANSIENT:</span><br><span class="line">                <span class="comment">// 일시적으로 AudioFocus를 가져온다.</span></span><br><span class="line">                Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; AUDIOFOCUS_GAIN_TRANSIENT&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK:</span><br><span class="line">                <span class="comment">// 15초 이상 점유하면 안 된다. 앱의 소리가 나지만, Background App의 사운드가 작게 들릴 수 있다.</span></span><br><span class="line">                Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS:</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; AUDIOFOCUS_LOSS&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:</span><br><span class="line">                <span class="comment">// 일시적인 LOSS로, 잠깐 사용한 App이 점유를 끝내면 가장 마지막에 GAIN한 App이 AudioFocus를 점유한다.</span></span><br><span class="line">                Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; AUDIOFOCUS_LOSS_TRANSIENT&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:</span><br><span class="line">                <span class="comment">// 볼륨을 낮추는 것을 권장한다.</span></span><br><span class="line">                Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_REQUEST_FAILED:</span><br><span class="line">                <span class="comment">// 요청 실패할 경우의 로직을 추가한다.</span></span><br><span class="line">                Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; AUDIOFOCUS_REQUEST_FAILED&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1번부터 3번까지의 TODO를 추가해 보았다. 1번부터 천천히 수정해 보자.</p><br><h2 id="1-buildversion_codeso-미만인-단말에서의-생성자-세팅-추가"><a class="markdownIt-Anchor" href="#1-buildversion_codeso-미만인-단말에서의-생성자-세팅-추가"></a> 1. <code>Build.VERSION_CODES.O</code> 미만인 단말에서의 생성자 세팅 추가</h2><p>이 코드는 아주 간단하다. <code>Build.VERSION_CODES.O</code> 미만인 단말에서는 <code>AudioManager</code> 생성만 해 주면 된다. 그래서 별도의 <code>else</code> 처리 없이, <code>if</code> 문 안에 있던 <code>AudioManager</code> 를 밖으로 빼 준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AudioFocusHelper</span><span class="params">(<span class="meta">@Nonnull</span> Context context)</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;Create AudioFocusHelper&quot;</span>);</span><br><span class="line">    <span class="comment">// 이렇게 위로 빼 주면 됨</span></span><br><span class="line">    audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">        <span class="comment">// audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);</span></span><br><span class="line">        AudioAttributes mAudioAttributes = <span class="keyword">new</span> AudioAttributes.Builder()</span><br><span class="line">            .setUsage(AudioAttributes.USAGE_MEDIA)</span><br><span class="line">            .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)</span><br><span class="line">            .build();</span><br><span class="line">        audioFocusRequest = <span class="keyword">new</span> AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN)</span><br><span class="line">            .setAudioAttributes(mAudioAttributes)</span><br><span class="line">            .setAcceptsDelayedFocusGain(<span class="keyword">true</span>)</span><br><span class="line">            .setOnAudioFocusChangeListener(<span class="keyword">this</span>)</span><br><span class="line">            .setWillPauseWhenDucked(<span class="keyword">true</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="2-buildversion_codeso-미만-단말에서의-audiofocus-request-기능-추가"><a class="markdownIt-Anchor" href="#2-buildversion_codeso-미만-단말에서의-audiofocus-request-기능-추가"></a> 2. <code>Build.VERSION_CODES.O</code> 미만 단말에서의 AudioFocus Request 기능 추가</h2><p><code>Oreo</code>, API level 26보다 낮은 단말에서 <code>AudioFocus</code> 를 얻고 싶다면 다음의 코드를 사용하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestAudioFocus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; called requestAudioFocus() / Build.VERSION: &quot;</span> + Build.VERSION.SDK_INT);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 2. Build.VERSION_CODES.O 미만 단말에서의 AudioFocus Request 기능 추가</span></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">        audioManager.requestAudioFocus(audioFocusRequest);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        audioManager.requestAudioFocus(<span class="keyword">this</span>, AudioManager.USE_DEFAULT_STREAM_TYPE, AudioManager.AUDIOFOCUS_GAIN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>requestAudioFocus(OnAudioFocusChangeListener l, int streamType, int durationHint)</code> 형태를 따라 적절한 값을 넣어 주면 된다.</p><br><h2 id="3-abandonaudiofocus-function-추가"><a class="markdownIt-Anchor" href="#3-abandonaudiofocus-function-추가"></a> 3. <code>abandonAudioFocus()</code> function 추가</h2><p>앞서 우리는 <code>AudioFocus</code> 를 요청만 했지 반납하지 않았다. 서비스가 종료되거나, 더이상의 Audio가 필요하지 않을 땐 <code>AudioFocus</code> 를 반납하는 것이 인지상정! 이 코드도 굉장히 짧다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abandonAudioFocus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; called abandonAudioFocus()&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">        audioManager.abandonAudioFocusRequest(audioFocusRequest);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        audioManager.abandonAudioFocus(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>너무 쉽죠?</p><br><h1 id="전체-코드-보기"><a class="markdownIt-Anchor" href="#전체-코드-보기"></a> 전체 코드 보기</h1><p>Oreo 미만 단말에서 <code>AudioFocus</code> 를 요청할 수 있고, 반납 기능이 추가된 <code>AudioFocusHelper.java</code> 코드 전체는 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioFocusHelper</span> <span class="keyword">implements</span> <span class="title">AudioManager</span>.<span class="title">OnAudioFocusChangeListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = AudioFocusHelper.class.getSimpleName();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AudioManager audioManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AudioFocusRequest audioFocusRequest;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AudioFocusHelper</span><span class="params">(<span class="meta">@Nonnull</span> Context context)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Create AudioFocusHelper&quot;</span>);</span><br><span class="line">        audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            AudioAttributes mAudioAttributes = <span class="keyword">new</span> AudioAttributes.Builder()</span><br><span class="line">                .setUsage(AudioAttributes.USAGE_MEDIA)</span><br><span class="line">                .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)</span><br><span class="line">                .build();</span><br><span class="line">            audioFocusRequest = <span class="keyword">new</span> AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN)</span><br><span class="line">                .setAudioAttributes(mAudioAttributes)</span><br><span class="line">                .setAcceptsDelayedFocusGain(<span class="keyword">true</span>)</span><br><span class="line">                .setOnAudioFocusChangeListener(<span class="keyword">this</span>)</span><br><span class="line">                .setWillPauseWhenDucked(<span class="keyword">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestAudioFocus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; called requestAudioFocus() / Build.VERSION: &quot;</span> + Build.VERSION.SDK_INT);</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            audioManager.requestAudioFocus(audioFocusRequest);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            audioManager.requestAudioFocus(<span class="keyword">this</span>, AudioManager.USE_DEFAULT_STREAM_TYPE, AudioManager.AUDIOFOCUS_GAIN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abandonAudioFocus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; called abandonAudioFocus()&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            audioManager.abandonAudioFocusRequest(audioFocusRequest);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            audioManager.abandonAudioFocus(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAudioFocusChange</span><span class="params">(<span class="keyword">int</span> focusChange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (focusChange) &#123;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_GAIN:</span><br><span class="line">                <span class="comment">// 이제부터 AudioFocus는 우리 앱의 소유!</span></span><br><span class="line">                Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; AUDIOFOCUS_GAIN&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_GAIN_TRANSIENT:</span><br><span class="line">                <span class="comment">// 일시적으로 AudioFocus를 가져온다.</span></span><br><span class="line">                Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; AUDIOFOCUS_GAIN_TRANSIENT&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK:</span><br><span class="line">                <span class="comment">// 15초 이상 점유하면 안 된다. 앱의 소리가 나지만, Background App의 사운드가 작게 들릴 수 있다.</span></span><br><span class="line">                Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS:</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; AUDIOFOCUS_LOSS&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:</span><br><span class="line">                <span class="comment">// 일시적인 LOSS로, 잠깐 사용한 App이 점유를 끝내면 가장 마지막에 GAIN한 App이 AudioFocus를 점유한다.</span></span><br><span class="line">                Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; AUDIOFOCUS_LOSS_TRANSIENT&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:</span><br><span class="line">                <span class="comment">// 볼륨을 낮추는 것을 권장한다.</span></span><br><span class="line">                Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_REQUEST_FAILED:</span><br><span class="line">                <span class="comment">// 요청 실패할 경우의 로직을 추가한다.</span></span><br><span class="line">                Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; AUDIOFOCUS_REQUEST_FAILED&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드에서 나는 <code>OnAudioFocusChangeListener</code> 를 <code>implement</code> 하여 구현하였지만, <code>class</code> 내에서 직접 <code>new</code> 로 선언해 주어도 문제가 되지 않는다. 이전 코드는 그런 형식으로 되어 있었는데, <code>implement</code> 하는 방식이 더 깔끔하게 구현될 것 같아서 약간의 리팩토링 과정을 거쳐 수정하였다. 아무튼, 이대로 싱겁게 이번 포스팅 끝!</p><br>]]></content:encoded>
      
      
      <category domain="https://d2fault.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://d2fault.github.io/categories/Programming/Android/">Android</category>
      
      
      <category domain="https://d2fault.github.io/tags/android/">android</category>
      
      <category domain="https://d2fault.github.io/tags/audiofocus/">audiofocus</category>
      
      <category domain="https://d2fault.github.io/tags/webview/">webview</category>
      
      <category domain="https://d2fault.github.io/tags/java/">java</category>
      
      
      <comments>https://d2fault.github.io/2021/07/26/20210726-android-audio-focus-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] AudioFocus 알아보기(1) - 왜, 어떻게 사용하는가</title>
      <link>https://d2fault.github.io/2021/07/19/20210710-android-audio-focus-1/</link>
      <guid>https://d2fault.github.io/2021/07/19/20210710-android-audio-focus-1/</guid>
      <pubDate>Mon, 19 Jul 2021 14:29:55 GMT</pubDate>
      
      <description>AudioFocus가 적용되어 있지 않은 애플리케이션에 AudioFocus를 적용해야만 하는 일이 생겼다. 지금까지는 쓸 일도, 그럴 필요도 없었기에 이 친구의 존재를 모르고 있었는데 적용할 일이 생겼으니 공부해 보자 싶었다.</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="개요"><a class="markdownIt-Anchor" href="#개요"></a> 개요</h1><p>AudioFocus가 적용되어 있지 않은 애플리케이션에 AudioFocus를 적용해야만 하는 일이 생겼다. 지금까지는 쓸 일도, 그럴 필요도 없었기에 이 친구의 존재를 모르고 있었는데 적용할 일이 생겼으니 공부해 보자 싶었다. 이번 포스팅에서는 AudioFocus를 왜 써야 하는지, 그리고 어떻게 사용해야 하는지에 대해 적어보려고 한다.</p><br><h1 id="audiofocus가-뭐야"><a class="markdownIt-Anchor" href="#audiofocus가-뭐야"></a> AudioFocus가 뭐야?</h1><p>Android OS에게 “나 지금 미디어 필요해! 쓴다!” 하고 통보하는 기능으로, 일종의 약속이다. AudioFocus를 요청할 때에는 <strong>어떤 용도로 오디오를 사용하는지</strong>에 대한 정보를 함께 전달해야 한다. 용도에 대한 정보는 <code>AudioAttributes</code> 인스턴스 생성 후 <code>setUseage()</code> 와 <code>setContentType()</code> 를 통해 세팅할 수 있으며, 다음의 값 중 하나를 가진다. <s>(번역은 셀프입니다. ㅎㅎ;😉</s></p><h2 id="setuseage-list"><a class="markdownIt-Anchor" href="#setuseage-list"></a> setUseage List</h2><table><thead><tr><th>값</th><th>설명</th></tr></thead><tbody><tr><td>USAGE_UNKNOWN</td><td>Usage value to use when the usage is unknown.</td></tr><tr><td>USAGE_MEDIA</td><td>Usage value to use when the usage is media, such as music, or movie soundtracks.</td></tr><tr><td>USAGE_VOICE_COMMUNICATION</td><td>Usage value to use when the usage is voice communications, such as telephony or VoIP.</td></tr><tr><td>USAGE_VOICE_COMMUNICATION_SIGNALLING</td><td>Usage value to use when the usage is in-call signalling, such as wite a “busy” beep, or DTMF tones.</td></tr><tr><td>USAGE_ALARM</td><td>Usage value to use when the usage is an alarm (e.g. wake-up alarm).</td></tr><tr><td>USAGE_NOTIFICATION</td><td>Usage value to use when the usage is notification. See other notification usages for more specialized uses.</td></tr><tr><td>USAGE_NOTIFICATION_RINGTONE</td><td>Usage value to use when the usage is telephony ringtone.</td></tr><tr><td>USAGE_NOTIFICATION_COMMUNICATION_REQUEST</td><td>Usage value to use when the usage is a request to enter/end a communication, such as a VoIP communication or video-conference.</td></tr><tr><td>USAGE_NOTIFICATION_COMMUNICATION_INSTANT</td><td>Usage value to use when the usage is notification for an “instant” communication such as a chat, or SMS.</td></tr><tr><td>USAGE_NOTIFICATION_COMMUNICATION_DELAYED</td><td>Usage value to use when the usage is notification for a non-immediate type of communication such as e-mail.</td></tr><tr><td>USAGE_NOTIFICATION_EVENT</td><td>Usage value to use when the usage is to attract the user’s attention, such as a reminder or low battery warning.</td></tr><tr><td>USAGE_ASSISTANCE_ACCESSIBILITY</td><td>Usage value to use when the usage is for accessibility, such as with* a screen reader.</td></tr><tr><td>USAGE_ASSISTANCE_NAVIGATION_GUIDANCE</td><td>Usage value to use when the usage is driving or navigation directions.</td></tr><tr><td>USAGE_ASSISTANCE_SONIFICATION</td><td>Usage value to use when the usage is sonification, such as  with user interface sounds.</td></tr><tr><td>USAGE_GAME</td><td>Usage value to use when the usage is for game audio.</td></tr><tr><td>USAGE_ASSISTANT</td><td>Usage value to use for audio responses to user queries, audio instructions or help utterances.</td></tr></tbody></table><br><h2 id="setcontenttype-list"><a class="markdownIt-Anchor" href="#setcontenttype-list"></a> setContentType List</h2><table><thead><tr><th>값</th><th>설명</th></tr></thead><tbody><tr><td>CONTENT_TYPE_UNKNOWN</td><td>Content type value to use when the content type is unknown, or other than the ones defined.</td></tr><tr><td>CONTENT_TYPE_SPEECH</td><td>Content type value to use when the content type is speech.</td></tr><tr><td>CONTENT_TYPE_MUSIC</td><td>Content type value to use when the content type is music.</td></tr><tr><td>CONTENT_TYPE_MOVIE</td><td>Content type value to use when the content type is a soundtrack, typically accompanying a movie or TV program.</td></tr><tr><td>CONTENT_TYPE_SONIFICATION</td><td>Content type value to use when the content type is a sound used to accompany a user action, such as a beep or sound effect expressing a key click, or event, such as the type of a sound for a bonus being received in a game. These sounds are mostly synthesized or short Foley sounds.</td></tr></tbody></table><br><h1 id="audiofocus를-뺏길-땐-어떻게-해"><a class="markdownIt-Anchor" href="#audiofocus를-뺏길-땐-어떻게-해"></a> AudioFocus를 뺏길 땐 어떻게 해?</h1><p>Android는 다 계획이 있다, 이 말이야! 이 경우를 대비해서 Listener(<code>AudioManager.OnAudioFocusChangeListener</code>) 를 제공한다. 개발자는  이 Listener에서 처리할 수 있는 이벤트는 다음과 같다.</p><h2 id="audiofocus-change-listener-event-list"><a class="markdownIt-Anchor" href="#audiofocus-change-listener-event-list"></a> AudioFocus Change Listener Event List</h2><table><thead><tr><th>Event</th><th>설명</th></tr></thead><tbody><tr><td>AUDIOFOCUS_NONE</td><td>Used to indicate no audio focus has been gained or lost, or requested.</td></tr><tr><td>AUDIOFOCUS_GAIN</td><td>Used to indicate a gain of audio focus, or a request of audio focus, of unknown duration.</td></tr><tr><td>AUDIOFOCUS_GAIN_TRANSIENT</td><td>Used to indicate a temporary gain or request of audio focus, anticipated to last a short amount of time. Examples of temporary changes are the playback of driving directions, or an event notification.</td></tr><tr><td>AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK</td><td>Used to indicate a temporary request of audio focus, anticipated to last a short amount of time, and where it is acceptable for other audio applications to keep playing after having lowered their output level (also referred to as “ducking”).<br />Examples of temporary changes are the playback of driving directions where playback of music in the background is acceptable.</td></tr><tr><td>AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE</td><td>Used to indicate a temporary request of audio focus, anticipated to last a short amount of time, during which no other applications, or system components, should play anything.<br />Examples of exclusive and transient audio focus requests are voice memo recording and speech recognition, during which the system shouldn’t play any notifications, and media playback should have paused.</td></tr><tr><td>AUDIOFOCUS_LOSS</td><td>Used to indicate a loss of audio focus of unknown duration.</td></tr><tr><td>AUDIOFOCUS_LOSS_TRANSIENT</td><td>Used to indicate a transient loss of audio focus.</td></tr><tr><td>AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK</td><td>Used to indicate a transient loss of audio focus where the loser of the audio focus can lower its output volume if it wants to continue playing (also referred to as “ducking”), as the new focus owner doesn’t require others to be silent.</td></tr></tbody></table><br><h1 id="어떻게-사용해"><a class="markdownIt-Anchor" href="#어떻게-사용해"></a> 어떻게 사용해?</h1><p>음, <code>Helper</code> 라는 단어 사용을 지양해야 한다고 하는데 마땅한 단어가 떠오르지 않는다. 그래서 어쩔 수 없이 <code>AudioFocusHelper.java</code> class를 만들게 되었다. ^^; 필요한 곳에서 <code>AudioFocus</code> 를 <code>context</code> 와 함께 생성한다. 이후, <code>AudioFocus</code> 가 필요할 때 <code>requestAudioFocus()</code> 함수를 호출하면 깔끔하게 완성!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioFocusHelper</span> <span class="keyword">implements</span> <span class="title">AudioManager</span>.<span class="title">OnAudioFocusChangeListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = AudioFocusHelper.class.getSimpleName();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AudioManager audioManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AudioFocusRequest audioFocusRequest;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AudioFocusHelper</span><span class="params">(<span class="meta">@Nonnull</span> Context context)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Create AudioFocusHelper&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);</span><br><span class="line">            AudioAttributes mAudioAttributes = <span class="keyword">new</span> AudioAttributes.Builder()</span><br><span class="line">                    .setUsage(AudioAttributes.USAGE_MEDIA)</span><br><span class="line">                    .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)</span><br><span class="line">                    .build();</span><br><span class="line">            audioFocusRequest = <span class="keyword">new</span> AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN)</span><br><span class="line">                    .setAudioAttributes(mAudioAttributes)</span><br><span class="line">                    .setAcceptsDelayedFocusGain(<span class="keyword">true</span>)</span><br><span class="line">                    .setOnAudioFocusChangeListener(<span class="keyword">this</span>)</span><br><span class="line">                    .setWillPauseWhenDucked(<span class="keyword">true</span>)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestAudioFocus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; called requestAudioFocus() / Build.VERSION: &quot;</span> + Build.VERSION.SDK_INT);</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; requestAudioFocus&quot;</span>);</span><br><span class="line">            audioManager.requestAudioFocus(audioFocusRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAudioFocusChange</span><span class="params">(<span class="keyword">int</span> focusChange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (focusChange) &#123;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_GAIN:</span><br><span class="line">                <span class="comment">// 이제부터 AudioFocus는 우리 앱의 소유!</span></span><br><span class="line">                Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; AUDIOFOCUS_GAIN&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_GAIN_TRANSIENT:</span><br><span class="line">                <span class="comment">// 일시적으로 AudioFocus를 가져온다.</span></span><br><span class="line">                Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; AUDIOFOCUS_GAIN_TRANSIENT&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK:</span><br><span class="line">                <span class="comment">// 15초 이상 점유하면 안 된다. 앱의 소리가 나지만, Background App의 사운드가 작게 들릴 수 있다.</span></span><br><span class="line">                Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS:</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; AUDIOFOCUS_LOSS&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:</span><br><span class="line">                <span class="comment">// 일시적인 LOSS로, 잠깐 사용한 App이 점유를 끝내면 가장 마지막에 GAIN한 App이 AudioFocus를 점유한다.</span></span><br><span class="line">                Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; AUDIOFOCUS_LOSS_TRANSIENT&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:</span><br><span class="line">                <span class="comment">// 볼륨을 낮추는 것을 권장한다.</span></span><br><span class="line">                Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_REQUEST_FAILED:</span><br><span class="line">                <span class="comment">// 요청 실패할 경우의 로직을 추가한다.</span></span><br><span class="line">                Log.d(TAG, <span class="string">&quot;AudioFocus &gt;&gt; AUDIOFOCUS_REQUEST_FAILED&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h1 id="마무리하며"><a class="markdownIt-Anchor" href="#마무리하며"></a> 마무리하며</h1><p>필수 요건이 아닌 약속이라고 표현한 이유가 있다. 사실상 <code>AudioFocus</code> 를 요청하지 않아도 사운드 출력에는 문제가 없다. Android 플랫폼 생태계를 무시하고, ‘난 무조건 재생해야 해!’ 라는 억지를 부리고 싶다면 <code>AudioFocus</code> 없이 미디어를 출력해 버리면 된다. 혹은 <code>AUDIOFOCUS_LOSS</code> 이벤트를 받자마자 다시 GAIN하는 방법도 있지만, 당연히 <mark><strong>권장하지 않는다.</strong></mark></p><p>플랫폼 위에 올라가는 서비스 개발자는 플랫폼의 약속을 이행하는 것이 좋다. 이 자그마한 규약들은 각각의 앱들이 최대한 ‘정상 범주’ 내에서 동작할 수 있도록 만들어졌다. <code>AudioFocus</code> 를 무시하고 재생하는 앱이 하나일 경우에도 문제이지만, 여러 앱이 이것을 무시하고 재생한다면 UX가 와장창 깨지고 말 것이다. 알람도 울리고, 음악도 재생되고, 또 다른 앱에서 게임 소리도 나고, 또 다른 앱에서 영상이 재생되는 등의 복합 상황이 발생할 수 있다. 플랫폼의 약속은, 이런 복합 상황을 어느 정도 Android OS에게 '위임’한다는 의미를 포함한다.</p><br>]]></content:encoded>
      
      
      <category domain="https://d2fault.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://d2fault.github.io/categories/Programming/Android/">Android</category>
      
      
      <category domain="https://d2fault.github.io/tags/android/">android</category>
      
      <category domain="https://d2fault.github.io/tags/audiofocus/">audiofocus</category>
      
      <category domain="https://d2fault.github.io/tags/webview/">webview</category>
      
      <category domain="https://d2fault.github.io/tags/java/">java</category>
      
      
      <comments>https://d2fault.github.io/2021/07/19/20210710-android-audio-focus-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[JAVA] BitMask에 관한 자그마한 고찰, 그리고 EnumSet</title>
      <link>https://d2fault.github.io/2021/07/06/20210706-java-bitmask-and-enumset/</link>
      <guid>https://d2fault.github.io/2021/07/06/20210706-java-bitmask-and-enumset/</guid>
      <pubDate>Mon, 05 Jul 2021 16:30:18 GMT</pubDate>
      
      <description>BitMask 를 사용하는 이유와, 적용하게 된 계기를 적어 보고자 한다. 그러나 결국 EnumSet을 사용하기로 결정하였기 때문에, BitMask 대신 EnumSet 사용을 권장한다. 이 글은 &#39;왜&#39; 사용해야 하는가와 &#39;어떤 장점&#39;이 있는지에 초점을 맞추어 작성하였다.</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="개요"><a class="markdownIt-Anchor" href="#개요"></a> 개요</h1><p><code>BitMask</code> 를 사용하는 이유와, 적용하게 된 계기를 적어 보고자 한다. 그러나 결국 <mark><strong><code>EnumSet</code> 을 사용하기로 결정하였기 때문에, <code>BitMask</code> 대신 <code>EnumSet</code> 사용을 권장한다.</strong></mark></p><p>단, 이 포스팅에서 <code>BitMask</code> 와 <code>EnumSet</code> 을 디테일하게 다루지는 않을 것이다. <u><strong>이 글은 ‘왜’ 사용해야 하는가와 '어떤 장점’이 있는지에 초점을 맞추어 작성하였다.</strong></u></p><br><h1 id="bitmask요-갑자기요"><a class="markdownIt-Anchor" href="#bitmask요-갑자기요"></a> BitMask요? 갑자기요?</h1><p>스무 살, C언어 강의를 듣던 언젠가, 어렴풋이 들었던 것도 같다. (<s>심지어 그 당시 교수님도 그리 중요하게 다루지 않으셨고, 나는 A+이지렁!</s>) 지금도 잘 모르지만 그땐 더욱 몰랐으니 논외로 치고, 처음 <code>BitMask</code> 를 이해해야만 했던 것은 약 1년 전이다. 우리 앱<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>이 특정 앱에게 <code>intent</code>로 정보를 요청하고, 수신해야 했는데 이때 수신한 값이 <code>BitMask</code> 형태라는 것이다. 헤헤. 청천벽력 같았다. ‘어차피 <code>intent</code>에 <code>data</code> 담아서 줄 거면 그 값 그대로 주면 되지 굳이?’ 라는 생각이 들었지만, 그렇게 준다는 걸 어떡해. 앞으로 쓸 일도 없을 것 같고, 대충 이런 게 있구나 정도로만 이해하고 넘어갔다.</p><br><h1 id="코드-구경-이해-깨달음-적용"><a class="markdownIt-Anchor" href="#코드-구경-이해-깨달음-적용"></a> 코드 구경, 이해, 깨달음, 적용</h1><p>다른 업무로 옆 파트 과장님과 의견 교환 중에 우연히 과장님의 코드를 볼 기회가 생겼다. 업무 관련해서 조언을 구했는데, 과장님께서 본인 코드<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> 를 적절히 고치면 웬만해서 해결될 거라고 하셨다. 그렇다. 예상했겠지만, 이 코드 안에 <code>BitMask</code> 를 사용한 비즈니스 로직이 포함되어 있었다.</p><p>후. 이렇게 다시 만날 줄 몰랐다. 그러나 더는 피할 곳이 없었다. 이전엔 이미 마스킹된 값을 풀어내는 것에 그쳤지만, 이번엔 이것을 제대로 적용해 볼 수 있는 기회였다. 과장님께서 코드까지 주셨는데 두려울 게 뭐가 있겠습니까.</p><br><h1 id="그래서-bitmask가-뭔데"><a class="markdownIt-Anchor" href="#그래서-bitmask가-뭔데"></a> 그래서 BitMask가 뭔데?</h1><p>말 그대로 <code>bit</code> 에 관련된 것이다. <code>bit</code> 는 이진 숫자를 뜻하는 말로, 컴퓨터에서 사용되는 데이터의 최소 단위이다. 맞다, 0과 1! 그런데 왜 <code>bit</code> 에 <code>mask</code> 가 붙는 걸까? <code>BitMask</code> 는 0과 1로만 이루어진 <code>bit</code> 의 특성을 이용한 테크닉의 일종이다. 결론만 말하자면, <strong>이 테크닉은 ‘조건 지옥’ 에서  조금이나마 벗어날 수 있도록 해 준다.</strong> 아래 코드를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HobbyManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0000 0000 부터 1000 0000 까지 총 9가지의 기준을 가질 수 있다.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NONE = <span class="number">0x0</span>;         <span class="comment">// 0000 0000</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WALKING = <span class="number">0x1</span>;      <span class="comment">// 0000 0001</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READING = <span class="number">0x2</span>;      <span class="comment">// 0000 0010</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SINGING = <span class="number">0x4</span>;      <span class="comment">// 00000100</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING = <span class="number">0x8</span>;      <span class="comment">// 0000 1000</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROGRAMMING = <span class="number">0x10</span>; <span class="comment">// 0001 0000</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SWIMMING = <span class="number">0x20</span>;    <span class="comment">// 0010 0000</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DANCING = <span class="number">0x40</span>;     <span class="comment">// 0100 0000</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SLEEPING = <span class="number">0x80</span>;    <span class="comment">// 1000 0000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> hobbyFlags;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasHobby</span><span class="params">(<span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (flag &amp; hobbyFlags) == flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addHobby</span><span class="params">(<span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">        hobbyFlags |= flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setHobbyFlags</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        hobbyFlags = flags;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><s>작명이 영 별로이긴 하지만,</s> 위 코드는 누군가의 취미를 설정하고, 추가하고, 특정 취미 보유 여부를 판단할 수 있도록 한다. 사용 방법은 간단하다. 모든 함수가  <code>static</code> 함수로 선언되어 있기에 코드 어느 곳에서나, 필요할 때 위의 함수를 호출하기만 하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 초기 취미 Setting</span></span><br><span class="line">HobbyManager.setHobbyFlags(HobbyManager.WALKING |</span><br><span class="line">                          HobbyManager.SINGING |</span><br><span class="line">                          HobbyManager.DANCING);</span><br><span class="line"><span class="comment">// 신규 취미 추가</span></span><br><span class="line">HobbyManager.addHobby(HobbyManager.PROGRAMMING);</span><br><span class="line"><span class="comment">// 취미 보유 여부 확인</span></span><br><span class="line">HobbyManager.hasHobby(HobbyManager.SINGING);</span><br></pre></td></tr></table></figure><p>사실, <code>HobbyManager</code> 를 작성한 본질적인 이유는 <mark><strong>취미 보유 여부 확인</strong></mark> 이라고 해도 과언이 아니다. 만약, <code>BitMask</code> 를 사용하지 않는다면 어떤 코드를 작성할 수 있을까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; hobbies = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">hobbies.add(<span class="string">&quot;WALKING&quot;</span>);</span><br><span class="line">hobbies.add(<span class="string">&quot;SINGING&quot;</span>);</span><br><span class="line">hobbies.add(<span class="string">&quot;DANCING&quot;</span>);</span><br><span class="line">hobbies.add(<span class="string">&quot;PROGRAMMING&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasHobby</span><span class="params">(<span class="meta">@NonNull</span> String hobby)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; hobbies.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hobby.equals(hobbies.get(i))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>적당히 못난 코드로 작성해 보았다. <code>hasHobby</code> 에서 판단하고 싶은 <code>hobby</code> 를 전달받고, 유저의 취미 리스트를 0부터 하나씩 비교하여 존재할 경우 <code>true</code>, 아니면 <code>false</code> 를 반환하게 된다. 물론, 이렇게 개발해도 크리티컬한 문제는 없다. 이런 코드들이 쌓이고 쌓이면 문제가 될 수는 있겠지만 말이다. 그렇지만 코드가 예쁘고, 조금 더 효율적이면 기분이 조크든요. 기왕 하는 거 예쁘게 작성하면 모두가 행복합니다!</p><br><h1 id="다시-돌아와서"><a class="markdownIt-Anchor" href="#다시-돌아와서"></a> 다시 돌아와서</h1><p>막상 적용하니 문제가 생겼다. 위의 코드를 예시로 들면, 우리 앱에서 지원하고 싶은 취미가 9가지가 넘는단 사실이다. 이 경우에 <code>int</code> 형 대신 <code>long</code> 을 사용해서 더 많은 기준을 잡을 수 있다고는 하는데, 관련 예시가 없어 선뜻 적용하기가 어려웠다. 방법을 찾기 위해 열심히 구글링을 하다가, <code>BitMask</code> 대신 사용할 수 있는 엄청난 것을 발견했다. <s>(자바로 안드로이드 개발하지만 자바를 잘 모르는, 또 나만 몰랐겠지?)</s> 나와 같은 고민을 하는 사람이 없도록, Java는 위대했던 거시다.</p><br><h1 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h1><p><mark><strong><code>EnumSet</code> 쓰세요. 두 번 쓰세요.</strong></mark> 특징을 정리하면 다음과 같다.</p><ul><li><code>EnumSet</code> 에서 제공하는 모든 메서드는 산술 비트 연산을 사용하여 구현되므로 일반적인 <strong>연산 속도가 굉장히 빠르다.</strong></li><li><code>HashSet</code> 과 같은 다른 <code>Set</code> 구현체와 비교했을 때, 데이터가 예상 가능한 순서로 저장되어 있다.<ul><li>계산시 하나의 비트만이 필요하므로 더 빠르다.</li><li><code>HashSet</code> 처럼 데이터 저장 버킷을 찾을 때 hash code를 계산할 필요가 없다.</li></ul></li><li><code>EnumSet</code> 은 내부적으로 big vector로 표현된다.<ul><li>비트 벡터의 특성상 <strong>더 작은 메모리를 사용한다.</strong></li></ul></li></ul><p>bit flag, BitMask는 고전적인 방법(…)이라고 한다. 굳이 쓰지 말고, 내부적으로 bit flag를 사용하는 <code>EnumSet</code> 을 사용하자. 그럼, 위의 예시 코드를 바꿔 봐야지!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HobbyManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Hobbies</span> </span>&#123;</span><br><span class="line">      NONE, WALKING, READING,</span><br><span class="line">      SINGING, RUNNING, PROGRAMMING,</span><br><span class="line">      SWIMMING, DANCING, SLEEPING,</span><br><span class="line">      <span class="comment">// 신규 취미 2종 추가</span></span><br><span class="line">      DRAWING, BAKING</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EnumSet&lt;Hobbies&gt; hobbyFlags;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasHobby</span><span class="params">(Hobbies flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hobbyFlags.contains(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addHobby</span><span class="params">(Hobbies flag)</span> </span>&#123;</span><br><span class="line">        hobbyFlags.add(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setHobbyFlags</span><span class="params">(EnumSet&lt;Hobbies&gt; flags)</span> </span>&#123;</span><br><span class="line">        hobbyFlags = flags;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;hobbyFlags Flags: &quot;</span> + hobbyFlags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음과 같이 사용하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 초기 취미 Setting</span></span><br><span class="line">EnumSet&lt;HobbyManager.Hobbies&gt; hobbyEnumSet = EnumSet.of(HobbyManager.Hobbies.WALKING,</span><br><span class="line">                HobbyManager.Hobbies.SINGING,</span><br><span class="line">                HobbyManager.Hobbies.DANCING);</span><br><span class="line">HobbyManager.setHobbyFlags(hobbyEnumSet);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 신규 취미 추가</span></span><br><span class="line">HobbyManager.addHobby(HobbyManager.Hobbies.PROGRAMMING);</span><br><span class="line"><span class="comment">// 취미 보유 여부 확인</span></span><br><span class="line">HobbyManager.hasHobby(HobbyManager.Hobbies.SINGING);</span><br></pre></td></tr></table></figure><p>이번 개발 건에서는 '보유 여부 확인’만 하면 되어서 이정도 코드로 충분했으나, 만일 ‘제거’ 가 필요하다면 <code>EnumSet</code> 에서 지원하는 <code>remove</code> 를  <code>HobbyManager</code> 에 적용하여 확장하면 된다. Easy!</p><br><h1 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h1><ul><li><a href="https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;blogId=zero_kjy&amp;logNo=220794334785">10진수를 2진수 코드화</a></li><li><a href="https://mygumi.tistory.com/361">비트마스크(BitMask)는 무엇인가?</a></li><li><a href="https://sime.tistory.com/65">Java 데이터 형식 범위</a></li><li><a href="https://johngrib.github.io/wiki/java-enum/">Java enum의 사용</a></li><li><a href="https://scshim.tistory.com/253">Enum, 자바의 열거타입을 알아보자</a></li><li><a href="https://www.geeksforgeeks.org/enumset-class-java/">EnumSet in Java</a></li></ul><br><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>모 기업에서 Android Application 개발을 하고 있음. 다만, 일반적인 Android App과는 약간 다른 형태로, 특성 상 타 앱들과 intent를 주고받는 일이 잦다. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>같은 팀이기에 서로의 코드는 언제든지 열람 가능하다. <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://d2fault.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://d2fault.github.io/categories/Programming/Java/">Java</category>
      
      
      <category domain="https://d2fault.github.io/tags/android/">android</category>
      
      <category domain="https://d2fault.github.io/tags/bitmask/">bitmask</category>
      
      <category domain="https://d2fault.github.io/tags/enumset/">enumset</category>
      
      
      <comments>https://d2fault.github.io/2021/07/06/20210706-java-bitmask-and-enumset/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Book] 열정의 배신(하고 싶은 일만 하면 정말 행복해질까)</title>
      <link>https://d2fault.github.io/2021/05/09/20210509-book-review-so-good-they-cant-ignore-you/</link>
      <guid>https://d2fault.github.io/2021/05/09/20210509-book-review-so-good-they-cant-ignore-you/</guid>
      <pubDate>Sun, 09 May 2021 09:04:16 GMT</pubDate>
      
      <description>‘업의 본질’에 대한 탐구 끝에 얻은 일의 절대 원칙 열정을 따르는 대신, 열정이 당신을 따르게 하라! 자신이 꿈꾸는 일, 좋아하는 일은 천직처럼 따로 있으며, 그 일을 찾으면 저절로 행복해지고 성공한다는 이른바 ‘열정론’이 우리 사회에 만연해 있다.</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="책-소개"><a class="markdownIt-Anchor" href="#책-소개"></a> 책 소개</h1><p><a href="http://book.naver.com/bookdb/book_detail.nhn?bid=14593294"><img src="/images/20210509-book_review_so_good_they_cant_ignore_you/1.jpg" alt="" /></a></p><p>이미지를 클릭하시면 네이버 책으로 이동합니다.</p><br><h1 id="책-정보"><a class="markdownIt-Anchor" href="#책-정보"></a> 책 정보</h1><blockquote><p><strong>‘업의 본질’에 대한 탐구 끝에 얻은 일의 절대 원칙<br />열정을 따르는 대신, 열정이 당신을 따르게 하라!</strong></p><p>자신이 꿈꾸는 일, 좋아하는 일은 천직처럼 따로 있으며, 그 일을 찾으면 저절로 행복해지고 성공한다는 이른바 ‘열정론’이 우리 사회에 만연해 있다. 칼 뉴포트는 “열정을 따르라”는 조언이 틀렸을뿐더러 위험하기까지 하다고 단언한다. 이 오랜 믿음은 사실 결함투성이다. 대부분의 사람들은 애초에 열정을 품고 있지 않으며, 또 열정은 일을 사랑하게 되는 법과도 무관하다. 오히려 이를 맹신하다가는 현실의 벽에 부닥쳐 실패하기 십상이다.</p><p>“열정을 따르지 마라”는 대원칙을 입증한 후 뉴포트는, 그렇다면 ‘사람들은 어떻게 자신의 일을 사랑하게 되는가’에 대한 탐구를 시작한다. 벤처 투자자, 프리랜서 소프트웨어 개발자, 방송작가, 코미디언, 기업가, 컴퓨터 프로그래머, 뮤지션, 과학자, 고고학자 등 다양한 직업에서 큰 만족감을 이끌어 내고 있는 사람들을 인터뷰하면서, 그는 또 다른 중요한 3가지 원칙을 발견해 낸다. “누구도 무시하지 못할 실력을 쌓아라” “지위보다 자율성을 추구하라” “작은 생각에 집중하고, 큰 실천으로 나아가라”가 바로 그것이다.</p><p>이상의 4가지 원칙이야말로 자신이 하는 일을 사랑할 수 있게 해 주는 핵심 전략이다. 저자는 이런 큰 원칙들 아래 ‘커리어 자산을 쌓아라’ ‘장인 마인드셋을 갖추어라’ ‘자율성을 추구하되 함정에 빠지지 마라’ ‘사람들이 기꺼이 돈을 낼 일을 하라’ ‘사명감을 갖춰라’ ‘의식적 훈련에 매진하라’ ‘작은 도전에 승부를 걸어라’ ‘자신을 마케팅하라’ 등 구체적인 실천법을 제시한다. 그리고 다채로운 인물의 경험담과 연구 자료를 통해 그런 방법들을 실제로 어떻게 구현할 수 있는지 세세히 설명하면서 매력적인 커리어를 성취하는 로드맵을 제시한다.</p><p><small>예스24 제공</small></p></blockquote><br><h1 id="리뷰"><a class="markdownIt-Anchor" href="#리뷰"></a> 리뷰</h1><blockquote><p><strong>하고 싶은 일만 하면 정말 행복해질까?</strong></p></blockquote><p>궁금했다. 요즘의 내가 버거워서, 도피하고 싶은 마음이 가득해서, 재능이라곤 애매한 재능밖에 없는 것 같아서, 하고 싶은 일만 하면 지금보다 더 행복할 수 있을지 궁금했다. 평소 잘 읽지 않는 자기계발서가 눈에 들어왔다는 건 생각보다 더 큰 격변의 시기를 보내는 중임을 증명하는 게 아닐까.</p><p>바쁘다. 의도해서 벌인 일과, 의도하지 않았지만 생겨난 일들이 혼재한다. 나는 생각보다도 더 도태된 인간이었고, 이 알을 깨려 하는 노력이 올바른 방향의 노력인지 확신할 수 없었다. 그냥, <strong>과거에도 비슷한 일들이 있었고, 그럴 때마다 버텨냈고, 버티다 보면 지나갔기에 또 버티고 있었을 뿐이다.</strong></p><p>내 자신을 나약하다고 생각했다. 남들은 너무 열심히, 열정적으로, 잘 사는 것처럼 보였으니까. 내가 제일 못났는데, 그래서 나아가야 하는데 너무 더뎠다. 습득이 빠르지 않다는 건 알고 있었지만, 시간에 쫓기니 느릿느릿한 <strong>내가 못내 답답했다.</strong></p><br><blockquote><p>무엇이든 잘하게 되려면 시간이 걸린다는 점을 강조합니다. 자신만 해도 라디오 진행에서 즐거움을 얻기까지 오랜 세월이 필요했다고 고백하지요. <strong>“일을 통해 스스로를 단련하는 게 중요합니다. 실력이 갖춰질 때까지요. 그 기간이 가장 힘든 단계죠.”</strong></p></blockquote><br><p>우연히 만난 이 책이 나를 위로했다. 그냥 나는 가장 힘든 단계를 지나고 있을 뿐이라고, 반짝거리는 그들 또한 가장 힘든 단계를 거쳤다고 했다. 맞지, 내가 보는 건 그저 결과일 뿐이니까.</p><br><blockquote><p>그냥 회사에 출근해 <mark><strong>시키는 일만 한다면 안데르스 에릭슨이 이 장의 앞부분에서 설명한 대로 정체기 이전의 ‘적당한 수준’까지는 도달할 수 있겠죠.</strong></mark> 의식적 훈련을 통해 이 정체기를 넘어 경쟁자가 거의 없는 영역으로 올라설 수 있습니다. 하지만 이런 성과를 이룬 사람들이 극히 적은 이유는 바로 콜빈이 경고한 대로 <mark><strong>의식적 훈련은 대개 ‘즐거움’과는 거리가 멀기 때문이죠.</strong></mark></p></blockquote><br><p>타성에 젖지 않으려 노력했지만 천천히 멈추는 중이었던 것 같다. 정체기 이전의 '적당한 수준’이라는 문장이 머리를 쿵 쳤다. ‘내 이야기잖아?’ 나의 주요 업무는 '구조 개선’이나, '성능 개선’이 목표가 되어야 할 정도로 안정되어 있었다. 그리고 그 사실은 모든 사람이 알았나 보다. 지금 와서 생각해 보면 신규 프로젝트가 툭 떨어진 게 당연한 수순이었다.</p><p>그 프로젝트가 너무 버겁고 힘겨웠다. 즐겁지 않았고, 재미도 없었고, 그러다 보니 하기가 싫었다. 하하! 내가 하고 있던 게 의식적 훈련이라고?</p><br><blockquote><p>의식적 훈련을 묘사할 때 저는 “한계를 넘어선다”는 표현을 즐겨 씁니다. 제 개인적 경험에서 나온 표현이기도 하죠. <strong>새로운 수학적 기술을 배우는 과정은 의식적 훈련의 전형이라고 할 수 있는데, 이럴 때 제 머릿속에서는 육체적 과로와 비슷한 불편함이 느껴지거든요.</strong> 마치 제 뉴런들이 새롭게 재배열되는 듯한 기분이 들곤 합니다. <strong>어느 수학자나 인정하듯이 이런 한계를 넘어서는 느낌은 이미 익숙한 기술을 적용할 때의 즐거움과는 전혀 다르죠.</strong> <mark><strong>하지만 이 한계 극복 과정이 실력을 키우기 위한 전제 조건이라는 점 또한 모든 수학자들은 인정합니다.</strong></mark></p></blockquote><br><p>위 문장을 읽으며 유튜브에서 우연히 본 영상이 떠올랐다.</p><br><div class="video-container"><iframe src="https://www.youtube.com/embed/NVn0JmeXnuI" frameborder="0" loading="lazy" allowfullscreen></iframe></div><br><p>심각한 슬럼프를 겪었다던 아이유는 그 슬럼프를 넘어서기 위해 쉼과 새로운 도전을 택했다. 그리고 그 도전 너머에 즐거움이 있었다고 한다.</p><br><blockquote><p>이제 저는 <strong>‘압박감’을 긍정적으로 받아들일 줄 알게 됐죠.</strong> 압박감이 주는 불편함을 피해야 할 대상으로 여기지 않고, 보디빌더가 공들여 근육을 만들 때 타는 듯한 고통을 느끼는 것과 마찬가지로 <mark><strong>뭔가 제대로 하고 있을 때 느껴지는 신호라고 생각하게 된 겁니다.</strong></mark></p></blockquote><br><p>아마 아이유도 이젠 압박감을 긍정적으로 받아들이고 있지 않을까? 내가 아이유가 되어 보지도, 그만큼의 성공을 이뤄 보지도 못해서 확신할 수는 없지만 지금까지의 행보로 보면 음, 그럴 것 같다는 생각이 든다.</p><p>책을 읽으며 나를 되돌아봤다. 하면 하는대로 실력이 늘고, 해낼 자신감이 있었던 순간엔 일이 재미있었다. 이런 순간들이 모여 나를 정체기 이전의 '적당한 수준’까지 만들어 주었다. 지금 내가 느끼는 압박감은 긍정적인 것이며, 정체된 알을 깨고 나오려는 시도로 인해 생긴 힘듦과 어려움이다. 그렇다면 <strong>난 제대로 가고 있는 게 맞다.</strong> 내년의 내가 이 글을 볼 때 '그땐 그랬지, 귀엽네!'의 마음이길 바라며, <strong>이 확신을 잊지 않기 위해 기록한다.</strong></p><br>]]></content:encoded>
      
      
      <category domain="https://d2fault.github.io/categories/Anything/">Anything</category>
      
      <category domain="https://d2fault.github.io/categories/Anything/Review/">Review</category>
      
      
      <category domain="https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/">리뷰</category>
      
      <category domain="https://d2fault.github.io/tags/%EC%B1%85/">책</category>
      
      
      <comments>https://d2fault.github.io/2021/05/09/20210509-book-review-so-good-they-cant-ignore-you/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Diary] 매시업 10기 해커톤 회고하기</title>
      <link>https://d2fault.github.io/2021/03/01/20210301-diary/</link>
      <guid>https://d2fault.github.io/2021/03/01/20210301-diary/</guid>
      <pubDate>Mon, 01 Mar 2021 07:25:17 GMT</pubDate>
      
      <description>Ready, 1월 9일, 기다리고 기다리던 해커톤 팀이 발표됐다. 우리 팀은 iOS &amp; Android 팀으로, 디자이너와 서버(Spring)까지 총 12명!</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="ready"><a class="markdownIt-Anchor" href="#ready"></a> Ready,</h1><p>1월 9일, 기다리고 기다리던 해커톤 팀이 발표됐다. 우리 팀은 iOS &amp; Android 팀으로, 디자이너와 서버(Spring)까지 총 12명! 모든 것들을 비대면으로 진행하게 되어 어색함을 내려놓기까지 약간의 시간이 걸렸지만 주기적인 아이디어 회의와 깨알 같은 온라인 회식을 통해 하나의 팀으로 거듭났다. 😊 매주 한 번 이상, 1회 최소 2시간 이상의 찐-한 회의로 굉장히 끈끈해졌다는 후문.</p><p>해커톤 아이디에이션이 어느 정도 진행된 후에 아주 오랜 시간(거의 4-5시간?)의 온라인 회식을 함께했다. 참석 준비물은 맛있는 술과 안주! 우리는 각종 게임(어몽어스, 테트리스, 캐치마인드 등)을 섭렵하였는데, 마지막 게임은 결국 ‘말을 놓지 못하는 자, 마셔라!’ 로 귀결되었다. <s>(팀장님의 발언 쿨타임이 점멸 쿨타임과 같다는 썰이 있습니다.)</s></p><p>긴 설명 대신, 사진 한 장으로 우리의 우정 인증하기!</p><img src="/images/20210301-diary/0.jpg" style="zoom:40%;" /><p>카메라 안 켜고 진행한 회의가 더x99999 많았답니다. (사진 원본이 궁금하다면 매시업 11기에 도전하세요! 🥰)</p><br><h1 id="get-set"><a class="markdownIt-Anchor" href="#get-set"></a> Get set,</h1><p>노션을 만들고, 규칙을 정하고, 아이디어를 공유하고, 최종적으로 우리의 아이템이 결정되었다. 시작, 진짜_시작, 진짜_진짜_시작, 진짜_정말_최종_시작의 느낌이지만 아이템이 정해진 이후 우리는 더 분주해졌다. 회원 가입 유무, 오픈 방 유무, 관리자에게 어떤 권한까지 줄지 등 함께 정할 것들이 너무나도 많았다. 자칫 잘못하면 빙빙 돌 수도 있는 애매한 것들임에도 불구하고 <mark><strong>회의 전 명확한 안건 설정으로 시간 낭비를 막아낼 수 있었다.</strong></mark></p><p>기획의 디테일이 잡혀갈수록 디자이너들은 바빠졌다. IA, Wireframe 그리고 실제 디자인 가이드까지 80% 이상의 완성물을 해커톤 전까지 우리에게 공유해 주었다. 디스코드에서 밤낮없이 회의하던 갓 디자이너들의 모습이 아직도 눈에 선하다. <s>(한편으론 내가 그 멋진 디자인을 망칠까 걱정이 된다.)</s></p><p>어느 정도 디자인이 완성되던 그때, 디스코드에 서버 개발자들이 자주 등장했다. 지난 해커톤 팀의 경우 기획과 Wireframe만 대략적으로 잡고 모든 파트가 해커톤 당일에 0부터 시작했었는데 이번엔 다들 비대면에 익숙해져서 그런지 해커톤 전부터 무언가를 계속 준비하고 있었다. 그렇게 우리 팀의 서버는 전체적 구조 및 DB 설계가 완성된 상태로 해커톤을 맞이했다.</p><p>모바일 개발자들은 해커톤 전 github에 repository를 생성하였고, 애플리케이션 전체의 근간이 되는 베이스 코드를 작성하였다. 해커톤 당일에 UI 작업을 쉽게 하기 위해 밑작업을 해둔 셈이었다.</p><br><h1 id="go"><a class="markdownIt-Anchor" href="#go"></a> Go!</h1><p>모두가 바랐던 수도권의 5인 이상 집합 금지는 풀리지 않았다. 팀 전체(12명)는 절대로 모일 수 없었기에, 파트별로 모이기로 협의! 디자인과 서버는 건대, iOS는 판교, 그리고 안드로이드는 홍대에서 옹기종기 모여 작업하였다. 대면으로 하는 맛(?)은 덜했지만 우리를 연결해준 디스코드와 카카오톡 덕분에 큰 어려움은 없었다.</p><p>우리(안드로이드)의 해커톤 목표는 UI 작업 끝내기였다. 안드로이드 개발을 하지만 서비스와 거리가 먼 나의 개발 속도는 생각보다도 너무 너무 느려서 팀원들에게 굉장히 미안했다. 파트를 이끄는 것은 힘들지라도 <mark><strong>맡은 건 어떻게든 끝내는 팀원이고 싶었기에 할 수 있는 건 빠르게, 검색으로도 잘 나오지 않거나 정말 모르겠는 건 힌트를 얻어가는 방식으로 개발했다.</strong></mark> 작년 해커톤보다 성장한 건 확실한데, 성장한 수준이 그리 높지 않아서 좋아해야 할지 슬퍼해야 할지 모르겠다는 건 함정. (ㅠㅠ)</p><p>UI를 다 붙이려는 목표까진 달성하지 못했다. UI 진척도를 대략 80% 언저리까진 맞췄지만, 중간에 코드 머지하는 과정에서 약간의 이슈가 생겨 시연이 불가능했던 점은 아쉬웠다. 그래도 내 파트를 모두 개발한 것 뿐만 아니라(팀원보다 쉬운 페이지를 맡긴 했지만) <u><strong>추가적으로 무언가를 더 해냈다는 점에서 나를 굉장히 칭찬하고 싶다!</strong></u></p><br><h1 id="그리고"><a class="markdownIt-Anchor" href="#그리고"></a> 그리고</h1><p>우리는 실패했지만 iOS의 시연 영상 덕분에 엄청난 상을 받았다! 완성도 제일 높은 애플리케이션 상이라니! &gt;_&lt; 모든 팀들의 발표를 듣고 투표까지 마무리한 후 아주 잠깐 기절했었는데 정신을 차려보니 우리 팀이 상을 받다뇨?! 밤샘 피로가 싹 없어지(지는 않았지만)는 기분이었다.</p><p><img src="/images/20210301-diary/1.png" alt="" /></p><br><h1 id="마지막으로"><a class="markdownIt-Anchor" href="#마지막으로"></a> 마지막으로</h1><p>갓 디자이너들과 갓 개발자들 덕분에 즐겁고 행복한 해커톤이었다. 디자인과 서버가 이렇게 빨리 나오리라고는 상상도 못했는데 열정을 가지고 열심히 한 우리 팀원들 너무너무 대단하다! 아는 것도 별로 없는 느림보 데리고 개발한다고 고생한 우리 파트원들에게도 고맙고, 포기하지 않고 목표한 바를 이뤄낸 나에게도 고맙다. 두 명의 디자이너와 열 명의 개발자, TEAM TDTD(토닥토닥)의 속닥속닥 서비스 배포까지 모두 함께 잘 달렸으면 좋겠습니다. 🥰</p><img src="/images/20210301-diary/2.jpg" style="zoom:40%;" /><br><p>iOS 개발자들이 찍은 감성 가득한 해커톤 새벽의 하늘. 실물로 보는 게 더 더 더 예뻤다고 합니다. 아름다운 풍경 함께 보지 못해서 슬펐어요. ㅠ_ㅠ</p><img src="/images/20210301-diary/3.jpg" style="zoom:20%;" /><br><h1 id="github-repository-링크"><a class="markdownIt-Anchor" href="#github-repository-링크"></a> Github Repository 링크</h1><ul><li><a href="https://github.com/mash-up-kr/TDTD_Android">TDTD_Android</a></li><li><a href="https://github.com/mash-up-kr/TDTD_iOS">TDTD_iOS</a></li><li><a href="https://github.com/mash-up-kr/TDTD_Backend">TDTD_Backend</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://d2fault.github.io/categories/Anything/">Anything</category>
      
      <category domain="https://d2fault.github.io/categories/Anything/Diary/">Diary</category>
      
      
      <category domain="https://d2fault.github.io/tags/%ED%9A%8C%EA%B3%A0/">회고</category>
      
      <category domain="https://d2fault.github.io/tags/%ED%95%B4%EC%BB%A4%ED%86%A4/">해커톤</category>
      
      <category domain="https://d2fault.github.io/tags/%EB%A7%A4%EC%8B%9C%EC%97%85/">매시업</category>
      
      
      <comments>https://d2fault.github.io/2021/03/01/20210301-diary/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Kotlin] 코루틴(Coroutine) Context and Dispatchers</title>
      <link>https://d2fault.github.io/2021/02/21/20210221-coroutine-context-and-dispatchers/</link>
      <guid>https://d2fault.github.io/2021/02/21/20210221-coroutine-context-and-dispatchers/</guid>
      <pubDate>Sat, 20 Feb 2021 16:46:05 GMT</pubDate>
      
      <description>코루틴의 context 중 Dispatchers를 공부해 본다.</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="coroutine-context-and-dispatchers"><a class="markdownIt-Anchor" href="#coroutine-context-and-dispatchers"></a> Coroutine Context and Dispatchers</h1><p>코루틴은 항상 Kotlin 표준 라이브러리에 정의된 컨텍스트에서 실행된다. 코루틴 context에는 다양한 요소가 있으며, 그중 가장 중요한 요소는 이전 포스팅에서 다룬 <code>job</code>과 이번 포스팅에 다룰 <code>Dispatchers</code>이다.</p><p>※ IntelliJ나 Android Studio가 설치되어 있지 않다면 Kotlin 공식 사이트에서 지원하는 <mark><strong>온라인 IDE(<a href="https://play.kotlinlang.org/">Kotlin Playground</a>)를 사용하여 아래 코드를 실행할 수 있다.</strong></mark></p><br><h2 id="dispatchers-and-threads"><a class="markdownIt-Anchor" href="#dispatchers-and-threads"></a> Dispatchers and threads</h2><p>코루틴은 코루틴 컨텍스트에서 실행되는데, 코루틴 컨텍스트에 이 <code>Dispatchers</code>가 있다. <code>Dispatchers</code>는 코루틴을 어떤 스레드 혹은 스레드풀에서 실행할지 결정한다. 모든 코루틴 빌더는 optional로 <code>CoroutineContext</code> parameter를 가지고 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 코루틴이 main thread에서 실행됨</span></span><br><span class="line">    launch &#123; <span class="comment">// context of the parent, main runBlocking coroutine</span></span><br><span class="line">        println(<span class="string">&quot;main runBlocking      : I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 코루틴이 main thread에서 실행됨</span></span><br><span class="line">    launch(Dispatchers.Unconfined) &#123; <span class="comment">// not confined -- will work with main thread</span></span><br><span class="line">        println(<span class="string">&quot;Unconfined            : I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 코루틴이 DefaultDispather-worker-1에서 실행됨</span></span><br><span class="line">    launch(Dispatchers.Default) &#123; <span class="comment">// will get dispatched to DefaultDispatcher </span></span><br><span class="line">        println(<span class="string">&quot;Default               : I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 코루틴이 MyOwnThread에서 실행됨</span></span><br><span class="line">    launch(newSingleThreadContext(<span class="string">&quot;MyOwnThread&quot;</span>)) &#123; <span class="comment">// will get its own new thread</span></span><br><span class="line">        println(<span class="string">&quot;newSingleThreadContext: I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드 실행 결과는 다음과 같은데,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Unconfined            : I&#39;m working in thread main</span><br><span class="line">Default               : I&#39;m working in thread DefaultDispatcher-worker-1</span><br><span class="line">newSingleThreadContext: I&#39;m working in thread MyOwnThread</span><br><span class="line">main runBlocking      : I&#39;m working in thread main</span><br></pre></td></tr></table></figure><p>왠지 모르게 복잡해 보이는 이름을 출력한 <code>Dispatchers.Default</code> 가 특별(?)하게 느껴질 수도 있다. 그러나 <code>Dispatcher.Default</code> 는 global scope에서 실행했던 코루틴들이 실행되는 스레드를 뜻한다(==기본 스레드). 그러니까, global로 실행하나 <code>Dispatchers.Default</code> 로 실행하나 결국 같은 스레드라는 의미이다.</p><p>코루틴을 생성할 때마다 <code>newSingleThreadContext</code> 를 만드는 방식은 비용이 높은 방식이다. 새차원님의 강의에 따르면, 위 예시의 방식으로 작성하는 것보다 다음과 같이</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">newSingleThreadContext().use &#123;</span><br><span class="line">    launch(it) &#123;</span><br><span class="line">        println(<span class="string">&quot;newSingleThreadContext: I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사용하는 것이 좋다고 한다. 왜냐하면 <code>newSingleThreadContext</code> 를 호출하면 새로운 스레드를 만들게 되고, 이 경우 <code>close</code> 를 하지 않으면 메모리 누수가 발생할 수 있기 때문이다. <code>use</code> 를 사용할 경우 <code>close</code> 처리를 알아서 해 주기 때문에 이 방식을 권장한다.</p><p>그리고 당연히 <code>Dispatchers</code> 를 지정하지 않아도 코루틴 실행에는 문제가 없다.</p><br><h2 id="unconfined-vs-confined-dispatcher"><a class="markdownIt-Anchor" href="#unconfined-vs-confined-dispatcher"></a> Unconfined vs confined dispatcher</h2><p><code>Dispatchers.Unconfined</code> 는 호출한 스레드에서 코루틴을 시작하지만, 첫번째 suspension point까지만 그 스레드에 머물러 있다. 중단 이후 코루틴이 재개(resume)되면 resume을 명령한 코루틴 스레드에서 수행된다. <code>Dispatchers.Unconfined</code> 는 어떤 스레드에서 동작해도 무관할 때에 사용하면 된다. 즉, <code>Dispatchers.Unconfined</code> 는 시작 스레드와 종료 스레드가 같지 않기 때문에 프로그램의 규모가 커질 경우 어디서 종료될지 예측이 어려워진다. <s>도큐먼트에서는 특수한 상황(사실 어떤 상황에 도움이 될지 잘 모르겠다.)에는 도움이 될 수 있는 진보된 매커니즘이라고 소개하는데, 웬만해서 사용하지 않는 것이 좋을 것 같다.</s></p><p>반면, 코루틴 컨텍스트 요소들은 보통 부모 코루틴 스코프의 컨텍스트 요소가 자식 컨텍스트 요소에게 상속된다. 특히 <code>runBlocking</code> 코루틴의 기본 디스패처는 호출한 스레드에 국한되기 때문에 이를 상속하는 것은 그 스레드에만 국한되도록 하는 효과가 있다. 예측 가능한 FIFO 스케줄링이 필요할 때 confined dispatcher를 사용하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    launch(Dispatchers.Unconfined) &#123; <span class="comment">// not confined -- will work with main thread</span></span><br><span class="line">        println(<span class="string">&quot;Unconfined      : I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">500</span>)</span><br><span class="line">        println(<span class="string">&quot;Unconfined      : After delay in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    launch &#123; <span class="comment">// context of the parent, main runBlocking coroutine</span></span><br><span class="line">        println(<span class="string">&quot;main runBlocking: I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;main runBlocking: After delay in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드를 실행해 보면 다음의 결과를 볼 수 있다.</p><p><img src="/images/20210221-coroutine_context_and_dispatchers/1.jpg" alt="" /></p><p><code>launch</code> 에 별다른 디스패처 세팅을 하지 않은 코루틴은 <code>runBlocking</code> 을 따라 호출한 스레드에 국한되어 실행된다. 반면 <mark><strong><code>Dispatchers.Unconfined</code> 세팅을 한 코루틴은 <code>delay</code> 전과 후에 코루틴이 실행되는 스레드가 다르다.</strong></mark></p><br><h2 id="debugging-coroutines-and-threads"><a class="markdownIt-Anchor" href="#debugging-coroutines-and-threads"></a> Debugging coroutines and threads</h2><h3 id="debugging-with-idea"><a class="markdownIt-Anchor" href="#debugging-with-idea"></a> Debugging with IDEA</h3><p>코루틴은 한 스레드에서 중단된 후 다른 스레드에서 재개될 수 있다. 단일 스레드 디스패처에서조차 어떤 코루틴이 언제, 어디서 수행 중이었는지 알아내는 건 어렵다. 일반적으로 스레드를 사용하는 애플리케이션을 디버깅할 땐 각각의 로그마다 현재 수행 중인 스레드의 이름을 붙여 출력한다. 이 기능은 보통 logging framework에서 지원하며, 코루틴 프레임워크 또한 디버깅 기능을 제공한다.</p><blockquote><p>단, 디버깅 기능은 <code>kotlinx-coroutines-core</code> 버전 1.3.8 이상에서만 지원한다.</p></blockquote><p>JVM 옵션에 <code>-Dkotlinx.coroutines.debug</code> 을 추가하면 Thread 명에 추가로 코루틴 이름까지 출력되는 것을 확인할 수 있다.</p><p><img src="/images/20210221-coroutine_context_and_dispatchers/2.jpg" alt="" /></p><p>코루틴 디버거를 사용하여 디버그 모드로 애플리케이션을 실행하면 다음과 같은 기능을 사용할 수 있다.</p><ol><li>각 코루틴의 상태 확인</li><li>실행 중인 코루틴과 일시 중지된 코루틴 모두에 대한 변수 값 확인</li><li>전체 코루틴 생성 스택과 내부 호출 스택 확인</li><li>각 코루틴의 상태와 스택이 포함된 전체 정보</li></ol><br><h4 id="참고-android-studio에-vm-옵션-설정하기"><a class="markdownIt-Anchor" href="#참고-android-studio에-vm-옵션-설정하기"></a> [참고] Android Studio에 VM 옵션 설정하기</h4><ol><li>Help &gt; Edit Custom VM Options 클릭</li><li>VM 옵션을 한 번도 수정한 적이 없다면 새로운 <code>studio.vmoptions</code> 를 생성하라는 메시지가 출력됨 → Yes 클릭</li><li>오픈된 <code>studio.vmoptions</code> 파일에 위의 VM 옵션을 추가한다.</li></ol><p>자세한 내용은 <a href="https://developer.android.com/studio/intro/studio-config?hl=ko#customize_vm">공식 도큐먼트</a>를 참고하자.</p><br><h3 id="debugging-using-logging"><a class="markdownIt-Anchor" href="#debugging-using-logging"></a> Debugging using logging</h3><p>디버거가 없는 애플리케이션을 디버깅하기 위해 로그에 스레드 이름을 출력하는 방법이 있다. JVM 옵션을 추가하는 위의 방식이 더 발전된 방식이기에 위의 방법을 권장한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> = println(<span class="string">&quot;[<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> a = async &#123;</span><br><span class="line">        log(<span class="string">&quot;I&#x27;m computing a piece of the answer&quot;</span>)</span><br><span class="line">        <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> b = async &#123;</span><br><span class="line">        log(<span class="string">&quot;I&#x27;m computing another piece of the answer&quot;</span>)</span><br><span class="line">        <span class="number">7</span></span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;The answer is <span class="subst">$&#123;a.await() * b.await()&#125;</span>&quot;</span>)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드의 출력 결과는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[main @coroutine#2] I&#39;m computing a piece of the answer</span><br><span class="line">[main @coroutine#3] I&#39;m computing another piece of the answer</span><br><span class="line">[main @coroutine#1] The answer is 42</span><br></pre></td></tr></table></figure><br><h2 id="jumping-between-threads"><a class="markdownIt-Anchor" href="#jumping-between-threads"></a> Jumping between threads</h2><p>코루틴이 처음 실행했던 스레드에서 벗어나서 다른 스레드에 갔다가 다시 처음 스레드로 복귀하는 형태의 예제이다. 예를 들어, 안드로이드 메인 스레드에서 백그라운드 스레드에 갔다가 다시 메인스레드로 돌아오는 듯한 기능을 쉽게 만들 수 있게 해 주는 중요한 기능이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> = println(<span class="string">&quot;[<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    newSingleThreadContext(<span class="string">&quot;Ctx1&quot;</span>).use &#123; ctx1 -&gt;</span><br><span class="line">        newSingleThreadContext(<span class="string">&quot;Ctx2&quot;</span>).use &#123; ctx2 -&gt;</span><br><span class="line">            runBlocking(ctx1) &#123;</span><br><span class="line">                log(<span class="string">&quot;Started in ctx1&quot;</span>)</span><br><span class="line">                withContext(ctx2) &#123;</span><br><span class="line">                    log(<span class="string">&quot;Working in ctx2&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">&quot;Back to ctx1&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 가장 중요한 부분은 <code>withContext()</code> 이다. <code>withContext()</code> 에 스레드를 지정해 주면 그 스레드에서 코루틴을 실행하고, 실행이 끝나면 다시 원래 스레드(ctx1)로 돌아온다. 실행 결과는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## Ctx1에서 Started in ctx1 로그 출력</span><br><span class="line">[Ctx1 @coroutine#1] Started in ctx1</span><br><span class="line">## Ctx2에서 Working in ctx2 로그 출력</span><br><span class="line">[Ctx2 @coroutine#1] Working in ctx2</span><br><span class="line">## 다시 Ctx1으로 돌아와서 Back to ctx1 로그 출력</span><br><span class="line">[Ctx1 @coroutine#1] Back to ctx1</span><br></pre></td></tr></table></figure><br><h2 id="job-in-the-context"><a class="markdownIt-Anchor" href="#job-in-the-context"></a> Job in the context</h2><p>코루틴 컨텍스트에서 <code>Job</code> 을 탐색해 보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    println(<span class="string">&quot;My job is <span class="subst">$&#123;coroutineContext[Job]&#125;</span>&quot;</span>)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드를 실행하면 다음과 같이 출력된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">My job is &quot;coroutine#1&quot;:BlockingCoroutine&#123;Active&#125;@573fd745</span><br></pre></td></tr></table></figure><p>이건, “코루틴 컨텍스트에서 <code>Job</code> 엘리먼트를 꺼내 보았더니 존재(<code>BlockingCoroutine</code> 로)하더라.” 라는 의미이다.</p><br><h2 id="children-of-a-coroutine"><a class="markdownIt-Anchor" href="#children-of-a-coroutine"></a> Children of a coroutine</h2><p>코루틴이 실행될 때 <code>Job</code> 사이에 부모-자식 관계가 있다는 것을 보여주는 예제이다. 하나의 새로운 코루틴이 실행되면 그 코루틴은 부모 코루틴의 자식이 된다.</p><p>단, <code>GlobalScope.launch</code> 는 부모-자식 관계가 없는 독립 스코프로, 별도로 <code>Job</code> 이 생성된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// launch a coroutine to process some kind of incoming request</span></span><br><span class="line">    <span class="keyword">val</span> request = launch &#123;</span><br><span class="line">        <span class="comment">// it spawns two other jobs, one with GlobalScope</span></span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            println(<span class="string">&quot;job1: I run in GlobalScope and execute independently!&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">&quot;job1: I am not affected by cancellation of the request&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// and the other inherits the parent context</span></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">            println(<span class="string">&quot;job2: I am a child of the request coroutine&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">&quot;job2: I will not execute this line if my parent request is cancelled&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">500</span>)</span><br><span class="line">    <span class="comment">// 부모 코루틴을 취소했을 때 둘 중 어느 코루틴이 취소될까?</span></span><br><span class="line">    request.cancel()</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// delay a second to see what happens</span></span><br><span class="line">    println(<span class="string">&quot;main: Who has survived request cancellation?&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark><strong>부모 코루틴이 취소되면 자식 코루틴 또한 취소된다.</strong></mark> 그래서 위 예제의 결과는</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">job1: I run in GlobalScope and execute independently! [DefaultDispatcher-worker-1]</span><br><span class="line">job2: I am a child of the request coroutine [main]</span><br><span class="line">## 부모 코루틴 취소 요청 이후 job1은 취소되지 않음(부모-자식 관계 X)</span><br><span class="line">job1: I am not affected by cancellation of the request [DefaultDispatcher-worker-2]</span><br><span class="line">main: Who has survived request cancellation? [main]</span><br></pre></td></tr></table></figure><p>위와 같이 출력되며, <code>job2: I will not execute this line if my parent request is cancelled</code> 로그는 출력되지 않는다.</p><br><h2 id="parental-responsibilities"><a class="markdownIt-Anchor" href="#parental-responsibilities"></a> Parental responsibilities</h2><p>부모 코루틴은 모든 자식 코루틴의 실행 완료를 기다리기 때문에 <code>join</code> 을 사용하지 않아도 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// launch a coroutine to process some kind of incoming request</span></span><br><span class="line">    <span class="keyword">val</span> request = launch &#123;</span><br><span class="line">        repeat(<span class="number">3</span>) &#123; i -&gt; <span class="comment">// launch a few children jobs</span></span><br><span class="line">            launch  &#123;</span><br><span class="line">                delay((i + <span class="number">1</span>) * <span class="number">200L</span>) <span class="comment">// variable delay 200ms, 400ms, 600ms</span></span><br><span class="line">                println(<span class="string">&quot;Coroutine <span class="variable">$i</span> is done&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;request: I&#x27;m done and I don&#x27;t explicitly join my children that are still active&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 없어도 잘 동작함</span></span><br><span class="line">    request.join() <span class="comment">// wait for completion of the request, including all its children</span></span><br><span class="line">    println(<span class="string">&quot;Now processing of the request is complete&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>13 라인의 <code>request.join()</code> 을 지우고 위의 코드를 실행해 보면 좋을 것 같다. 부모가 자식 코루틴의 실행을 기다리기 때문에 <code>join()</code> 없이도 정상 동작함을 확인할 수 있다.</p><br><h2 id="naming-coroutines-for-debugging"><a class="markdownIt-Anchor" href="#naming-coroutines-for-debugging"></a> Naming coroutines for debugging</h2><p>디버깅을 위한 이름 설정 팁을 알려주는 예시이다. <strong><mark><code>CoroutineName</code> 이라는 컨텍스트 요소를 사용하면 스레드 이름과 동일하게 코루틴 이름을 지정할 수 있다.</mark></strong> 만일 디버깅 모드라면 <code>CoroutineName</code> 은 코루틴 수행 중인 스레드 이름에 함께 출력된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    log(<span class="string">&quot;Started main coroutine&quot;</span>)</span><br><span class="line">    <span class="comment">// run two background value computations</span></span><br><span class="line">    <span class="keyword">val</span> v1 = async(CoroutineName(<span class="string">&quot;v1coroutine&quot;</span>)) &#123;</span><br><span class="line">        delay(<span class="number">500</span>)</span><br><span class="line">        log(<span class="string">&quot;Computing v1&quot;</span>)</span><br><span class="line">        <span class="number">252</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> v2 = async(CoroutineName(<span class="string">&quot;v2coroutine&quot;</span>)) &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        log(<span class="string">&quot;Computing v2&quot;</span>)</span><br><span class="line">        <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;The answer for v1 / v2 = <span class="subst">$&#123;v1.await() / v2.await()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>결과는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[main @coroutine#1] Started main coroutine</span><br><span class="line">[main @v1coroutine#2] Computing v1</span><br><span class="line">[main @v2coroutine#3] Computing v2</span><br><span class="line">[main @coroutine#1] The answer for v1 &#x2F; v2 &#x3D; 42</span><br></pre></td></tr></table></figure><p>모든 코루틴이 <code>main</code> 스레드에서 실행된 사실과 함께 <code>CoroutineName()</code> 을 이용하여 지정해준 이름이 로그에 출력됨을 확인할 수 있었다.</p><br><h2 id="combining-context-elements"><a class="markdownIt-Anchor" href="#combining-context-elements"></a> Combining context elements</h2><p>CoroutineContext에 여러 요소를 정의할 수 있으며, 이때 <code>+</code> 연산을 사용할 수 있다. 아래 예제에서는 <code>Dispatchers</code> 와 <code>CoroutineName</code> 을 함께 사용하였다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    launch(Dispatchers.Default + CoroutineName(<span class="string">&quot;test&quot;</span>)) &#123;</span><br><span class="line">        println(<span class="string">&quot;I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음과 같은 실행 결과를 얻을 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I&#39;m working in thread DefaultDispatcher-worker-1 @test#2</span><br></pre></td></tr></table></figure><br><h2 id="coroutine-scope"><a class="markdownIt-Anchor" href="#coroutine-scope"></a> Coroutine Scope</h2><p><mark><strong>생명 주기가 있는 객체에서 코루틴을 사용할 땐 메모리 누수 방지를 위해 꼭 코루틴을 취소해 주어야 한다.</strong></mark> 아래 코드와 같이 하나의 코루틴 스코프를 생성하고, 그 스코프를 이용하여 동작하도록 하는 방식으로 개발하는 것이 유지보수에 용이하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mainScope라는 코루틴 스코프 생성</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mainScope = CoroutineScope(Dispatchers.Default)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">destroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 화면 destory시 mainScope cancel</span></span><br><span class="line">        mainScope.cancel()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// launch ten coroutines for a demo, each working for a different time</span></span><br><span class="line">        repeat(<span class="number">10</span>) &#123; i -&gt;</span><br><span class="line">            mainScope.launch &#123;</span><br><span class="line">                delay((i + <span class="number">1</span>) * <span class="number">200L</span>) <span class="comment">// variable delay 200ms, 400ms, ... etc</span></span><br><span class="line">                println(<span class="string">&quot;Coroutine <span class="variable">$i</span> is done&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// class Activity ends</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> activity = Activity()</span><br><span class="line">    activity.doSomething() <span class="comment">// run test function</span></span><br><span class="line">    println(<span class="string">&quot;Launched coroutines&quot;</span>)</span><br><span class="line">    delay(<span class="number">500L</span>) <span class="comment">// delay for half a second</span></span><br><span class="line">    println(<span class="string">&quot;Destroying activity!&quot;</span>)</span><br><span class="line">    <span class="comment">// 모든 코루틴 스코프가 삭제된다!</span></span><br><span class="line">    activity.destroy()</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// visually confirm that they don&#x27;t work    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>28 라인의 <code>activity.destroy()</code> 를 없애고, 29 라인의 <code>delay(1000)</code> 을 <code>delay(3000)</code> 으로 변경하여 테스트해 보는 것도 의미가 있다. 3초 후에 <code>main()</code> 이 끝나야 하지만 코루틴 스코프를 취소하지 않기에 코루틴이 계속 동작한다. (메모리 누수 발생 위험)</p><h3 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h3><p>ktx 유저는 <code>lifecycleScope</code> 와 <code>viewmodelScope</code> 를 사용하는 것이 좋다. 취소 작업을 알아서 처리하기 때문에 별도로 작업하지 않아도 된다.</p><br><h2 id="thread-local-data"><a class="markdownIt-Anchor" href="#thread-local-data"></a> Thread-local data</h2><p>가끔 스레드 로컬 데이터를 코루틴으로 전달하거나 혹은 코루틴 간에 전달하는 기능이 유용할 때가 있다. 그러나 코루틴은 특정 스레드에 국한되어 실행되지 않음으로, 이런 기능을 직접 구현하기 위해선 많은 작업이 필요하다.</p><p><code>ThreadLocal</code> 을 위해 <code>asContextElement()</code> 확장 함수를 사용할 수 있다. 이 함수는 <code>ThreadLocal</code> 의 값을 저장했다가 코루틴이 속한 컨텍스트가 변경될 때마다 해당 값을 복원한다. <s>(조금 다르지만 <code>static</code> 변수로 저장하는 느낌! 그런 느낌으로만 이해했다.)</s></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> threadLocal = ThreadLocal&lt;String?&gt;() <span class="comment">// declare thread-local variable</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    threadLocal.<span class="keyword">set</span>(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Pre-main, current thread: <span class="subst">$&#123;Thread.currentThread()&#125;</span>, thread local value: &#x27;<span class="subst">$&#123;threadLocal.get()&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">    <span class="comment">// asContextElement 주목</span></span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default + threadLocal.asContextElement(value = <span class="string">&quot;launch&quot;</span>)) &#123;</span><br><span class="line">        println(<span class="string">&quot;Launch start, current thread: <span class="subst">$&#123;Thread.currentThread()&#125;</span>, thread local value: &#x27;<span class="subst">$&#123;threadLocal.get()&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        yield()</span><br><span class="line">        println(<span class="string">&quot;After yield, current thread: <span class="subst">$&#123;Thread.currentThread()&#125;</span>, thread local value: &#x27;<span class="subst">$&#123;threadLocal.get()&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line">    println(<span class="string">&quot;Post-main, current thread: <span class="subst">$&#123;Thread.currentThread()&#125;</span>, thread local value: &#x27;<span class="subst">$&#123;threadLocal.get()&#125;</span>&#x27;&quot;</span>)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실행 결과는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pre-main, current thread: Thread[main @coroutine#1,5,main], thread local value: &#39;main&#39;</span><br><span class="line">Launch start, current thread: Thread[DefaultDispatcher-worker-1 @coroutine#2,5,main], thread local value: &#39;launch&#39;</span><br><span class="line">After yield, current thread: Thread[DefaultDispatcher-worker-2 @coroutine#2,5,main], thread local value: &#39;launch&#39;</span><br><span class="line">Post-main, current thread: Thread[main @coroutine#1,5,main], thread local value: &#39;main&#39;</span><br></pre></td></tr></table></figure><p>그런데 이 방식은 코루틴을 실행하는 스레드가 다를 경우 코루틴에서 접근한 스레드 로컬 변수는 예상하지 못한 값을 들고 있을 수도 있다. 이런 상황을 방지하기 위해서 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html"><code>ensurePresent</code></a> 메서드를 사용하고, 부적절한 사용시 <code>fail-fast</code> 를 사용하는 것이 좋다.</p><p>스레드 로컬 변수에 다른 값을 업데이트하고 싶다면 <code>withContext</code> 를 사용하면 된다. 자세한 내용은 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/as-context-element.html"><code>asContextElement</code></a> 를 참조하자.</p><br><h1 id="참고-2"><a class="markdownIt-Anchor" href="#참고-2"></a> 참고</h1><ul><li><a href="https://kotlinlang.org/docs/reference/coroutines/coroutine-context-and-dispatchers.html">코루틴 공식 문서 - Coroutine Context and Dispatchers</a></li><li><a href="https://youtu.be/0uIrl47bSTA">새차원의 코틀린 코루틴 강좌 #6 - Coroutine Context and Dispatchers</a></li><li><a href="https://developer.android.com/topic/libraries/architecture/coroutines?hl=ko">아키텍처 구성요소와 함께 Kotlin 코루틴 사용</a></li><li><a href="https://myungpyo.medium.com/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EA%B3%B5%EC%8B%9D-%EA%B0%80%EC%9D%B4%EB%93%9C-%EC%9E%90%EC%84%B8%ED%9E%88-%EC%9D%BD%EA%B8%B0-part-5-62e886f7862d">코루틴 공식 가이드 자세히 읽기 - Part 5</a></li><li><a href="https://jjjhong.tistory.com/33">[Android] 코루틴 Coroutine Context and Dispatchers</a></li></ul><br>]]></content:encoded>
      
      
      <category domain="https://d2fault.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://d2fault.github.io/categories/Programming/Android/">Android</category>
      
      
      <category domain="https://d2fault.github.io/tags/kotlin/">kotlin</category>
      
      <category domain="https://d2fault.github.io/tags/coroutine/">coroutine</category>
      
      <category domain="https://d2fault.github.io/tags/Android/">Android</category>
      
      <category domain="https://d2fault.github.io/tags/context/">context</category>
      
      <category domain="https://d2fault.github.io/tags/dispatchers/">dispatchers</category>
      
      
      <comments>https://d2fault.github.io/2021/02/21/20210221-coroutine-context-and-dispatchers/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Kotlin] 코루틴(Coroutine) Composing Suspending Functions</title>
      <link>https://d2fault.github.io/2021/02/19/20210219-coroutine-composing-suspending-functions/</link>
      <guid>https://d2fault.github.io/2021/02/19/20210219-coroutine-composing-suspending-functions/</guid>
      <pubDate>Thu, 18 Feb 2021 16:25:50 GMT</pubDate>
      
      <description>이번 포스팅에서는 코루틴의 일시 중단 함수를 조합하여 활용하는 방법을 알아본다.</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="composing-suspending-functions"><a class="markdownIt-Anchor" href="#composing-suspending-functions"></a> Composing Suspending Functions</h1><p>이번 포스팅에서는 코루틴의 일시 중단 함수를 조합하여 활용하는 방법을 알아본다.</p><p>※ IntelliJ나 Android Studio가 설치되어 있지 않다면 Kotlin 공식 사이트에서 지원하는 <mark><strong>온라인 IDE(<a href="https://play.kotlinlang.org/">Kotlin Playground</a>)를 사용하여 아래 코드를 실행할 수 있다.</strong></mark></p><br><h2 id="sequential-by-default"><a class="markdownIt-Anchor" href="#sequential-by-default"></a> Sequential by default</h2><p>아래 코드는 어떤 유용한 기능(?) 두 가지를 순차적으로 실행 및 조합하여 결과를 내도록 구현되어 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> one = doSomethingUsefulOne()</span><br><span class="line">        <span class="keyword">val</span> two = doSomethingUsefulTwo()</span><br><span class="line">        println(<span class="string">&quot;The answer is <span class="subst">$&#123;one + two&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Completed in <span class="variable">$time</span> ms&quot;</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulOne</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// pretend we are doing something useful here</span></span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulTwo</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// pretend we are doing something useful here, too</span></span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark><strong>코루틴에서는 일반 코드처럼 작성하면 비동기적인 기능일지라도 순차적으로 실행한다.</strong></mark> 즉, 위의 코드는</p><ol><li><code>doSomethingUsefulOne()</code> 실행</li><li><code>doSomethingUsefulTwo()</code> 실행</li><li><code>println(&quot;The answer is $&#123;one + two&#125;&quot;)</code> 실행</li></ol><p>순서로 진행된다.</p><br><h2 id="concurrent-using-async"><a class="markdownIt-Anchor" href="#concurrent-using-async"></a> Concurrent using async</h2><p>만약 두 연산에 dependency가 없다면 동시에 실행하는 것이 리소스를 효율적으로 사용할 수 있을 것이다. 아래 코드를 참고하자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> one = async &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">        <span class="keyword">val</span> two = async &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">        println(<span class="string">&quot;The answer is <span class="subst">$&#123;one.await() + two.await()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Completed in <span class="variable">$time</span> ms&quot;</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulOne</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// pretend we are doing something useful here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulTwo</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// pretend we are doing something useful here, too</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코루틴 빌더인 <code>async</code> 키워드를 사용하면 비동기를 비동기처럼(?) 동작하게 할 수 있다.</p><br><h2 id="lazily-started-async"><a class="markdownIt-Anchor" href="#lazily-started-async"></a> Lazily started async</h2><p><code>async</code> 로 실행하는 코루틴을 ‘나중에’ 실행하는 방법을 보여주는 예제이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> one = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">        <span class="keyword">val</span> two = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">        <span class="comment">// some computation</span></span><br><span class="line">        one.start() <span class="comment">// start the first one</span></span><br><span class="line">        two.start() <span class="comment">// start the second one</span></span><br><span class="line">        println(<span class="string">&quot;The answer is <span class="subst">$&#123;one.await() + two.await()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Completed in <span class="variable">$time</span> ms&quot;</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulOne</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// pretend we are doing something useful here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulTwo</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// pretend we are doing something useful here, too</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>async</code> 의 매개변수에 <code>start = CoroutineStart.LAZY</code> 를 추가하게 되면 해당 코루틴은 바로 실행되지 않는다. <code>LAZY</code> 가 걸린 코루틴을 <code>start()</code> 하거나 <code>await()</code> 를 해 줄 때 비로소 값을 받을 수 있다.</p><p><code>async</code> 는 인자를 받을 수 있는데, 아무 인자도 넣지 않으면 바로 실행하는(<code>start = CoroutineStart.Default</code>) 것이 default이다. 즉, <code>start()</code> 나 <code>await()</code> 를 만나지 않아도 내부적으로는 이미 그 코루틴이 실행된 상태라는 의미이다. 다음의 코드를 실행해 보면 이해가 조금 쉬울 듯하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> one = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">        <span class="keyword">val</span> two = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">        <span class="comment">// some computation</span></span><br><span class="line">        one.start() <span class="comment">// start the first one</span></span><br><span class="line">        two.start() <span class="comment">// start the second one</span></span><br><span class="line">        println(<span class="string">&quot;The answer is <span class="subst">$&#123;one.await() + two.await()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Completed in <span class="variable">$time</span> ms&quot;</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulOne</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// pretend we are doing something useful here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulTwo</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// pretend we are doing something useful here, too</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h3><ul><li><code>start()</code><ul><li>코루틴을 시작한다. 시작할 수 있으면 <code>true</code>, 없으면 <code>false</code> 를 반환한다.</li></ul></li><li><code>await()</code><ul><li>이미 <code>start()</code> 된 코루틴의 경우 실행된 값을 반환하고, <code>start()</code> 되기 전 코루틴이라면 실행 및 값을 반환한다.</li></ul></li></ul><br><h2 id="async-style-functions"><a class="markdownIt-Anchor" href="#async-style-functions"></a> Async-style functions</h2><p><strong>이렇게 사용하지 마라고 권고하는</strong> 내용의 예제이다. async-style의 함수는 exception이 발생했을 때 돌이킬 수 없는 상황에 봉착하게 된다. (exception이 발생되어도 코루틴이 죽지 않고 좀비로 남는 모습을 볼 수 있음.)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note that we don&#x27;t have `runBlocking` to the right of `main` in this example</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="comment">// somethingUseful~ 함수는 suspend 함수가 아님(누구나 실행 가능)</span></span><br><span class="line">        <span class="keyword">val</span> one = somethingUsefulOneAsync()</span><br><span class="line">        <span class="keyword">val</span> two = somethingUsefulTwoAsync()</span><br><span class="line">        <span class="comment">// but waiting for a result must involve either suspending or blocking.</span></span><br><span class="line">        <span class="comment">// here we use `runBlocking &#123; ... &#125;` to block the main thread while waiting for the result</span></span><br><span class="line">        runBlocking &#123;</span><br><span class="line">            println(<span class="string">&quot;The answer is <span class="subst">$&#123;one.await() + two.await()&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Completed in <span class="variable">$time</span> ms&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">somethingUsefulOneAsync</span><span class="params">()</span></span> = GlobalScope.async &#123;</span><br><span class="line">    <span class="comment">// doSomethingUseful~ 함수는 suspend 함수임</span></span><br><span class="line">    doSomethingUsefulOne()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">somethingUsefulTwoAsync</span><span class="params">()</span></span> = GlobalScope.async &#123;</span><br><span class="line">    doSomethingUsefulTwo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulOne</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// pretend we are doing something useful here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulTwo</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// pretend we are doing something useful here, too</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코루틴을 <mark><strong>아무 곳에서나 마구 사용할 수 있게 만든 위와 같은 코드는 절대적으로 지양해야 한다.</strong></mark></p><br><h2 id="structured-concurrency-with-async"><a class="markdownIt-Anchor" href="#structured-concurrency-with-async"></a> Structured concurrency with async</h2><p>이전 예제에서 안 좋은 코드를 예로 들었다면, 이번 코드는 권장하는 스타일을 제안한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        println(<span class="string">&quot;The answer is <span class="subst">$&#123;concurrentSum()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Completed in <span class="variable">$time</span> ms&quot;</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// coroutineScope로 감싸서 suspend function으로 바꿔주었다.</span></span><br><span class="line"><span class="comment">// suspend function은 아무 곳에서나 호출할 수 있는 형태가 아닌 코루틴 내에서만 사용 가능</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">concurrentSum</span><span class="params">()</span></span>: <span class="built_in">Int</span> = coroutineScope &#123;</span><br><span class="line">    <span class="keyword">val</span> one = async &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">    <span class="keyword">val</span> two = async &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">    one.await() + two.await()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulOne</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// pretend we are doing something useful here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulTwo</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// pretend we are doing something useful here, too</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예제처럼 scope 안에서 suspending function들을 조립해서 사용해야 한다. <strong>exception이 발생할 경우 코루틴 블록 내부의 모든 코루틴이 취소되어 우리의 코드는 안전할 것임.</strong> 코루틴 좀비 해결!</p><br><h2 id="cancellation-propagated-coroutines-hierarchy"><a class="markdownIt-Anchor" href="#cancellation-propagated-coroutines-hierarchy"></a> Cancellation propagated coroutines hierarchy</h2><p>아래 예제는 <code>async</code> 로 작성된 코루틴에서 exception이 발생할 경우 어떤 결과가 나타날지 시뮬레이션해 보는 코드이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        failedConcurrentSum()</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e: ArithmeticException) &#123;</span><br><span class="line">        println(<span class="string">&quot;Computation failed with ArithmeticException&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">failedConcurrentSum</span><span class="params">()</span></span>: <span class="built_in">Int</span> = coroutineScope &#123;</span><br><span class="line">    <span class="keyword">val</span> one = async&lt;<span class="built_in">Int</span>&gt; &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            delay(<span class="built_in">Long</span>.MAX_VALUE) <span class="comment">// Emulates very long computation</span></span><br><span class="line">            <span class="number">42</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;First child was cancelled&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> two = async&lt;<span class="built_in">Int</span>&gt; &#123; </span><br><span class="line">        println(<span class="string">&quot;Second child throws an exception&quot;</span>)</span><br><span class="line">        <span class="keyword">throw</span> ArithmeticException()</span><br><span class="line">    &#125;</span><br><span class="line">    one.await() + two.await()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark><strong><code>asnyc</code> 로 실행된 코루틴 중 하나의 코루틴에서 exception이 발생할 경우, 이 exception은 다른 코루틴에게 영향을 주어 결국 모든 코루틴이 중단되게 한다.</strong></mark></p><br><h1 id="정리"><a class="markdownIt-Anchor" href="#정리"></a> 정리</h1><ul><li>일반 코드처럼 코틀린 코드를 작성할 경우 순서대로 동작한다.</li><li>일반 비동기 코드처럼 동시에 실행하고 싶다면 코루틴 빌더인 <code>async</code> 를 이용하자.</li><li>코루틴을 일반 함수로 감싸 아무 곳에서나 실행할 수 있는 미친 짓은 절대로 하지 말자. (exception 터질 때 감당 불가)</li></ul><br><h1 id="참고-2"><a class="markdownIt-Anchor" href="#참고-2"></a> 참고</h1><ul><li><a href="https://kotlinlang.org/docs/reference/coroutines/composing-suspending-functions.html">코루틴 공식 문서 - Composing Suspending Functions</a></li><li><a href="https://youtu.be/0viswXto028">새차원의 코틀린 코루틴 강좌 #4 - Composing Suspending Functions</a></li></ul><br>]]></content:encoded>
      
      
      <category domain="https://d2fault.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://d2fault.github.io/categories/Programming/Android/">Android</category>
      
      
      <category domain="https://d2fault.github.io/tags/kotlin/">kotlin</category>
      
      <category domain="https://d2fault.github.io/tags/coroutine/">coroutine</category>
      
      <category domain="https://d2fault.github.io/tags/android/">android</category>
      
      
      <comments>https://d2fault.github.io/2021/02/19/20210219-coroutine-composing-suspending-functions/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Kotlin] 코루틴(Coroutine) Cancellation and Timeouts</title>
      <link>https://d2fault.github.io/2021/01/18/20210114-coroutine-cancellation-and-timeouts/</link>
      <guid>https://d2fault.github.io/2021/01/18/20210114-coroutine-cancellation-and-timeouts/</guid>
      <pubDate>Sun, 17 Jan 2021 16:45:51 GMT</pubDate>
      
      <description>Composing Suspending Functions 이번 포스팅에서는 코루틴의 일시 중단 함수를 조합하여 활용하는 방법을 알아본다.</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="cancellation-and-timeouts"><a class="markdownIt-Anchor" href="#cancellation-and-timeouts"></a> Cancellation and Timeouts</h1><p>이번 게시글에서는 코루틴의 취소와 timeout 처리에 대해 알아보자.</p><p>※ IntelliJ나 Android Studio가 설치되어 있지 않다면 Kotlin 공식 사이트에서 지원하는 <mark><strong>온라인 IDE(<a href="https://play.kotlinlang.org/">Kotlin Playground</a>)를 사용하여 아래 코드를 실행할 수 있다.</strong></mark></p><br><h2 id="cancelling-coroutine-execution"><a class="markdownIt-Anchor" href="#cancelling-coroutine-execution"></a> Cancelling coroutine execution</h2><p><code>launch</code> 에서 반환되는  <code>job</code> 객체는 코루틴을 취소할 수 있는 기능을 제공해 준다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;job: I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// delay a bit</span></span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancel() <span class="comment">// cancels the job</span></span><br><span class="line">    job.join() <span class="comment">// waits for job&#x27;s completion </span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>job.cancel()</code> 을 이용하여 실행 중인 <code>job</code> 을 취소할 수 있다.</p><br><h2 id="cancellation-is-cooperative"><a class="markdownIt-Anchor" href="#cancellation-is-cooperative"></a> Cancellation is cooperative</h2><p>코루틴이 취소되기 위해서는 일종의 조건이 필요하다. <s>그래서 협력적(cooperative)이라는 단어를 사용한 듯하다.</s></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123; <span class="comment">// computation loop, just wastes CPU</span></span><br><span class="line">            <span class="comment">// print a message twice a second</span></span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">                nextPrintTime += <span class="number">500L</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// delay a bit</span></span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// cancels the job and waits for its completion</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>얼핏 보기에는 위의 코드가 정상적으로 취소될 것 같지만 실제 돌려보면 취소가 되지 않는 것을 볼 수 있다. <strong>코루틴을 취소하려면 해당 코루틴에 suspend 함수가 포함되어야 하는데</strong> 위의 <code>launch</code> 안에는 어떠한 suspend 함수도 포함되지 않았기에 원하는 결과가 나오지 않은 것이다.</p><p>위의 코드를 취소 가능한 코드로 만드려면 어떻게 해야 할까? 이전 포스팅에 정리했던 대표적인 suspend 함수, <code>delay</code> 를 호출하면 된다. <code>if</code> 문 안에 살짝 추가해 보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                <span class="comment">// 이곳에 delay를 추가했다.</span></span><br><span class="line">                delay(<span class="number">1L</span>)</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">                nextPrintTime += <span class="number">500L</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>)</span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>delay()</code> 하나 추가했을 뿐인데 아주 정상적으로 종료된다.</p><br><h2 id="making-computation-code-cancellable"><a class="markdownIt-Anchor" href="#making-computation-code-cancellable"></a> Making computation code cancellable</h2><h3 id="1-suspend-함수를-주기적으로-호출"><a class="markdownIt-Anchor" href="#1-suspend-함수를-주기적으로-호출"></a> 1. Suspend 함수를 주기적으로 호출</h3><p>공식적으로 cancellable한 코드로 만드는 방법 두 가지 중 첫 번째 방법이다. 바로 <code>yield</code>! <strong><code>yield</code>를 사용하면 일시중지 및 재개시 exception까지 처리할 수 있다.</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="comment">// try-catch로 error message를 출력</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                    <span class="comment">// 이곳에 yield를 추가했다.</span></span><br><span class="line">                    yield()</span><br><span class="line">                    println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">                    nextPrintTime += <span class="number">500L</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            kotlin.io.println(<span class="string">&quot;Exception [<span class="variable">$e</span>]&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>)</span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="2-명시적으로-상태isactive를-체크하여-코루틴-취소"><a class="markdownIt-Anchor" href="#2-명시적으로-상태isactive를-체크하여-코루틴-취소"></a> 2. 명시적으로 상태(<code>isActive</code>)를 체크하여 코루틴 취소</h3><p><code>cancel</code> 요청이 들어오면 <code>isActive</code> 상태가 <code>false</code> 로 변경되어 <code>while</code> 문에서 탈출할 수 있다! 아래 코드로 확인하자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (isActive) &#123; <span class="comment">// cancellable computation loop</span></span><br><span class="line">            <span class="comment">// print a message twice a second</span></span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">                nextPrintTime += <span class="number">500L</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// delay a bit</span></span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// cancels the job and waits for its completion</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isActive</code> 를 사용하여 취소될 경우, <code>yield</code>와 다르게 <code>exception</code> 을 던지지 않는다는 차이가 있다.</p><br><h2 id="closing-resources-with-finally"><a class="markdownIt-Anchor" href="#closing-resources-with-finally"></a> Closing resources with finally</h2><p>코루틴 종료시 리소스를 어떻게 해제할 수 있는지 알아보는 예제이다. 서버와 통신하거나, DB를 사용할 때 갑자기 코루틴이 종료된다면 해당 리소스를 닫아 주어야 하는데, 이번 예제를 통해 그 방법을 배울 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">                delay(<span class="number">500L</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// finally에서 해제해 주면 됨!</span></span><br><span class="line">            println(<span class="string">&quot;job: I&#x27;m running finally&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// delay a bit</span></span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// cancels the job and waits for its completion</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>finally</code> 블록 안에 리소스 처리 코드를 작성해 주면 된다.</p><br><h2 id="run-non-cancellable-block"><a class="markdownIt-Anchor" href="#run-non-cancellable-block"></a> Run non-cancellable block</h2><p>이미 cancel된 코루틴 안에서 또 코루틴을 호출하여 종료해야 하는 특수 케이스의 예이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">                delay(<span class="number">500L</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// withContext에 NonCancellable을 전달</span></span><br><span class="line">            withContext(NonCancellable) &#123;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m running finally&quot;</span>)</span><br><span class="line">                delay(<span class="number">1000L</span>)</span><br><span class="line">                println(<span class="string">&quot;job: And I&#x27;ve just delayed for 1 sec because I&#x27;m non-cancellable&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// delay a bit</span></span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// cancels the job and waits for its completion</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IDE에서 실행해 보면 종료된 코루틴 안에 코루틴이 돌아서 해당 코루틴이 종료되기 전까지 main 함수가 종료되지 않는 것을 확인할 수 있다. <s>&quot;아직 잠깐 기다려!!! 나 일 하나만 더 하고!!!&quot;의 느낌을 받았다.</s></p><br><h2 id="withtimeout"><a class="markdownIt-Anchor" href="#withtimeout"></a> withTimeout</h2><p>코루틴을 실행할 때 특정 시간이 지나면 이 코루틴은 취소된다! 라고 timeout을 지정하는 방식이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    withTimeout(<span class="number">1300L</span>) &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제에서는 1.3초 이후 timeout으로 인해 작업이 중단되지만, <code>runBlocking</code> 으로 내부에서 실행했기 때문에 exception이 발생한다. 이 exception을 해결할 수 있는 키워드를 다음 예제에서 소개한다.</p><br><h2 id="withtimeoutornull"><a class="markdownIt-Anchor" href="#withtimeoutornull"></a> withTimeoutOrNull</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> result = withTimeoutOrNull(<span class="number">1300L</span>) &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">&quot;Done&quot;</span> <span class="comment">// will get cancelled before it produces this result</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Result is <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드를 실행해 보면 <code>Result is null</code> 이 출력될 것이다.</p><br><h2 id="asynchronous-timeout-and-resources"><a class="markdownIt-Anchor" href="#asynchronous-timeout-and-resources"></a> Asynchronous timeout and resources</h2><p><code>withTimeout</code> 은 해당 블록에서 실행 중인 코드에 대해 비동기로 처리되며, 내부 블록이 반환되기 직전 어디에서든 발생할 수 있다. 블록 내부에서 수정 중인 리소스를 외부에서 사용할 경우 이를 염두하여 코드를 작성해야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> acquired = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span> &#123; acquired++ &#125; <span class="comment">// Acquire the resource</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123; acquired-- &#125; <span class="comment">// Release the resource</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        repeat(<span class="number">100_000</span>) &#123; <span class="comment">// Launch 100K coroutines</span></span><br><span class="line">            launch &#123; </span><br><span class="line">                <span class="keyword">val</span> resource = withTimeout(<span class="number">60</span>) &#123; <span class="comment">// Timeout of 60 ms</span></span><br><span class="line">                    delay(<span class="number">50</span>) <span class="comment">// Delay for 50 ms</span></span><br><span class="line">                    Resource() <span class="comment">// Acquire a resource and return it from withTimeout block     </span></span><br><span class="line">                &#125;</span><br><span class="line">                resource.close() <span class="comment">// Release the resource</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Outside of runBlocking all coroutines have completed</span></span><br><span class="line">    println(acquired) <span class="comment">// Print the number of resources still acquired</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>컴퓨터 상황이나 사양에 따라 위 코드 결과가 0이 될 수도, 0이 아닐 수도 있다. 그러나 실제로 이 코드에서 0이 아닌 값을 보기 위해서는 예제의 시간을 조정해야 할 것이다.</p><p>이 문제를 해결하기 위해 <code>withTimeout</code> 블록에서 return하는 것과 반대로 리소스에 대한 참조를 변수에 저장해둘 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> acquired = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span> &#123; acquired++ &#125; <span class="comment">// Acquire the resource</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123; acquired-- &#125; <span class="comment">// Release the resource</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        repeat(<span class="number">100_000</span>) &#123; <span class="comment">// Launch 100K coroutines</span></span><br><span class="line">            launch &#123; </span><br><span class="line">                <span class="keyword">var</span> resource: Resource? = <span class="literal">null</span> <span class="comment">// Not acquired yet</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    withTimeout(<span class="number">60</span>) &#123; <span class="comment">// Timeout of 60 ms</span></span><br><span class="line">                        delay(<span class="number">50</span>) <span class="comment">// Delay for 50 ms</span></span><br><span class="line">                        resource = Resource() <span class="comment">// Store a resource to the variable if acquired      </span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// We can do something else with the resource here</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">                    resource?.close() <span class="comment">// Release the resource if it was acquired</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Outside of runBlocking all coroutines have completed</span></span><br><span class="line">    println(acquired) <span class="comment">// Print the number of resources still acquired</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 항상 0을 반환한다.</p><p>좀 쉽게 풀어서 쓰자면, 외부 리소스를 코루틴 안에서 사용할 때</p><ol><li>리소스 참조 변수를 선언</li><li><code>finally</code> 에서 리소스 해제</li></ol><p>이 두 가지를 기억하면 좋을 것이다.</p><br><h1 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h1><ul><li><a href="https://kotlinlang.org/docs/reference/coroutines/cancellation-and-timeouts.html">코루틴 공식 문서 - Cancellation and Timeouts</a></li><li><a href="https://youtu.be/GmVv98LUa0k">새차원의 코틀린 코루틴 강좌 #3 - Cancellation and Timeouts</a></li></ul><br>]]></content:encoded>
      
      
      <category domain="https://d2fault.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://d2fault.github.io/categories/Programming/Android/">Android</category>
      
      
      <category domain="https://d2fault.github.io/tags/kotlin/">kotlin</category>
      
      <category domain="https://d2fault.github.io/tags/coroutine/">coroutine</category>
      
      <category domain="https://d2fault.github.io/tags/android/">android</category>
      
      
      <comments>https://d2fault.github.io/2021/01/18/20210114-coroutine-cancellation-and-timeouts/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Kotlin] 코루틴(Coroutine) 기본 개념 이해하기</title>
      <link>https://d2fault.github.io/2021/01/13/20210113-coroutine-basic/</link>
      <guid>https://d2fault.github.io/2021/01/13/20210113-coroutine-basic/</guid>
      <pubDate>Wed, 13 Jan 2021 13:39:41 GMT</pubDate>
      
      <description>Coroutine? 루틴의 일종으로, 협동 루틴으로 이해하면 쉽다. 코루틴의 &quot;Co&quot;는 with, together를 뜻한다. 코루틴은 자신의 실행이 마지막으로 중단된 지점 다음의 포인트부터 동작을 재개한다. 즉, 순차 실행이 가능하다.</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="coroutine"><a class="markdownIt-Anchor" href="#coroutine"></a> Coroutine?</h1><ul><li><p>루틴의 일종으로, 협동 루틴으로 이해하면 쉽다.</p></li><li><p>코루틴의 &quot;Co&quot;는 with, together를 뜻한다.</p></li><li><p>코루틴은 자신의 실행이 마지막으로 중단된 지점 다음의 포인트부터 동작을 재개한다. <strong>즉, 순차 실행이 가능하다.</strong></p></li><li><p><s>(tmi) 코루틴 최초의 출판물은 1963년에 등장했다.</s></p></li><li><p>러닝 커브는 다음 그림 참고(<a href="https://twitter.com/akarnokd/status/979732723152687106?s=20">출처 바로가기</a>)</p><p><img src="/images/20210113-coroutine_basic/1.jpg" alt="들어올 땐 쉽지만......?" /></p></li></ul><p>※ IntelliJ나 Android Studio가 설치되어 있지 않다면 Kotlin 공식 사이트에서 지원하는 <mark><strong>온라인 IDE(<a href="https://play.kotlinlang.org/">Kotlin Playground</a>)를 사용하여 아래 코드를 실행할 수 있다.</strong></mark></p><br><h2 id="your-first-coroutine"><a class="markdownIt-Anchor" href="#your-first-coroutine"></a> Your First Coroutine</h2><p>아래 코드를 실행하면,</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">// launch a new coroutine in background and continue</span></span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// non-blocking delay for 1 second (default time unit is ms)</span></span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>) <span class="comment">// print after delay</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>) <span class="comment">// main thread continues while coroutine is delayed</span></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>) <span class="comment">// block main thread for 2 seconds to keep JVM alive</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Would!Hello,</code> 가 출력될까?</p><p>예상했겠지만, 당연히 답이 아니다. <code>main()</code> 이 실행되고, <code>GlobalScope.launch</code> 에서 1초의 딜레이가 걸린다. 이때 <strong>딜레이는 <code>GlobalScope.launch</code> 에만 영향을 주기에 <code>main()</code> 의 코드는 그대로 실행되며,</strong> <s>우리 모두가 아는</s> <code>Hello,World!</code> 의 출력을 확인할 수 있다.</p><p>정확히는 <code>Hello,</code> 출력 후 1초의 딜레이, 그리고 <code>World!</code> 출력 후 1초 딜레이 이후 해당 프로그램이 종료될 것이다.</p><br><h3 id="정리"><a class="markdownIt-Anchor" href="#정리"></a> 정리</h3><ul><li>코루틴은 가벼운 스레드의 일종으로 볼 수 있다.</li><li>coroutine builder인 <code>launch</code> 를 이용하여 코루틴을 생성할 수 있다.</li><li><code>launch</code> 를 사용하기 위해서는 CoroutineScope인 GlobalScope를 사용해야 한다.</li><li><code>GlobalScope.launch &#123;&#125;</code> 는 <code>therad &#123;&#125;</code> 로 변환될 수 있다.</li></ul><br><h2 id="bridging-blocking-and-non-blocking-worlds"><a class="markdownIt-Anchor" href="#bridging-blocking-and-non-blocking-worlds"></a> Bridging blocking and non-blocking worlds</h2><p><code>Thread.sleep(2000L)</code> 로 끝난 코드를 <code>runBlocking</code> 으로 바꿔보는 예제이다. 이전에, <code>delay</code> 와 <code>sleep</code> 의 차이를 짚고 넘어가자.</p><ul><li><code>delay</code><ul><li>일시 중단되는(suspend) 함수</li></ul></li><li><code>sleep</code><ul><li>thread를 blocking하는 함수</li></ul></li></ul><p>즉, 이번 예제의 목표는 <code>main()</code> 함수에서 suspend 함수 사용법을 배우는 것이다. 아래 코드를 참고하자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">// launch a new coroutine in background and continue</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>) <span class="comment">// main thread continues here immediately</span></span><br><span class="line">    runBlocking &#123;     <span class="comment">// but this expression blocks the main thread</span></span><br><span class="line">        delay(<span class="number">2000L</span>)  <span class="comment">// ... while we delay for 2 seconds to keep JVM alive</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runBlocking</code> 을 사용하면 blocking하는 코루틴을 생성할 수 있다.</p><br><h3 id="정리-2"><a class="markdownIt-Anchor" href="#정리-2"></a> 정리</h3><ul><li>코루틴 빌더인 <code>runBlocking</code> 을 사용하면 내부 코루틴이 완료될 때까지 메인 스레드가 blocking되어 프로그램이 중단되지 않는다.</li></ul><br><h3 id="코드를-조금-더-깔끔하게-작성할-수는-없을까"><a class="markdownIt-Anchor" href="#코드를-조금-더-깔끔하게-작성할-수는-없을까"></a> 코드를 조금 더 깔끔하게 작성할 수는 없을까?</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">// launch a new coroutine in background and continue</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>) <span class="comment">// main coroutine continues here immediately</span></span><br><span class="line">    delay(<span class="number">2000L</span>)      <span class="comment">// delaying for 2 seconds to keep JVM alive</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main()</code> 함수를 <code>runBlocking</code> 으로 감싸서 전체 flow가 완료되기 전까지 종료되지 않는 코드로 변신!</p><br><h2 id="waiting-for-a-job"><a class="markdownIt-Anchor" href="#waiting-for-a-job"></a> Waiting for a job</h2><p><code>delay</code> 없이 비동기 작업을 깔끔하기 처리하기 위해서는 <code>job</code> 객체에 <code>join()</code> 하는 방법이 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// launch로 코루틴을 생성하면 job 객체를 반환한다.</span></span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>)</span><br><span class="line">    <span class="comment">// job에 join을 하면 launch로 생성한 코루틴이 종료될 때까지 기다렸다가 프로그램을 종료한다.</span></span><br><span class="line">    job.join() <span class="comment">// wait until child coroutine completes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드를 보고 ‘그럼 runBlocking은 불필요한 것 아닌가?’ 하는 생각이 들어 코드를 지우고 실행하니 정상적으로 동작하지 않았다. <mark><strong><code>join()</code><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 은 suspend function으로, 코루틴 내부나 다른 suspend function에서만 실행할 수 있다! 잊지 말 것!</strong></mark></p><br><p>여기서 잠깐! 그럼 <code>main</code> 에  <code>job</code> 을 100개 가지는 코루틴은 <code>job</code> 마다 <code>join</code> 을 전부 해 줘야 하는 걸까? <s>호엥? 너무 비효율적이잖아?</s></p><br><h2 id="structured-concurrency"><a class="markdownIt-Anchor" href="#structured-concurrency"></a> Structured concurrency</h2><p>그래서 코루틴에서는 이런 비효율을 개선하기 위해 <code>runBlocking</code> 과 <code>launch</code> 의 관계성을 확립하는 구조를 제안한다. 코드를 보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// this: CoroutineScope, this 생략 가능</span></span><br><span class="line">    <span class="keyword">this</span>.launch &#123; <span class="comment">// launch a new coroutine in the scope of runBlocking</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GlobalScope</code> 에서 <code>launch</code> 하지 말고 <code>runBlocking</code> 에서 <code>launch</code> 로 코루틴을 생성하는 방법이다. 이렇게 생성할 경우 코루틴이 몇 개가 생성되든 <code>main</code> 함수는 해당 <code>job</code> 들이 모두 끝나기 전까지 프로그램을 종료하지 않는다.</p><br><h2 id="scope-builder"><a class="markdownIt-Anchor" href="#scope-builder"></a> Scope builder</h2><p>위와 비슷한 방법으로 <code>coroutineScope</code> 를 이용해서 범위를 선언할 수도 있다. 코루틴 범위를 만들고 그 안에서 만들어진 모든 자식 코루틴이 완료되기 전까지 끝나지 않는 방식이다. 언뜻 보면 structured concurrency와 비슷해 보이지만 차이점이 있다.</p><ul><li><code>runBlocking</code><ul><li>대기하기 위해 현재 스레드를 차단한다.</li></ul></li><li><code>coroutineScope</code><ul><li>다른 용도로 사용하기 위해 기본 스레드 상태를 해제한다.</li></ul></li></ul><p>아래 코드 실행 순서를 눈여겨보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123; </span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        println(<span class="string">&quot;1. Task from runBlocking&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    coroutineScope &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">500L</span>) </span><br><span class="line">            println(<span class="string">&quot;2. Task from nested launch&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        println(<span class="string">&quot;3. Task from coroutine scope&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;4. Coroutine scope is over&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>편의를 위해 문장에 번호를 추가했다. 어떤 순서로 실행될까? 이 코드를 처음 봤을 때 4-3-1-2 순서<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>로 실행된다고 생각했지만 정답이 아니었다. 위의 코드는 3-1-2-4 순서로 실행된다. <strong>즉, <code>coroutineScope</code> 가 완료되지 않은 상태에서도 <code>3. Task from coroutine scope</code> 바로 뒤에 <code>1. Task from runBlocking</code> 이 실행됨을 알 수 있다.</strong></p><br><h3 id="정리-3"><a class="markdownIt-Anchor" href="#정리-3"></a> 정리</h3><ul><li><code>delay</code> 대신 <code>job.join()</code> 을 이용하면 비동기 작업이 깔끔해진다.</li><li><code>join()</code> 은 코루틴 내부나 다른 suspend function에서만 실행할 수 있다.</li><li><code>join()</code> 오조 오억 개 쓰기 싫으면 <code>structured concurrency</code> 사용해라.</li><li><code>runBlocking</code> 은 대기하기 위해 현재 스레드를 차단(<code>coroutineScope</code> 의 플로우가 모두 실행되기 전까지 4번 문장을 출력하지 않음)한다.</li><li><code>coroutineScope</code> 는 다른 스레드를 실행하기 위해 현재 스레드를 suspend한다. 즉, 코루틴을 생성한 최상위 함수가 동일한 스레드에서 계속 실행될 수 있다.</li></ul><br><h2 id="extract-function-refactoring"><a class="markdownIt-Anchor" href="#extract-function-refactoring"></a> Extract function refactoring</h2><p>코루틴 내부에서 호출할 함수에 <code>delay</code> 등의 <code>suspend</code> 함수를 사용하고 싶다면 다음 코드를 주목하자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123; doWorld() &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is your first suspending function</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="정리-4"><a class="markdownIt-Anchor" href="#정리-4"></a> 정리</h3><ul><li>일반 함수를 suspend 함수로 바꾸고 싶다면 <code>suspend</code> 를 붙이면 된다. <s>(심플)</s></li></ul><br><h2 id="global-coroutines-are-like-daemon-threads"><a class="markdownIt-Anchor" href="#global-coroutines-are-like-daemon-threads"></a> Global coroutines are like daemon threads</h2><p>코루틴이 계속 실행되고 있다고 해서 스레드가 실행 중이라고 볼 수 없다. 프로세스가 살아 있을 때에만 동작할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// just quit after delay</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드를 실행시켜 보면 1.3초 이후에는 <code>main</code> 함수가 종료되고, 이와 동시에 <code>repeat()</code> 도 멈추는 것을 확인할 수 있다. 즉, <strong>메인 프로세스가 종료될 경우 그 안에 생성된 코루틴의 동작 또한 모두 중지된다.</strong></p><br><h1 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h1><ul><li><a href="https://kotlinlang.org/docs/reference/coroutines/basics.html">코루틴 공식 문서 - Basics</a></li><li><a href="https://youtu.be/14AGUuh8Bp8">새차원의 코틀린 코루틴 강좌 #2 - basics</a></li><li><a href="https://stackoverflow.com/questions/53535977/coroutines-runblocking-vs-coroutinescope">stack overflow - runBlocking vs coroutineScope</a></li></ul><br><hr /><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>잊지 말자고는 했지만 사실 에러 로그를 너무나도 명확하게 출력해 준다. <code>Suspend function 'join' should be called only from a coroutine or another suspend function</code> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><code>coroutiuneScope</code> 를 <code>launch</code> 로 바꿀 경우 4-3-1-2 순서로 실행된다. <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://d2fault.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://d2fault.github.io/categories/Programming/Android/">Android</category>
      
      
      <category domain="https://d2fault.github.io/tags/kotlin/">kotlin</category>
      
      <category domain="https://d2fault.github.io/tags/coroutine/">coroutine</category>
      
      <category domain="https://d2fault.github.io/tags/android/">android</category>
      
      
      <comments>https://d2fault.github.io/2021/01/13/20210113-coroutine-basic/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Diary] 2020년 회고하기</title>
      <link>https://d2fault.github.io/2020/12/31/20201231-diary/</link>
      <guid>https://d2fault.github.io/2020/12/31/20201231-diary/</guid>
      <pubDate>Thu, 31 Dec 2020 13:36:42 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;회고-전-반성&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#회고-전-반성&quot;&gt;&lt;/a&gt; 회고 전 반성&lt;/h1&gt;
&lt;p&gt;늦었다. 그것도 아주 많이. 이 회고는 분명 작년 12월 31일 이전에 작성&lt;sup class=&quot;foo</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="회고-전-반성"><a class="markdownIt-Anchor" href="#회고-전-반성"></a> 회고 전 반성</h1><p>늦었다. 그것도 아주 많이. 이 회고는 분명 작년 12월 31일 이전에 작성<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>되어야만 했다. 여느 때와 마찬가지인 여유로운 연말이었으나 아무것도 하지 못했다. <mark>블로그 리뉴얼, 그리고 회고로 마무리하는 2020년!</mark> 계획만큼은 완벽했는데.</p><p>내 연말 루틴<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>을 박살 낸 코로나 핑계를 대고 싶지만 <s>(응, 아니야~ 너 데스크톱 사서 메이플스토리만 했어…)</s>  왠지 모르게 마음 한쪽이 콕콕 쑤시는 게, 하자면 할 수 있는 상황이었음을 잘 알기 때문일 거야.</p><p>반성합니다. <strong>2021년 연말은 절대, 네버, 이렇게 <s>(이따위로)</s> 보내지 않겠습니다.</strong></p><br><h1 id="2019년-회고-살펴보기"><a class="markdownIt-Anchor" href="#2019년-회고-살펴보기"></a> 2019년 회고 살펴보기</h1><p>야망이 넘치는 모습을 <a href="https://d2fault.github.io/2019/12/31/20191231-diary/">2019년 회고</a>에서 찾아볼 수 있었다.</p><blockquote><p>내년의 곡은 <strong>오마이걸의 게릴라(Guerilla)</strong>! 때를 기다리고 덮칠 거야!!! PO야망WER!!!</p></blockquote><div class="video-container"><iframe src="https://www.youtube.com/embed/wVMeNl4UfIE" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>갑자기 그때의 내가 떠오른다. 어떤 사건 때문에 야망을 품을 수밖에 없었는데, 힘듦을 추진력으로 잘 써먹었다고 생각한다. 충분히 칭찬할 일이야!</p><br><h1 id="2020-혼돈의-카오스"><a class="markdownIt-Anchor" href="#2020-혼돈의-카오스"></a> 2020: 혼돈의 카오스</h1><p>넘치는 야망으로 해결할 수 없는 크리티컬한 문제가 있었다. 이름하여 COVID-19. 2020년은 코로나를 빼곤 설명할 수 없다. 어색하던 마스크는 필수가 되었고, 마스크 없이 살던 삶은 까마득해졌다. 나란 사람 청개구리 심보 가득한 집순이. 강제 집콕은 행복했지만, 너무 괴로웠다. <mark><strong>재택근무 좋아요, 강제 집콕 싫어요.</strong></mark></p><br><h2 id="그래도-포기할-수-없어-매시업"><a class="markdownIt-Anchor" href="#그래도-포기할-수-없어-매시업"></a> 그래도 포기할 수 없어, 매시업</h2><p>문을 두드릴 여유와 용기가 없어서 생각만 삼 년을 했다. 그런데 더는 실력 없이 고여가는 내 모습을 두고볼 수 없었다. 행동하지 않으면 끝일 것만 같은 불안함이 나를 움직였다. 결단과 행동이 늘 좋은 결과로 나타나는 것은 아니지만 운이 따랐나 보다. 그렇게 매시업은 봄과 함께 찾아왔다.</p><h3 id="말로만-하던-코틀린을-드디어"><a class="markdownIt-Anchor" href="#말로만-하던-코틀린을-드디어"></a> 말로만 하던 코틀린을 드디어?</h3><p>맛만 봤다. 코틀린 인 액션 책을 보긴 했는데, 그리고 예제를 만들긴 했는데 세상이 바뀌어도 너무 바뀌었다. 안드로이드를 잠깐 놓은 동안, 단말 종속성이 있고 뷰가 없는 안드로이드 개발을 하는 동안 천지개벽이 일어났네? 겁이 났다. ‘시작은 했는데 잘할 수 있을까?’ 총체적 난국이라는 말은 이럴 때 쓰는 건가 봐.</p><h3 id="사실-코틀린만의-문제는-아냐"><a class="markdownIt-Anchor" href="#사실-코틀린만의-문제는-아냐"></a> 사실 코틀린만의 문제는 아냐</h3><p>헤헤, 라떼는 분명 MVC만 썼던 것 같은데 뭐가 이렇게 많지요? <s>(ㅋㅎㅋㅎㅋㅎ)</s> MVP, MVVM, MVI요? Data Binding에, rxjava나 coroutine 그리고 koin과 hilt 모두 처음인데다가, room도 안 쓰고 있었으니 말 다했지. 사실 아직도 잘 모른다. 많은 것을 쥐고 싶었는데 이렇다할 결과는 아직이다.</p><p>난 습득과 적용이 빠른 사람은 아니다. 이번 고비를 넘기기까지 많은 시간이 필요하겠지만, 그래도 <strong>처음보다 지금이 낫다면 성공한 거 아냐?</strong> 이 합리화는 남들보다 느린 나를 위로하는 나만의 방식이다.</p><h3 id="ios요-제가요"><a class="markdownIt-Anchor" href="#ios요-제가요"></a> iOS요? 제가요?</h3><p>네, 제가요. 드디어 입문했네요.</p><p>거창한 목표로 시작한 건 아니었다. 맥북 유저로 늘 ‘맥북도 쓰는데 언젠가 iOS 개발 한번 해야지!’ 라고 생각하던 중 좋은 기회가 왔달까. 비대면으로 시작해서 대면으로 끝났던, 그래서 더 좋았던 스터디. 이 스터디를 처음부터 끝까지 열정적으로 이끌어준 <strong>친구에게 진심으로 감사하다. 그 친구의 칭찬과 작은 성취로 바닥을 기던 자신감을 조금은 회복했으니까.</strong></p><p>아이러니하게도 iOS 스터디 내내 안드로이드를 처음 시작한 그때가 떠올랐다. 개발이 재미있어서 나를 새벽까지 몰아세우는 게 너무 오랜만이었기 때문이겠지.</p><h3 id="아쉬움이-남는-첫-해커톤-tich"><a class="markdownIt-Anchor" href="#아쉬움이-남는-첫-해커톤-tich"></a> 아쉬움이 남는 첫 해커톤, TICH</h3><p>해커톤이 끝나고 쓴 회고를 보면,</p><p><img src="/images/20201231-diary/1.jpg" alt="" /></p><p>팀이 아닌 내가 문제였다는 결론에 이른다. 빈 부분이 어딘지 알았으니까 조금씩 채워가면 된다고 해 줘! (ㅠㅠ)</p><h3 id="온라인으로요-이것까지요"><a class="markdownIt-Anchor" href="#온라인으로요-이것까지요"></a> 온라인으로요? 이것까지요?</h3><p>온라인 모각작, 온라인 스터디, 랜선 회식 등 온라인으로 할 수 있는 모든 것을 매시업과 함께하며 집 밖을 나가지 않으면 생산적인 일을 하지 못하던 <s>(하더라도 아주 드문)</s> 내가 바뀌었다. 진절머리나는 코로나가 준 유일한 이점은 비대면으로 이동 시간이 줄고, 온라인으로 무언가를 함께하는 게 자연스러워졌다는 거 아닐까. 비대면이 익숙해지는 요즈음, 상상 속 미래에 사는 기분이다.</p><br><h2 id="재미있는데-재미없어-재미가-없는데-있어-data"><a class="markdownIt-Anchor" href="#재미있는데-재미없어-재미가-없는데-있어-data"></a> 재미있는데 재미없어 재미가 없는데 있어: Data</h2><p>2월부터 시작된 데이터 분석은 정체성 혼란을 야기했다. 머리를 쥐어짜도 안 나오는 쿼리로 괴로움에 허우적댔고, gephi라는 비주얼라이징 툴도 사용해 봤다. 그래도 어찌저찌 나름 의미 있는 분석 결과과 나와서 천만다행이었다. 덕분에 다섯 번의 발표를 진행한 건 함정. <mark><strong>폭풍 칭찬 들은 건 안 함정!!!</strong></mark></p><p>그런데 왜 ADSP 시험은 떨어졌을까! 공부 안 하고 떨어진 거면 억울하지나 않지! 억지로 공부한다고 주말을 헌납했는데 공부 방법이 잘못됐었다. 단원 끝에 있는 문제가 아닌 맨 뒤에 포함된 기출문제를 풀었어야 했는데 그거 빼고 다 푼 거 실화냐. 어쨌거나 <strong>자격증 공부는 너무너무 싫다. 재미가 하나도 없어.</strong></p><p>어찌저찌 AI 관련 사내 자격증을 땄고, 또 어찌저찌 텐서플로우 입문까진 했다. 잠깐 놓았더니 다 까먹은 건 비밀이긴 한데, 적어놓고 보니 1년 내내 데이터와 싸웠다는 사실은 명백하네. 해야 해서 한 일이지만 의미가 있는 일이라 좋았다. 의미 없는 해야만 하는 일보다 백 배 천 배는 나으니까!</p><br><h2 id="문화생활-0-0-0-0"><a class="markdownIt-Anchor" href="#문화생활-0-0-0-0"></a> 문화생활? 0, 0, 0, 0</h2><p>뮤지컬 0회, 연극 0회, 콘서트 0회, 페스티벌 0회에 빛나는 2020. 뮤지컬은 정말 가고 싶었는데 썸씽로튼 예매까지 다 하고 취소하길 몇 번, 결국 코로나가 마음에 걸려서 못 갔다. 온라인 콘서트는 고민만 하다가 drop. 콘서트는 역시 스탠딩이지. 직접 가서 부딪히는 맛으로 가는 건데 이게 뭐냐고. 하긴, 영화관도 거의 못 갔는데 다른 문화를 즐길 수 있었을리가 없다.</p><br><h2 id="그래도-꾸준했던-취미"><a class="markdownIt-Anchor" href="#그래도-꾸준했던-취미"></a> 그래도 꾸준했던 취미</h2><p>취미 없이 행복할 수 없는 사람이다. 코로나가 득실대도 숨구멍을 포기할 순 없지! 밖에서 즐기는 문화생활 대신, 집에서 안전하게 즐길 수 있는 것들 위주로 지속했다. 그중 대표적인 취미는 독서!</p><p><img src="/images/20201231-diary/2.jpg" alt="" /></p><p><a href="https://www.notion.so/d2fault/b1054a7be51c4c43820669eab885eef5?v=a8f9099e228a49c0993043d66f1b603b">Notion에 읽은 책을 정리</a>하기 시작했다. 읽을 때 와장창 읽는 건 기분 탓인 줄 알았는데 표로 확인하니 기분이 이상하네. 그래도 어떻게 일 년에 무려 35권의 책을 완독했다! 요새 내 문장력과 단어 수준이 떨어지는 걸 느껴서 의도적으로 소설을 많이 읽으려 한다.</p><p>여전히 노래도 열심히 부른다. 정말 많이 늘었다. 시간 투자 대비 아웃풋이 나쁘지 않아서 뿌듯하다. 많은 사람들 앞에서 부르기엔 부족함이 많지만 취미로 부르는 거니까 괜찮아! Garageband를 이용해서 해본 녹음도 너무 재미있었다. <s>(사흘 가지고 놀았다. ㅋㅋ)</s></p><p>2월부터 하려고 했던 운동은 6월이 되어서야 시작했다. 코로나 무서워서 미루기엔 영영 못할 것 같아서 눈 딱 감고 질렀다. 효과는 뛰어났다! 힘이 없던 손가락과 팔에 힘이 생겼고, 체력이 조금씩 늘기 시작했다. 체력이 느니 여유가 생겼고, 여유가 생기니 퇴근 이후의 삶이 풍요로워졌다. 그리고 가장 큰 변화! 운동한 게 아까워서 좋아하는 술을 다 참는다. 그래도 술 좋아!</p><p>처음이자 마지막이 된 차박도 있었다. 난 차박에 늘 진심이었다고! 마침 스트레스가 극에 달한 상태여서 행동했다. 밤에 보는 한강이 그렇게 좋은 줄 몰랐지. 기회가 되면 또 가려고 한다. 새벽에 비가 와서 우중 차박까지 경험해서 더 더 행복했다. 사실 차박보다 당일치기 여행을 더 자주 다녔다. 운전도 취미가 돼서 행복하다. 포천, 속초, 주문진, 인천, 청주 등 최대한 사람들과 마주치지 않는 선에서 안전하게 즐기고 돌아왔다.</p> <br><h1 id="2020-어워즈"><a class="markdownIt-Anchor" href="#2020-어워즈"></a> 2020 어워즈</h1><ul><li>올해의 명반<ul><li><code>스텔라장-STELLA I</code></li></ul></li><li>질리지 않는 띵곡<ul><li><code>정세운-온도차</code></li><li><code>비투비-My Lady</code></li></ul></li><li>기억에 남는 영화<ul><li><code>삼진그룹 토익반</code></li></ul></li><li>기분 좋았던 책<ul><li><code>달러구트 꿈 백화점</code></li></ul></li><li>Best of best 책<ul><li><code>여자의 독서</code></li><li><code>역사의 쓸모</code></li><li><code>사랑의 생애</code></li><li><code>을의 철학</code></li></ul></li></ul><h2 id="그리고"><a class="markdownIt-Anchor" href="#그리고"></a> 그리고</h2><p>진급했다. 연초에는 큰 생각 없었는데 평가 기간이 다가올수록 쫄렸던 그 기분 잊지 못한다. 진급이라 쓰고 누락 피하기라고 읽지만 나 하나를 위해 희생하고 도와준 사람들이 너무 많았음을 알기에 여전히 미안하고 감사하다. 한편으로는 걱정도 된다. 신입 때와 지금을 비교하면 크게 달라진 건 없는 것 같은데, 시간이 나를 대리로 만들었다. <mark><strong>조금 더 책임감 있는, 믿을 수 있는 사람이 되어야겠다.</strong></mark></p><br><h1 id="회고를-마무리하며"><a class="markdownIt-Anchor" href="#회고를-마무리하며"></a> 회고를 마무리하며</h1><p>매년 회고를 쓰면 작년 목표를 평가하는 재미를 느낄 수 있다.</p><blockquote><p>내년에 <strong>무조건 개발 동호회든 동아리든 스터디든 어디라도 들어갈 것</strong>이다. 강제성을 부여해서 올해보다 더 이룬 게 많은 해로 만들 것임. 그렇게 <strong>얻은 거 기록</strong>으로 남기는 건 덤. 몇 년째 적성 못 찾고 헤매는데, <strong>코틀린 이용한 안드로이드 개발 먼저 시작</strong>할 것이다. 언제까지 이대로 있을 순 없다. <strong>꾸준한 보컬 레슨</strong>과 <strong>한 달에 한 권 이상 책 읽고 필사</strong>하기도 잊을 수 없지.</p></blockquote><p>분명 2019보다 구체적인 목표라고 적혀 있었는데 어디가 구체적인 건지 잘 모르겠다. 개발 동아리 성공, 얻은 거 기록으로 남기기 실패, 코틀린 안드로이드 성공, 보컬 레슨 성공, 한 달에 한 권 이상 책 읽기 성공, 필사하기 실패. 총 4/6으로 <mark><strong>이룬 거 50% 넘었다!</strong></mark> 작년에 이루지 못했던 2019 목표도 일부 이뤄서<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> 신기하고 재미있다.</p><p>그럼 2021년 목표도 세워는 게 인지상정! 가장 먼저, 운동 놓지 않고 꾸준히 하기를 꼽고 싶다. 운동으로 얻은 이점이 많아. 잠깐 쉴 수는 있겠지만 그만두지 않았으면 한다. <strong>노래, 책, 운동</strong>은 올해도 안고 가는 걸로. 약간의 욕심을 부리자면 <strong>오토 트레이딩 시스템</strong>을 만들어 보고 싶기는 한데… <strong>블로그 리뉴얼</strong>을 먼저 끝내고 <strong>꾸준히 포스팅</strong>하는 게 우선이라고 봅니다. <strong>안드로이드 개발 실력</strong>은 지금보다 150% 올리고 싶습니다. <s>(주관적인 수치 주의)</s></p><p>어쨌거나 <s>(본론)</s>, 2021년은 사랑과 애정으로 따뜻함이 넘치는 한해가 되길 기도하며</p><div class="video-container"><iframe src="https://www.youtube.com/embed/0FQ1Fk1RYJc" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p><mark><strong>비투비포유의 Show your love</strong></mark> 을 새해 첫곡으로 선정했다.</p><blockquote><p>어둠이 내려 앞이 보이지 않아 길을 잃었어<br />이 세상은 왜 아름답기보단 아프기만 한지?<br />많은 사람이 넘어지고 많은 눈물이 넘쳐흘러<br />우린 필요해요 서로에게 힘이 돼야 해, oh</p><p>모두가 필요해 L-O-V-E<br />나도 알아 요새 많이 힘들었지 (I know)<br />귀 빌려줄 테니, 말해봐 문제가 뭔지<br />I’ll be here for you whenever you need (woo)</p><p>이제 말해줘 어렵지 않아, babe<br />사랑이란 말 아끼지 말고</p><p>Everybody singing “Show Your Love” (ooh-ooh)<br />Show your love (ooh-ooh)<br />사랑보다 더 큰 힘은 없어, 그것뿐이면 돼<br />Say your love (ooh-ooh), say your love (ooh-ooh)<br />사랑이 더 더 퍼지게 다시 웃을 수 있게</p><p>Just like a star, I’ll be by your side<br />어둠을 밝혀 내가 너의 빛이 되어 줄게 (yeah, yeah)<br />두려워하지 마 (eh) 거짓말 같은 이 밤도<br />모든 게 꿈처럼 희미해질 거야<br />서로 꼭 안아줘, show your love, I love ya (ay, eh)</p><p>이제 말해줘 어렵지 않아, babe<br />사랑이란 말 아끼지 말고</p><p>Everybody singing, “Show Your Love” (ooh-ooh)<br />Show your love (ooh-ooh)<br />사랑보다 더 큰 힘은 없어, 그것뿐이면 돼<br />Say your love (ooh-ooh), say your love (ooh-ooh)<br />사랑이 더 더 퍼지게 다시 웃을 수 있게</p><p>Two is better than one 'cause we’ll be stronger together<br />우린 사랑이 필요해, yeah, we need each other<br />힘들다고 약한 건 절대 아니니까<br />모두가 필요해 가끔 someone to lean on<br />You never know, know that life goes on<br />다시금 온 세상에 필 웃음꽃 love<br />소리 높여 노래 불러, 더 크게 소리 질러<br />온 세상에 닿도록 show your love</p><p>Everybody singing Show Your Love (ooh-ooh)<br />Show your love (ooh-ooh)<br />사랑보다 더 큰 힘은 없어, 그것뿐이면 돼<br />Say your love (ooh-ooh), say your love (ooh-ooh)<br />사랑이 더 더 퍼지게 다시 웃을 수 있게</p><p>La-la-la-la-la-la-la-la-la-la-la<br />La-la-la-la-la-la-la, love<br />La-la-la-la-la-la-la-la-la-la-la<br />La-la-la-la-la, 다시 웃을 수 있게</p></blockquote><p>사랑보다 더 큰 힘은 없대. 사랑하고 감사하며 살아가야지.</p><p>P.S. 회고 마무리까지 디스코드에서 함께 놀아준 <a href="https://black-jin0427.tistory.com/">black-jin</a>, MW, MJ 고맙습니다!</p><br><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>작성 일자만 살짝 바꿔서 올린 건 함정. 지금은 2021년 2월이다. 무려 2월이다. 2월, 2월, 2월!!! <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>카페에서 맥북과 함께 일년을 회고하며 보내는 것을 의미한다. 사람 구경도 하고, 유튜브도 좀 보고 그런 거… <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>운동 시작한 거! <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://d2fault.github.io/categories/Anything/">Anything</category>
      
      <category domain="https://d2fault.github.io/categories/Anything/Diary/">Diary</category>
      
      
      <category domain="https://d2fault.github.io/tags/%ED%9A%8C%EA%B3%A0/">회고</category>
      
      
      <comments>https://d2fault.github.io/2020/12/31/20201231-diary/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
