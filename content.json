{"meta":{"title":"잡동사니 수집광","subtitle":"Jiyoung's Somthing","description":"잡학다식을 꿈꾸는 공간","author":"Jiyoung(d2fault)","url":"https://d2fault.github.io","root":"/"},"pages":[{"title":"About","date":"2018-02-26T04:51:23.000Z","updated":"2021-03-04T05:31:57.852Z","comments":true,"path":"about/index.html","permalink":"https://d2fault.github.io/about/index.html","excerpt":"","text":"없는 건 잊어도, 가진 건 잊지 말자. 준 건 잊어도, 받은 건 잊지 말자. 지나칠 수 있는 사소한 것들을 잡아두는 공간. d2fault@naver.com https://github.com/d2fault"}],"posts":[{"title":"[Diary] 2023년 회고하기","slug":"20231231-diary","date":"2023-12-31T12:03:03.000Z","updated":"2024-01-14T05:44:24.035Z","comments":true,"path":"2023/12/31/20231231-diary/","permalink":"https://d2fault.github.io/2023/12/31/20231231-diary/","excerpt":"","text":"뭐라고 시작하는 게 좋을까 첫 곡이 먼저냐, 예언이 먼저냐의 고민이랄까. 물론 둘 다 정답임을 안다. 새해 첫 곡을 선정해 들은 지 어언 10년이 넘었는데 반년도 안 되어 그 의미를 깨달은 해는 처음이다. 처음 마주할 것들이 많으리라 예상되는 2023도 지지 않으며, 또 가끔 지며 다채롭게 채워 봐야지! 이 문장을 적을 땐 몰랐죠… 지금도 모르고 싶어요… 22년 11월, 정든 첫 회사를 떠나며 새로운 회사에서의 새출발을 응원하는 마음으로 선정한 김동률의 시작은 아주 멀리까지 가보고 싶어 그 곳에선 누구를 만날 수가 있을지 아주 높이까지 오르고 싶어 얼마나 더 먼 곳을 바라볼 수 있을지 (중략) 내가 자라고 정든 이 거리를 난 가끔 그리워하겠지만 이렇게 나는 떠나네 더 넓은 세상으로 또 다른 시작을 선물했다. 빙글빙글 돌아간 상반기 상황이 애매모호하게 돌아가고 있단 건 어렴풋이 느끼고 있었다. 그런 상황에서도 내가 할 수 있는 건 없기에 그저 주어진 것에 집중하려 노력했다. 제공하던 SDK 구조를 개선하기 위해 정기적으로 논의도 하고, 먼슬리 회고도 하고, 샘플 코드도 만들고, 디자인 모듈도 만들면서 나름 알찬 시간을 보냈다. 음, 그러니까 본질은, 그 누구도 우리에게 일을 주지 않았지만 시간을 허투루 보내진 않았단 뜻이다. 스터디를 통해 플러터[1]입문도 하고, 이런 것들이 쌓여 함께하던 분들과 단시간에 친밀감[2]을 쌓을 수 있었다고 생각한다. 있었는데… 그래도 분명 회사가 있었는데요, 있었거든요? 전 회사의 10% 규모래도 작은 건 아니거든요? 그런데 없어, 아니 없어지는 중이네요. 온실 속 화초에서 정글로 걸어가는 건 마냥 설레는 일은 아니다. 앞으로 이전보다 더한 고난과 역경이 닥칠 수도 있다는 것도 알지만 궁금한 걸 어떡해? 정글로 간다고 해서 날 잡아먹을 육식 동물만 있진 않겠지. ‘이만하면 웬만한 일 다 겪었다!’ 싶을 때 '힝, 속았지?'의 사건들이 종종 튀어나온다. 이번 일도 그 연장선이지, 뭐. &quot;진짜 망할 수도 있을 듯요. 와하하!&quot;라고 말하던 과거의 내 모습이 스쳐 가는 게 어쩌면 알면서 선택한 것 같기도. 그래서 후회하느냐? 아니. 낮은 확률이라 생각했을 뿐이지 고려하지 않은 상황은 아니다. 내 맷집 그렇게 약하지 않다고! 회사가 망한 건 처음이지만 뒤숭숭하고 소문 많은 분위기는 이미 신입사원 때 다~ 겪어낸 일이지 않겠습니까. 회사만 안 망했을 뿐이지 우리 팀이 폭파될 수 있단 걱정을 연말마다 해야 했던 n년차 직장인 짬바는 어디 안 가지롱. 그 상황[3]에서 내가 뭘 한다고 달라질 건 없었다. 공부가 손에 안 잡히는 거? 그것도 어쩔 수 없지. 불확실한 상황 속 단 하나의 확실함이 있다면 이 순간을 그리워할 날이 온다는 것이다. 미래의 난 ‘결국’ 일하고 있을 테니까. 그게 언젠지, 어딜지 모른다는 점만 빼면 월급도 나오지, 재택 중인데 일은 없지, 시간은 넘치지? 꿈꾸던 삶 아닌가요? 그렇게 생각하니 선택할 수 있는 건 딱 하나였다. 지금을 즐기자. 쉼표 찍기 많은 경험과 사람을 만나는 것에 집중했던 작년이라면 올해는 앞으로의 내 삶을 어떻게 가꿀지 정리하는 해가 되었으면 한다. 작년 회고에 적은 다짐이 이렇게 실현되는구나. 내 세상[4]에서 한 발짝 떨어지기로 했다. 차박에 진심…까진 아니더라도 빈도가 가장 잦았던 해. 별게 별것이 아니게 될 때까지 낯선 곳을 찾아 머리를 비웠다. 그때 본 일몰과 윤슬, 돌멩이가 부딪히던 소리, 누군가 즐기던 불꽃이 선하다. 물론 차박만 다닌 건 아니다. 미친 듯 더웠던 전주, 할머니, 엄마와 함께 다녀온 무의도, 수다가 목적이었던 일산, 그리고 고요함이 마음에 든 진해[5]도 있었다. 이게 되네? 구직자 포지션이 입사 예정자로 바뀌던 순간, 이대로 입사할 순 없단 생각이 들었다. 입사 전 해외 한번 찍어야지! 2박 3일 만에 방콕행 티켓을 끊고 숙소까지 예약하다니! 😨 비행기 타는 날 한숨도 못 자고 간 건 함정이지만 단기간에 몰입해서 해냈다는 것 자체로 뿌듯했다. 목적도, 목표도 없이 홀로 떠난 여행이라 그냥 많이 걷고, 구경하고, 쉰 게 전부였지만 아직까지도 조막만한 미니 파인애플의 맛이 혀끝에 맴돈다. 물론 1일 1마사지도 잊을 수 없음! 이 여행으로 체력도 지갑도 탈탈 털렸지만 후회는 없다. 그 둘은 채울 수 있지만 요 시간은 언제 다시 돌아올지 알 수 없으니. 또 다른 시작 8월부터 새 회사에 출근했다. 그렇게 시작된 우당탕탕 적응기 시즌 2! 는 작년의 시작과 참 닮아 있었다. 성격 좋은 능력자들이라 나만 잘하면 될 것 같달까. 그런 마음과 생각이 부담이 되어 또 자신감이 맨틀을 뚫고 들어갈락 말락 할 때 누군가 내 상태를 알아챘다. 내 오랜 숙제인 자신감 부족[6]이 정통으로 꿰뚫린 일은 처음이었다. 그러게. 틀리면 고치면 되고, 잘못한 건 개선하면 되는데 난 무엇 때문에 부담에 짓눌려 살았지? 짧다면 짧고 길다면 긴 n년의 커리어를 진지하게 돌아봤다. 그 끝에 욕심이 있었다. 사람이니까 흠이 있을 수도 있고, 실수를 할 수도 있는데 ‘그러고 싶지 않은’ 마음이 발목을 잡았던 거다. 그래서 인정하기로 했다. 난 부족하지만 잘하고 싶고, 잘 해내고 싶은 사람이다. 과정에선 실수가 있을 수도, 잘못된 방향으로 갈 수도 있지만 되돌리면 그만이다. ‘고작’ 그거 하나 잘못했다고 세상이 뒤집히지 않는다. 이 생각을 항상 마음에 품고 살아야겠다고 다짐한다. 그리고 이 글을 적는 지금, 어쩌면 이런 내 모습을 알아본 사람이 또 있었을지도 모르겠단 생각을 했다. 고마웠습니다. 덕후는 멈추지 않아! 휴덕은 있어도 탈덕은 없다는 말이 딱이다. 23년 1월 1일을 비투비 콘서트로 시작했으며, 10월 13일부터 15일은 임현식 콘서트로 불태웠다. 3일 올콘은 고민되는 일이었지만 (구)동방신기 덕질 중 깨달음이 있었으니, '떡밥은 줄 때 먹어야 한다!'는 거다. 3일 올콘에 올 스탠딩? 까짓거 별거 아니네! 작년 여름에 나올 것 같던 앨범이 아직까지 감감무소식이다. 무소식이 희소식이라는 말을 믿고 기다려 봐야지. DIVE INTO YOU, 콘서트 이름에 딱 맞는 공연이었다. 축축함도, 산뜻함도, 고독함도, 찬란함도 느껴지는 바다와 함께한 기분이랄까. 그 시간을 다시 곱씹으니 새삼 행복해지는 게 역시 좋은 선택이었다. 누구에게나 공개할 수 있는 그런 것 말고, 조용히 오래 즐기는 인문학적(?)인 덕질도 하나 있다. 올해는 요 부분에서 성장을 체감한 의미 있는 해였다. 코로나 이후로 늘 교류하던 사람들과만 교류했었는데 오랜만에 새로운 사람들을 만나게 되어 느끼고 배운 점이 많다. 가장 의미 있던 건 다음 레벨로의 점프를 위해 나름의 계산이 된다는 것이다. 지금까진 못 했던 건데! 존버는 승리한다고! 이제서야 조금 이해하는 것 “여기 일은 솔직히… 쉬워요.” “늘 쉽다고 할 순 없지만, 대체적으로 쉬워요.” 늘 어렵진 않아도 꽤 어렵다고 생각하던 우물 안 개구리는 충격에 휩싸였다. 🙃 개발 경력 차이만으론 설명할 수 없는 '뭔가’가 있겠다 싶었다. 무엇보다 속마음을 허투루 말하는 분이 아님을 알기에 더 그랬다. 그곳을 떠난 지 1년 남짓. 지금에서야 조금은 이해할 것 같기도. 책임 없이 넘어가는 일이 비일비재하다는 것, 내가 하는 일이 조금 잘못돼도 내 밥그릇이 엎어질 경우가 드물다는 것, 업무를 뺏기더라도 그뿐이라는 것 등 그분이 말한 '일’에는 여러 의미가 포함되어 있었다. 그러니까, '개발 경력 차이’보다는 '직장인으로 겪을 수 있는 경험 차이[7]’로부터 나온 결론이 아니었을까. 그러나 후회는 없다. 아마 과거로 돌아간대도 같은 선택을 할 거다. 맺음글 불확실의 끝을 달리던 시기, '어떤 선택이 최선일지 모르겠어요.'라는 말에 '지나고 보니 내가 선택한다고 착각하고 사는 거더라고요. 될 일은 어떻게 해서든 되고, 안 될 일은 어찌해도 안 되니 너무 걱정하지 마세요.'라는 위로를 받은 적이 있다. 당시에 난 '선택한다는 착각 속’이었고, 다 지난 지금에서야 '이렇게 될 일’임을 깨달은 거겠지. 역시 모든 과정은 지나고 난 후에야 비로소 제대로 평가할 수 있다. 그래서 23년 목표는 얼마나 달성했나요? 올해는 나를 다져가는 해로 만들겠다고 다짐한다. 가계부도 다시 쓰고, 투자 포트폴리오도 정리하고, 보험도 들고(어린이 보험 막차 타기), 영어 공부, 개발 공부(안드로이드가 아니더라도), 그리고 건강 챙기기가 있다. 영어는 작년부터 하고 싶다는 생각만 가지고 있었는데 올해는 꼭 꾸준히 해 봐야지! 많은 경험과 사람을 만나는 것에 집중했던 작년이라면 올해는 앞으로의 내 삶을 어떻게 가꿀지 정리하는 해가 되었으면 한다. 가계부도 다시 쓰고, 포트폴리오 정리하면서 증권사 연금 저축 계좌로 옮기는 것까지 완료했고, 보험도 성공! 영어 공부는 꾸준히 하고 싶었는데 그러지 못해서 아쉬웠고, 개발 공부…는 하긴 했는데 만족스럽진 못했다. 건강은 못 지킴. 올해만큼 자주, 많이 아팠던 해가 있었나 싶다. 2023년은 대충 65점이군요. 2024년엔 23년에 챙기지 못했던 건강 잘 챙겼으면 좋겠고, 노션도 정리하고, 돈도 열심히 모으고, '쓰는 것’에 조금 더 시간을 투자했으면 한다. 아무도 보지 않을 글이라도, 혹은 누구나 볼 수 있는 블로그라도 그냥 '쓰는 행위 자체’에 조금 더 집중하는? 기왕이면 개발 관련 글이면 좋겠지만, 그게 아니더라도 괜찮을 듯. 24년엔 12권 이상의 책을 읽었으면 하고, 프롬프트[8]와 좀 더 친해지는 해가 되었으면 한다. 에이, 그냥 믿고 가는 거지 뭐. 믿음은 현실이 되니까. 다른 문을 열어 따라 갈 필요는 없어 넌 너의 길로 난 나의 길로 음 하루하루마다 색이 달라진 느낌 밝게 빛이 나는 길을 찾아 I’m on my way 넌 그냥 믿으면 돼 I’m on my way 보이는 그대로야 너는 누군가의 Dreams come true 제일 좋은 어느 날의 데자뷰 머물고픈 어딘가의 낯선 뷰 I’ll be far away That’s my Life is 아름다운 갤럭시 Be a writer, 장르로는 판타지 내일 내게 열리는 건 big big 스테이지 So that is who I am Look at me now 어제랑 또 다른 짜릿한 나 두려운 모든 게 설레이게 I’m in sky high, OMG 사소한 건 다 아득해져 와 Look at me now I’m on fire I’m on my way 넌 그냥 믿으면 돼 I’m on my way 보이는 그대로야 너는 누군가의 Dreams come true 제일 좋은 어느 날의 데자뷰 머물고픈 어딘가의 낯선 뷰 I’ll be far away That’s my Life is 아름다운 갤럭시 Be a writer, 장르로는 판타지 내일 내게 열리는 건 big big 스테이지 So that is who I am 어느 깊은 밤 길을 잃어도 차라리 날아올라 그럼 네가 지나가는 대로 길이거든 1, 2, 3 Fly up I hope you’d be someone’s dreams come true 제일 좋은 어느 날의 데자뷰 머물고픈 어딘가의 낯선 뷰 I’ll be far away That’s my Life is 아름다운 갤럭시 Be a writer, 장르로는 판타지 내일 내게 열리는 건 big big 스테이지 So that is who I am 선언형 UI를 이해하는 데 많은 도움이 되었다. ↩︎ 혼자만의 생각이면 안 되는데요…! ↩︎ 이것저것 참 많은 시도를 했는데 이렇게까지 뭐가 안 나오는 상황도 처음이었다. (포괄적인 의미의) 누구에게 물어도 비슷한 답변이 나오던 기묘함. ↩︎ 물론 구직자이니 포트폴리오 정리, 서류, 과제, 면접 등 일련의 과정엔 성실히 임했다. ↩︎ 진해로 출발한 날 면접 봤단 사실을 까맣게 잊고 있었다. ↩︎ 있다가도 없고 없다가도 있다지만, 대부분 부족할 때가 많다. 자신감이 좀 생겼다 싶을 때마다 큰 실수를 해서 바닥부터 쌓아 올린 게 몇 번은 된다. 그래서 그런지 자신감이 붙을 땐 누구보다 조심스러워진다. ↩︎ 순서가 다를 뿐 나 또한 같은 일을 겪었으니까. ↩︎ 지니와 오래 놀았지만 AI가 너무 발전해서 슬슬 밑천 드러나는 중. ↩︎","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Diary","slug":"Anything/Diary","permalink":"https://d2fault.github.io/categories/Anything/Diary/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://d2fault.github.io/tags/%ED%9A%8C%EA%B3%A0/"}]},{"title":"[Android] 안드로이드 개발자의 디자인 시스템(모듈) 개발기","slug":"20230507-android-design-module-development-story","date":"2023-05-07T08:18:16.000Z","updated":"2024-01-03T14:01:13.949Z","comments":true,"path":"2023/05/07/20230507-android-design-module-development-story/","link":"","permalink":"https://d2fault.github.io/2023/05/07/20230507-android-design-module-development-story/","excerpt":"안드로이드 디자인 모듈을 개발하며 생긴 많은 고민과 결론을 정리한다.","text":"개요 어쩌다 디자이너 없이 디자인 시스템을 구축하게 되었느냐 물으신다면 대답해 드리는 게 인지상정! 단연코 가장 큰 이유는 역시 ‘디자인의 통일성’이라고 할 수 있다. 팀의 특성상 Sample App이나 Test App 등, product라고 할 수 없지만 공식적으로 ‘제공’해야 하는 애플리케이션들이 많은 편이다. 이 앱들은 필요에 의해 지속적으로 제공되기도 하지만 단발성으로 제공되기도 하기에 디자인이 중구난방인 상황이 발생한다. 이 부분에서 ‘디자인에 대한 고민 없이, 통일된 톤 앤 매너를 제공할 방법’으로 디자인 모듈의 필요성이 대두되었다. 요약하자면 다음과 같다. Product는 아니나 임시로 제공되는 앱(SampleApp, Test App 등)의 디자인이 통일되었으면 좋겠다는 니즈 디자인에 들어가는 비용 최소화 (가능하다면) iOS 앱도 유사한 느낌으로 제공할 수 있는 발판 마련 필요한 건 알겠고, 어떻게 하지…? 막상 시작하려 보니 고민할 포인트가 산더미처럼 쌓여 있었다. 그중 날 가장 헷갈리게 만든 두 가지 항목을 소개하려 한다. (이 두 가지가 전부였던 것 같기도 하고…?) Material 3, 어디까지 포함해야 하는가 🧐 디자인 모듈이 언급되었을 때, 해당 모듈이 포함될 테스트 앱에 Material 3 또한 적용해 보기로 하였다. 처음에는 ‘그럴 수 있지’의 생각이었으나, 막상 디자인 모듈 설계와 Material 3을 놓고 진지하게 고민하다 보니 ‘여긴 어디, 나는 누구?’의 상태가 되었다. 이제 와서 생각해 보면 그때의 내가 바보였다. Material 3 또한 디자인 시스템의 일종이니 디자인 시스템을 설계하는 상황[1]에서는 충돌이 발생할 수밖에. 이럴 때엔 기준을 잘 잡아야 한다는 걸 알고 있었지만 처음이다 보니 Material 3을 어디에 포함해야 하는지, 어디까지 넣어야 하는지의 기준 잡기가 쉽지 않았다. 처음에는, 찝찝함을 뒤로하고 이미 만들어진 디자인 시스템인 Material 3에 우리 브랜드를 녹여 보았다. 음, 좋은 시도였다고 생각한다. 가장 빠르게 만들 수 있는 방법이었으니까. 그러나 적절한 방법은 아니다. Material 버전이 업데이트된다면? Material 시스템에 종속된다는 건 결국 Material 버전에 따라 누군가는 이 디자인 모듈을 계속 수정해야 한다는 것을 의미한다. 너무 당연하지만, Material 3은 디자인 모듈이 아닌 모앱에 포함되어야 한다는 결론에 도달했다. 대신, Material 3 Theme을 쉽게 적용할 수 있도록 color set의 기본값을 지정하는 정도로 마무리했다. 재정의 Component 또한 Material 3과의 종속성을 끊어내고 AppCompat에 의존하도록 변경하였다. 네이밍, 네이밍, 네이밍!!! 🔥 하, 진짜, 할 말은 많지만 하지 못할 정도로 네이밍과 멱살 잡고 싸웠다. color부터 icon, selector 등 파일 하나 만들 때마다 수없이 고민했다. 단연코 탑은 dimen! 중복되는 값들이 많아 padding, margin 대신 spacing으로 통일하였는데 '어떤 값을 사용해야 할지 모르겠다’는 피드백을 받았고, 이 피드백을 통해 사용자 입장을 더 깊이 생각해 볼 수 있었다. 모듈 사용자 입장에서는 몇 가지 단어를 적어 보고 추천되는 값을 기반으로 적용할 텐데, ‘spacing’ 이나 ‘padding’ 만으로는 이게 ‘어디에’ 사용될 값인지 알 수 없다는 게 가장 큰 문제였다. 적은 리소스로 최대한 많은 범위를 포함하고 싶어 애매하게 정한 네이밍이 사용성을 해치는 결과를 낳았다. 🥲 위 피드백에 덧붙여, UI 적용 케이스마다 정해진 값이 있으면 편할 것 같다는 의견을 함께 받았다. 곰곰이 생각해 보니 이 방향이 맞았다. 디자인 모듈 개발 목적 중 하나는 '비용 최소화’도 있었기 때문에, 사용자 입장에서 고민할 시간을 줄이는 것 또한 모듈의 목표가 되는 게 맞다. 둥글둥글 애매모호했던 표현을 조금 더 명확하게 다듬었다. 예를 들어, default_start_spacing 과 같은 모호한 표현 대신 default_list_item_inner_padding_start 와 같이 ’사용 케이스’와 '어떤 값’인지 분명히 알 수 있도록 의도했다. 그래도 어쩌겠습니까, 해내야죠 0부터 시작하는 일은 몇 번을 마주해도 어렵지만 약간의 요령이 생기긴 하나 보다. 엄두가 나지 않을 땐 쪼개고 쪼개고 또 쪼개서 할 수 있는 것부터 하려고 노력한다. 쪼개고 쪼개진 것들이 모이면 덩어리가 될 테니까! 할 수 있는 것 먼저 처리하자 아이콘 리소스 집어넣기 쉽고 빠르게 할 수 있는 단순 노동. 아이콘은 사내에 공식 배포된 리소스가 있었기에, svg로 다운로드 후 xml로 변환하여 넣어 주었다. 네이밍은 ic_mail 과 같이 접두사로 ic 를 사용했다. color 정의하기 위 문단에서 언급한 것처럼 Material 3 기준 color setup 리소스와 함께 주로 사용되는 투명 색상과 기본적으로 사용되는 브랜드 컬러를 추가했다. 폰트를 넣어 볼까? NO! 굳이 몸집 키울 이유가 없다. 폰트는 필요한 경우 모앱에서 넣기로 해! Size, 너도 문제야 끝없는 싸움이었다. 🫠 모든 사이즈 정의가 불가하기 때문에 바로 사용해야 하는 값들과 함께 여기저기 막 사용할 수 있는 사이즈를 몇 가지 지정했다. 간략히 나열하자면 radius, button_text_size, image_size, text_size, line_height 정도? 그 외 몇 가지를 더 추가했는데, 이 값은 Material 3 dimen을 보고 힌트를 얻었다. label 이나 headline 등, 만만하게 막 쓸 수 있는 값들을 조금 더 추가했다. 그리고 이 값들로 커버할 수 없는 값은 dimen 이라는 친구로 통일했다. 예를 들어 dimen_2 는 8dp 를 의미한다. (실제 dp = 접미사 * 4) 버튼, 너라도 많이 만들어야겠다 Material 3을 기준으로 AppCompat을 상속하여 Custom Button set을 정의했다. 아래 리스트가 재정의한 버튼들이다. Button Button.Filled Button.Fit Button.Rounded Button.Rounded.Filled Button.FullyRounded Button.FullyRounded.Filled TextButton - AppCompat의 Button.Borderless 를 재정의함 TextButton.Fit OutlinedButton OutlinedButton.Rounded OutlinedButton.FullyRounded ImageButton ImageButton.Small ImageButton.Medium ImageButton.Large 버튼 정의시 배경과 selector 정의[2]가 필요하다. 이 부분은 캡쳐로 대신한다. 마무리하며 작업이 끝났을 때 바로 회고하는 게 가장 좋다는 걸 알면서도 늘 게으름이 이긴다. 그나마 다행인 건 작업 중 적어둔 메모의 존재와 중간중간 거친 정리 과정이겠지? 미루고 미루던 디자인 모듈 개발기를 완성할 수 있어 뿌듯한 일요일이다. 🍀 거창하고 대단하다고 할 순 없지만… AppCompat이 나온(나올 수밖에 없었던) 배경과 디자인 시스템을 이해해 보는 소중한 경험이었다. 🫡 참고 [Github] Material Components - Android Material3 Theme Builder Material2 Color Palette Generator Material3 공식 가이드(컴포넌트 내 여백 등 참고함) appcompat v21: material design for pre-Lollipop devices! 심지어 Material 3 가이드를 참고하여 설계하는 중이었음 🫥 ↩︎ selector 정의 안 해도 되지만… 안 하면 onClick event 발생시 ripple 효과가 안 생김 ↩︎","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://d2fault.github.io/categories/Programming/Android/"}],"tags":[{"name":"design","slug":"design","permalink":"https://d2fault.github.io/tags/design/"},{"name":"module","slug":"module","permalink":"https://d2fault.github.io/tags/module/"}]},{"title":"[Diary] 2022년 회고하기","slug":"20221231-diary","date":"2022-12-31T11:12:22.000Z","updated":"2024-01-03T14:01:13.948Z","comments":true,"path":"2022/12/31/20221231-diary/","link":"","permalink":"https://d2fault.github.io/2022/12/31/20221231-diary/","excerpt":"어쩌다 생긴 연말 루틴으로 12월만 되면 가슴 한켠에 숙제를 안고 살아가는 기분이나 적어서 얻는 이점을 포기할 수 없기에 올해도 포기하지 않고 달그락 달그락 갈무리해 본다.","text":"회고 뭐, 별거 있나요 까마득한 걸 보면 꽤나 오래전인 것 같다. 싸이월드 다이어리에 Goodbye 어쩌구, Hello 어쩌구 그런 문장을 적었던 게 시작이었으려나? 간단했던 문장이 넘버링한 여러 줄이 되고, 블로그 정착 후 줄글이 되었다. 어쩌다 생긴 연말 루틴으로 12월만 되면 가슴 한켠에 숙제를 안고 살아가는 기분이나 적어서 얻는 이점을 포기할 수 없기에 올해도 포기하지 않고 달그락 달그락 갈무리를 준비해 본다. 작년 회고 살펴보기 어떤 선택을 하든 내가 최우선이 되었으면 하는 바람으로, 올해의 첫 곡으로 비투비의 Dreamer 를 선정했다. 이 곡을 선정한 여러 이유 중 가장 큰 이유는 사그라든 열정의 불꽃이 다시 타오르길 바라는 마음이었다. 3으로 시작하는 나이는 처음이니 태초마을로 돌아가 다양한 시각으로 더 많은 걸 보고 느끼고 즐기고 싶었다. 결과보다 경험에 조금 더 집중하는 그런 것. 앞이 보이지 않고 세상이 휘청거려도 힘차게 we need to be stronger oh baby 뜻대로 되지가 않고 자꾸 어긋난대도 흘러가는 시간을 타고 Do what you wanna do 다 마음대로 해 네 마음대로 (다 마음대로 해 어때) 하고 싶은 대로 해 좋은 날에 (하고 싶은 대로 okay) 우린 아직도 꿈을 꾸고 가슴이 뜨겁게 뛰는 걸 I mean feel your heartbeat oh my baby Do what you wanna do 지금 시작해도 절대 안 늦었어 it’s not too late (it’s never too late) 누가 뭐라 해도 do what you wanna do it’s ok (everything gonna be ok) 매년 느끼는 거지만 새해 첫 곡의 의미는 참 대단하다. 매일 그 곡을 듣고 사는 것도 아니고, 가끔 생각날 때 듣는 정도인데 지나고 나면 어쩜 이렇게 한해가 가사처럼 지나가는 건지 알 수 없다. 끼워 맞추기도 10년이면 인정해 줘야 한다고! 그러니까 올해도 가사처럼 지나갔다는 뜻이다. 책임감과 부담을 조금 내려두고 순간에 집중하는, 때로는 ‘어떻게든 되겠지!’ 하는 막무가내의 멘탈로 잘 버텼다 는 뜻이지. 물보라를 일으켜 🌊 내 감정이나 생각이 마음대로 제어되지 않을 때 글을 쓴다. 심장이 콱 막힌 것 같은 기분이 들 때 실마리를 찾아내는 과정이라고 해야 하나. 아무튼, 노션과 페이스북 비공개 피드에 내 조각들이 남아 있다. 회고 작성 전 이 기록들을 하나씩 살펴보곤 하는데 눈물이 날 뻔했다. 다이내믹 그 잡채. 하고 싶은 일이 해야만 하는 일이 되었을 때의 스트레스 기록, 이해할 수 없는 행동에 관한 기록, 원인을 찾으려고 무던히 노력했던 감정 기복의 소용돌이 등 올해도 꽤 많은 성장을 해낸 것 같다. 내 감정이 가장 격정적이었던 순간, 범람하는 천을 보며 마음과 비슷하단 생각을 했나 보다. 너울치는 지금을 통제하지 않으려 해. 차라리 더 많이 느끼고, 생각하는 쪽을 택할래. 그럼 자연스럽게 정리되겠지. 그게 감정이든, 생각이든, 일이든, 사람이든. 그리고 지금, 날 이렇게 만든 사건이 무엇이었는지 기억나지 않는 걸 보아 자연스럽게 정리된 게 맞는 듯하다. 역대급 소비 올해를 소비의 해로 정의해도 과언이 아니다. (10년 넘게 고민하다 지른) 카메라 두 대(R10, g7x mark iii) 인스탁스 미니 필름 (300장은 사지 않았을까?) 보테가베네타 백 가족 선물 특히 카메라는 사서 아주 유용하게 사용하고 있다. 이럴 줄 알았으면 미리 살걸 약간의 후회감이 들기도 하고, 나한테는 똑딱이가 제격이란 생각이 들기도 하고… 제주도 여행에 R10과 함께 갔다가 힘들어서 사진이고 뭐고 포기하고 싶었다. 무엇보다 바디 손떨방이 없어 열심히 찍은 영상들이 멀미 유발 영상이 되어 버린 게 가장 아쉽다. (그래서 또 지른 g7x mark iii…) 일상을 담는 정도라면 하이브리드 카메라가 딱이다. 굳이 렌즈 교환식 그런 거 필요없어! 무거워! 찍고 싶은 순간에 내 손에 있는 카메라가 최고의 카메라임! 대학생 때 무슨 경진대회 상품으로 받은 인스탁스 미니90! 오래전 혼자 홍콩 여행했을 때 유용하게 쓴 후 사용한 적이 없었다. 배터리도 방전돼서 새로 구매한 건 안 비밀. 특별한 순간 단 한 장의 사진이라는 점이 너무 매력적이라 여행 갈 때마다 챙기게 된다. 덕분에 카메라 앞에서 뚝딱이던 표정과 포즈가 ‘조금은’ 개선되어 뿌듯하다. 연말정산 결과 보고 기겁했지만 덕분에 환급도 받고… 좋은 게 좋은 거라고 생각하기로 했다. ^^ 떠나요 ✈ 집을 정리하고 보니 거의 두 달에 한 번은 떠난 꼴이다. 이유는 모르겠지만 어쩌다 보니 그렇게 됐습니다. 강릉 벚꽃 여행 속초 여행 4박 5일 자동차 여행(남쪽) 제주도 여행 2회 서유럽 3국 패키지 여행(이탈리아, 스위스, 프랑스) 아무래도 가장 기억에 남는 건 유럽이다. 유로 가장 비쌀 때 간 게 조금 속이 쓰리지만 시간은 다시 돌아오지 않으니까. 패키지의 장점과 단점을 명확하게 깨달았던 여행. 이탈리아는 생각보다 너무 더웠고, 스위스 풍경은 그림보다 더 그림 같았고, 프랑스는 무언의 여유로움이 있었다. 이 여행을 기점으로 영어 회화를 향한 열정(?)[1]이 솟구치고[2] 있다. 23년엔 휴양지에 가 보고 싶은데 그럴 수 있겠지? 떠나요 ✈ 매시업을 12기를 마지막으로 매시업을 떠나기로 결정했다. 정말 마지막에 마지막에 마지막까지 고민하다 내린 결론이다. 후련함과 미련이 뒤엉킨 마음이지만 다방면으로 고민되는 것들을 두고 내 욕심 하나로 가져가는 건 이기적이라 생각했다. 매시업을 하겠다고 결심했던 순간부터 12기가 끝난 그 순간까지 돌이켜보면 감사한 일도, 힘든 일도, 소중한 추억도 참 많았다 싶다. 코로나가 아니었다면 좋은 사람들과 더 끈끈한 인연을 만들 수 있었을까? 그래도 다행인 건, 우연한 계기로 본 지원서의 내 다짐과 지난 2년의 내 모습이 다르지 않았다는 거다. 느리더라도 포기하지 않고, 채우려고 노력하고, 열심히 아이디어도 내고, 조율도 해 보고, 여러 사람들과 잘 섞여도 보았던 그 시간들이 무척이나 그리울 것 같다. 매시업이 없더라도 다양함을 경험하고 성장하는 사람이 되겠다 다짐한다. 떠나요 ✈ 회사를 올해의 가장 큰 변화. 약 5년을 몸담은 회사와 작별했다. 큰 꿈은 없었지만 희망을 갖고 입사했던, 나름의 애정을 가진 회사를 떠나며 다양한 기억과 추억이 떠오른다. 진지하게 퇴사를 고민하며 내 마음을 불편하게 한 건 차곡차곡 쌓은 인간관계와 늘 함께했던 업무를 두고 간다는 점이었다. 일에는 아무런 문제가 없었다. 동료분들 모두 각자의 프로젝트와 긴 시간을 함께했기에 업무 하기가 수월했다. 다만, 회사의 행보에 희망이 생기지 않았다. 여러 문제가 있었다. 어용 노조를 포함하여 차마 글로 적을 수 없는, 직접 겪어야 알 수 있는 것들. 그러나 아이러니하게도 그 조직 안에는 업무에 최선을 다하는, 척박한 상황에서도 성공해내는 멋진 사람들이 있다. 물론 한순간의 불만으로 퇴사를 결정한 것은 아니다. 입사할 때부터 갖고 있던 의문이 3년 차 때 극에 달했고, 행동을 통한 결과를 얻어낸 게 올해였을 뿐. 바뀔 거라 믿고 버틴 게 벌써 몇 년이다. 이 회사를 나갈 경우 나의 득실을 세 가지로 나누어 보았다. 얻는 것, 잃는 것, 그리고 기대되는 것. 잃는 것도 잃기엔 아까운, 상당히 가치있는 것들이었지만 얻는 것과 기대되는 것의 가치에 더 끌렸다. 그리고 그 가치는, 나의 성장이다. 이 또한 5년을 일하며 나름의 성장을 해왔기에 선택할 수 있었다고 생각한다. 그냥, 바깥 세상이 궁금했다. 온실 속 화초에서 정글로 걸어가는 건 마냥 설레는 일은 아니다. 앞으로 이전보다 더한 고난과 역경이 닥칠 수도 있다는 것도 알지만 궁금한 걸 어떡해? 정글로 간다고 해서 날 잡아먹을 육식 동물만 있진 않겠지. 어디서든 내 몫을 해내는 사람이고 싶다. 새 회사 적응기 적응하기 위해 정말 열심히 노력 중이다. 분위기, 업무, 근무 체계, 업무 방식 등 다른 점이 너무 많다. 정적인 환경에서 동적인 환경으로 바뀐 터라 포지셔닝에 관해 고민하고 있다. 사실 이 고민은 둘째고, 진짜 고민은 ‘아무도 지적하지 않는데 뭔가 증명해야 할 것 같은’ 마음이다. 매일같이 멘탈 붕괴와 재건이 반복된다. '누군가에겐 나도 대단할 때가 있겠지, 나도 유독 잘하는 부분이 있겠지’라고 되뇌여도 자꾸 무너지는 걸 어떡하니~ 처음 겪는 일이라 생각했는데 문득 떠오른 순간이 있었다. 세상 사람 다 똑똑한데 나만 바보인 것 같은 기분을 느끼던 그 해에 나는 큰 성장을 이뤘다. 지금 이 버거움도 성장통의 일종이리라. 현명하게 잘 견뎌내겠다고 다짐해 본다. 내 의지로 할 수 있는 건 몸이 무너지지 않도록 하는 것 뿐. 아이러니하게도 같이 일하는 분들은 하나같이 너무 좋다. 잘 챙겨 주시고, 다정하고, 따뜻하다. 결국 이 스트레스는 모두 나에게서 기인한 것이란 의미이겠지? 몸으로 올 스트레스를 잘 털어내야겠다. 문화 생활과 취미 문화 생활 한 거라곤 넷플릭스 보기, 음악 듣기, 두 번의 사진전, 싸이 흠뻑쇼, 사운드베리페스타, 그리고 한 편의 뮤지컬[3]이 전부이다…라고 적으려고 했는데 열거하고 보니 생각보다 많이 즐겼네? 그래도 문화보단 여행에 조금 더 집중했던 거로. 사운드베리페스타 이야기를 빼 놓을 수가 없다. 양일권으로 갔는데 이튿날에 비가 너무 많이 와서 힘들었다. 갑자기 태풍이요? 그래도 포기 안 하고 양일 다 간 내가 위너다. HYNN(박혜원)의 음악 스타일을 좋아하지 않음에도 불구하고 노래를 너무 잘해서 듣는 내내 정신이 혼미했다. 특히 ‘막차’ 라이브 때 처음 들은 곡임에도 불구하고 눈물 줄줄 흘렸던 건 비밀. 이직이 되냐 마냐, 하는 게 맞냐 아니냐 등을 두고 고민하던 때라 더욱 와닿았던 것 같다. 10cm 보고 덕통사고(원래 좋아하긴 했지만) 당해서 몇 주 내내 10cm 노래만 들었고, 소란의 무대 매너 끝내줬고, 상큼한 최예나, 음색이 좋았던 조유리, 낯가리던 이석훈, 목 상태가 아쉬웠던 볼빨간 사춘기, 늘 안정적인 잔나비, 목소리에 진심이 묻어나는 박재정 등 정말 많은 무대가 날 행복하게 했다. 윤하 언니… 비가 너무 와서 못 봤는데… 갈 걸 그랬어… 그리고 몇 년을 놓지 못하는 취미, 노래. 조금씩 흩어진 퍼즐을 하나씩 끌어다 맞추는 중이다. 퍼즐이 있다는 게 어디며, 이만큼 나아진 게 어디야. 갈 길이 멀지만 존버는 승리하니까! 하다 보면 또 늘겠지. 책을 거의 안 읽은 건 반성해야 한다. 미디어 시청 시간을 좀 줄이는 게 좋겠다. 회고를 맺으며 12월 중순부터 회고를 위해 달렸지만 올해도 밀렸다. 중요한 건 꺾이지 않는 다짐. 올해의 끝에서 작년의 다짐을 얼마나 지켜내었는지 확인해 보아야겠지? 작년보다 조금 더 여유롭고, 건강하고, 기초를 탄탄히 하는 해가 되었으면 한다. 욕심 대신 순간을 소중하게 여기고, 나에게 주어진 기회들과 행복을 누리는 한해가 되길. 여유를 갖고 다방면의 경험을 쌓는 해였고, 퇴라피로 건강을 ‘잠깐’ 되찾았으며, 기초를 탄탄히 하고자 했으나 빈 곳을 모두 채우는 건 쉽지 않은 일이었다. 점수를 따지면 70점? 위의 문장을 적으며 '2022년에는 이직할지도 모르겠다.'라는 생각을 했는데 그 일이 현실이 될 줄은 몰랐습니다. 우당탕탕 정신없는 한해였지만 그래도 어떻게 저떻게 잘 보낸 듯하다. (회고도 12월 중순부터 미리 쓰기 시작한 거 칭찬해!) 올해는 나를 다져가는 해로 만들겠다고 다짐한다. 가계부도 다시 쓰고, 투자 포트폴리오도 정리하고, 보험도 들고(어린이 보험 막차 타기), 영어 공부, 개발 공부(안드로이드가 아니더라도), 그리고 건강 챙기기가 있다. 영어는 작년부터 하고 싶다는 생각만 가지고 있었는데 올해는 꼭 꾸준히 해 봐야지! 많은 경험과 사람을 만나는 것에 집중했던 작년이라면 올해는 앞으로의 내 삶을 어떻게 가꿀지 정리하는 해가 되었으면 한다. 이런 마음을 담아 친구들과 함께 들은 올해의 첫 곡은 김동률의 '출발’ 이다. 아주 멀리까지 가보고 싶어 그 곳에선 누구를 만날 수가 있을지 아주 높이까지 오르고 싶어 얼마나 더 먼곳을 바라볼 수 있을지 작은 물병 하나 먼지 낀 카메라 때 묻은 지도 가방 안에 넣고서 언덕을 넘어 숲 길을 헤치고 가벼운 발걸음 닿는대로 끝없이 이어진 길을 천천히 걸어가네 멍하니 앉아서 쉬기도 하고 가끔 길을 잃어도 서두르지 않는 법 언젠가는 나도 알게 되겠지 이 길이 곧 나에게 가르쳐 줄 테니까 촉촉한 땅바닥 앞서간 발자국 처음 보는 하늘 그래도 낯익은 길 언덕을 넘어 숲 길을 헤치고 가벼운 발걸음 닿는 대로 끝없이 이어진 길을 천천히 걸어가네 새로운 풍경에 가슴이 뛰고 별것 아닌 일에도 호들갑을 떨면서 나는 걸어가네 휘파람 불며 때로는 넘어져도 내 길을 걸어가네 작은 물병 하나 먼지 낀 카메라 때 묻은 지도 가방 안에 넣고서 언덕을 넘어 숲 길을 헤치고 가벼운 발걸음 닿는 대로 끝없이 이어진 길을 천천히 걸어가네 내가 자라고 정든 이 거리를 난 가끔 그리워 하겠지만 이렇게 나는 떠나네 더 넓은 세상으로 처음 마주할 것들이 많으리라 예상되는 2023도 지지 않으며, 또 가끔 지며 다채롭게 채워 봐야지!","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Diary","slug":"Anything/Diary","permalink":"https://d2fault.github.io/categories/Anything/Diary/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://d2fault.github.io/tags/%ED%9A%8C%EA%B3%A0/"}]},{"title":"[GoodNote] 2023 굿노트 다이어리, 프리노트 무료 배포","slug":"20221225-2023-goodnote-diary-and-free-note-templates-for-free","date":"2022-12-25T13:36:22.000Z","updated":"2024-01-03T14:01:13.946Z","comments":true,"path":"2022/12/25/20221225-2023-goodnote-diary-and-free-note-templates-for-free/","link":"","permalink":"https://d2fault.github.io/2022/12/25/20221225-2023-goodnote-diary-and-free-note-templates-for-free/","excerpt":"이 다이어리의 가장 큰 목적은 업무 플래너이기에 위클리만 제작하였으며, 시작하는 요일도 월요일로 만들었다. 사이즈는 일반적인 다이어리 크기인 A5로 설정하였고, 프린트가 필요할 경우 모아찍기로 두 페이지를 A4 한 장에 넣을 수 있도록 했다.","text":"Preview 설명 올해 다이어리 표지 색상은 팬톤에서 선정한 2023 올해의 컬러인 ‘비바 마젠타’ 로 선택했다. 벌써 세 번째 제작한 플래너로, 게으름과 여러 시행착오 끝에 이제서야 첫 배포를 해 본다. 이 다이어리의 가장 큰 목적은 '업무 플래너’이기에 위클리만 제작하였으며, 시작하는 요일도 월요일로 만들었다. 사이즈는 일반적인 다이어리 크기인 A5로 설정하였고, 프린트가 필요할 경우 모아찍기로 두 페이지를 A4 한 장에 넣을 수 있도록 했다. 위클리가 모두 모눈인 이유는 딱히 없다. 개인적으로 모눈을 가장 선호하기에 그렇게 설정하였다. 맨 마지막 페이지에는 'DIARY’와 'MEMO’가 포함되어 있는데, 개인적으로 이 공간은 다이어리와 함께 배포되는 프리 노트를 이용하여 채운다. 위클리는 대부분 업무 관련 내용만 적고 다이어리 쪽에 프리 노트를 추가하여 사용한다. 맨 뒤쪽 메모의 경우 위클리 칸이 넘칠 경우[1] 사용한다. 프리 노트는 크게 모눈, 무지, 라인으로 나누어 제작했다. 가장 자주 쓰는 것은 모눈 4분할이다. 프리노트의 라인 색상 또한 ‘비바 마젠타’ 계열의 붉고 옅은 톤으로 설정했다. 이걸 굳이 왜 직접…? 만들고 싶지 않았다. 굿노트 무료 템플릿, 굿노트 심플, 굿노트 심플 노트 등 여러 키워드로 검색했는데 마땅한 템플릿을 찾지 못했을 뿐… 다꾸 용도 말고 딱 업무에 쓰기 좋은 노트를 찾을 수가 없어 전적으로 나에게 맞는 형식으로 직접 만들었다. 위클리는 딱 투두 리스트 정도만 작성할 수 있도록 간단하게 만들고, 길어지는 내용은 뒤쪽으로 뺄 수 있게 했다. (이 방식 또한 수많은 시행착오 끝 얻어낸 결론이다.) 놀랍게도 이 템플릿은 모두 파워포인트로 만들었다. 사용 폰트 Franklin Gothic Medium Oswald-Regular_Medium Bahnschrift Light SemiCondensed 서울남산체 B 서울한강체 B 다운로드 2023 다이어리 다운로드 2023 Free Note 다운로드 무단 배포 및 임의 수정을 엄격히 제한[2]합니다. 아이디어 노트, 개발 노트, 회의록, 자산 관리 등 ↩︎ 개발자가 머리 싸매고 잡은 디자인 막 카피하고 그러는 건 정말이지…말도 안 된다고 생각함.😐 ↩︎","categories":[{"name":"Blog","slug":"Blog","permalink":"https://d2fault.github.io/categories/Blog/"},{"name":"Information","slug":"Blog/Information","permalink":"https://d2fault.github.io/categories/Blog/Information/"}],"tags":[{"name":"goodnote","slug":"goodnote","permalink":"https://d2fault.github.io/tags/goodnote/"},{"name":"굿노트","slug":"굿노트","permalink":"https://d2fault.github.io/tags/%EA%B5%BF%EB%85%B8%ED%8A%B8/"},{"name":"템플릿","slug":"템플릿","permalink":"https://d2fault.github.io/tags/%ED%85%9C%ED%94%8C%EB%A6%BF/"}]},{"title":"[Android] ContentObserver 알아보기","slug":"20220721-android-contentobserver","date":"2022-07-21T13:02:33.000Z","updated":"2024-01-03T14:01:13.946Z","comments":true,"path":"2022/07/21/20220721-android-contentobserver/","link":"","permalink":"https://d2fault.github.io/2022/07/21/20220721-android-contentobserver/","excerpt":"타 패키지 내 콘텐츠 변경시 이벤트 수신 방법을 알아본다.","text":"개요 타 패키지의 DB 값을 ContentProvider 로 읽어오는 로직 개발 중 DB 값이 변경되었을 때의 이벤트를 수신하고 싶었다. 가장 쉽게 구현하는 방법으로는 DB 변경을 알려주는 Intent 규격을 하나 생성하는 것이겠지만, 구글링을 통해 내가 원하는 기능을 Android 플랫폼에서 자체적으로 제공한다는 사실을 알아냈다! (나만 몰랐던 이야기…?) 단, ContentObserver는 Oreo 이상에서만 동작한다. Oreo 미만 단말에서는 Intent 를 사용해야 하겠지요? ContentObserver 가 뭔데? 이름 그대로 ‘Content를 관찰’하다가 변경이 생겼을 때 알려주는 친구다. 즉, 우리는 변경을 관찰하고 싶은 URI 를 등록하기만 하면 된다. BroadcastReceiver 사용할 때와 동일하게 ‘등록’ 과정이 있기 때문에 모든 사용이 끝난 후에는 꼭! 메모리 누수 방지를 위한 등록 해제가 필수이다. 사용법 ContentObserver 등록 context 로부터 contentResolver 에 접근할 수 있으며, 여기까지 접근하면 registerContentObserver 로 observer를 등록할 수 있다. 해제가 필수이기 때문에 등록한 ContentObserver 객체를 유지하고 있어야 한다. 1234567891011121314151617// ContentObserver 생성하여 변수에 유지함val contentObserver = object : ContentObserver(Handler()) &#123; override fun onChange(selfChange: Boolean) &#123; super.onChange(selfChange) if (selfChange) &#123; // TODO: 이 이벤트 발생시의 동작 정의 &#125; &#125;&#125;// context에서 contentResolver에 접근하여 ContentObserver 등록with(context.contentResolver) &#123; /* notifyForDescendants: Boolean */ // true: 하위 경로의 변경도 관찰 // false: URI 경로의 변경만 관찰 registerContentObserver(URI, true, contentObserver)&#125; ContentObserver 등록 해제 유지하고 있던 contentObserver 를 이용하여 등록을 해제한다. 123context.contentResolver.run &#123; unregisterContentObserver(contentObserver)&#125; 유의 사항 사실 위 과정은 변경하는 쪽에서 알려주지 않으면 말짱 도루묵이다. DB를 수정하는 부분에서 아래 코드를 꼭! 추가해 주어야 한다. (직접 해 봤는데 얘 없인 진짜 안 된다.) 1context.contentResolver.apply &#123; notifyChange(uri, null) &#125; 참고 Android 공식 Document: registContentResolver Android 공식 Document: unregistContentResolver ContentObserver 뭐하는 녀석인지 알아봅시다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://d2fault.github.io/categories/Programming/Android/"}],"tags":[{"name":"contentprovider","slug":"contentprovider","permalink":"https://d2fault.github.io/tags/contentprovider/"},{"name":"contentobserver","slug":"contentobserver","permalink":"https://d2fault.github.io/tags/contentobserver/"}]},{"title":"[Android] Process VS Task","slug":"20220403-android-process-vs-task","date":"2022-04-03T07:27:55.000Z","updated":"2024-01-03T14:01:13.941Z","comments":true,"path":"2022/04/03/20220403-android-process-vs-task/","link":"","permalink":"https://d2fault.github.io/2022/04/03/20220403-android-process-vs-task/","excerpt":"안드로이드의 Process와 Task를 알아본다.","text":"개요 안드로이드 Activity의 launchMode 에 대해 공부하던 중에 process 와 task 개념을 확실하게 하기 위해 포스팅을 작성한다. Process? Task? 안드로이드 애플리케이션을 실행하면 Process가 생성된다. 이 Process는 애플리케이션마다 별도로 생성되며, 애플리케이션이 종료될 때 Process도 종료된다. 그렇다면 Task는 언제 생성될까? Task는 현재 생성된 Task가 없을 때에 생성되고, 이미 생성된 Task가 있다면 그 Task에 Activity 정보를 저장한다. Process 애플리케이션의 독립적인 실행 단위 Task 프로세스와 무관하게 실행되는 액티비티의 정보를 저장하는 공간 Task에 Activity 정보를 언제 저장하는데? 예를 들어 보자. 메신저 앱에서 친구에게 사진을 보내고 싶을 때 우리는 '앨범’에서 사진을 선택하여 전송한다. 이때, 앨범 앱이 올라왔다가 내려가게 되는데 이 상황을 Task 기준으로 그림을 그려 보면 다음과 같다. 메신저 앱이 띄워진 상태 ‘사진 첨부’ 버튼을 눌러 앨범을 띄운 상태 사진을 선택하고 ‘확인’ 버튼을 눌러 메신저 앱에 돌아간 상태 사진을 다 보내고 애플리케이션을 종료하여 런처(홈 화면)로 돌아간 상태 화면에 보이는 Activity에 따라 Task에 저장된 Activity 정보가 달라지는 것을 볼 수 있다. 단, Task에 저장된 것이 ‘Activity’ 가 아닌 'Activity 정보’임을 유의해야 한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://d2fault.github.io/categories/Programming/Android/"}],"tags":[{"name":"process","slug":"process","permalink":"https://d2fault.github.io/tags/process/"},{"name":"task","slug":"task","permalink":"https://d2fault.github.io/tags/task/"}]},{"title":"[Book] 이것이 안드로이드다 with 코틀린","slug":"20220220-book-review-this-is-android-with-kotlin","date":"2022-02-20T05:07:16.000Z","updated":"2024-01-03T14:01:13.929Z","comments":true,"path":"2022/02/20/20220220-book-review-this-is-android-with-kotlin/","link":"","permalink":"https://d2fault.github.io/2022/02/20/20220220-book-review-this-is-android-with-kotlin/","excerpt":"하나! 코틀린이 낯설다고요? 걱정하지 마세요, 코틀린 기본 문법부터 설명합니다. 안드로이드 앱 개발은 자바와 코틀린 이 두 가지 언어로 할 수 있는데요. 구글이 안드로이드 공식 언어로 코틀린을 채택한 뒤로 코틀린은 안드로이드를 학습하는 데 필수 언어가 되었습니다.","text":"책 소개 이미지를 클릭하시면 네이버 책으로 이동합니다. 책 정보 하나! 코틀린이 낯설다고요? 걱정하지 마세요, 코틀린 기본 문법부터 설명합니다. 안드로이드 앱 개발은 자바와 코틀린 이 두 가지 언어로 할 수 있는데요. 구글이 안드로이드 공식 언어로 코틀린을 채택한 뒤로 코틀린은 안드로이드를 학습하는 데 필수 언어가 되었습니다. 이 책은 코틀린을 모르는 독자도 앱을 개발할 수 있도록 안드로이드 앱 개발에 필요한 코틀린 기본 문법부터 설명합니다. 앱 개발에 꼭 필요한 내용을 모두 담았습니다. 둘! 안드로이드 프로그래밍의 기초, UI 구성과 생명주기부터 설명합니다. 안드로이드 스튜디오를 설치하고 기본 화면 구성부터 설명합니다. 위젯과 레이아웃을 다루고, 액티비티와 컨테이너, 뷰를 통해서 화면 전체를 컨트롤하는 방법을 순서대로 설명합니다. 설명을 따라 작성하는 작은 프로젝트는 나중에 실전 프로젝트에 활용할 수 있습니다. 셋! 실무에서 사용하는 앱 개발에 필요한 개발 지식을 다룹니다. 앱 개발은 단순히 코틀린 언어를 익히고 안드로이드의 화면을 구성한다 해서 완성할 수 있는 게 아닙니다. 네트워크나 데이터베이스와 파일 입출력, 오픈 API 등 안드로이드 앱 개발에 필요한 다양한 개발 지식을 다루고 실습합니다. 넷! 실전 프로젝트를 포함한 70개의 예제로 다양한 기능을 실습합니다. 실생활에서 가장 많이 사용하는 사진, 카메라, 타이머, 메모장, 음악 플레이어, 오픈 API를 활용한 서울시 도서관 찾기 프로젝트 등을 제공합니다. 또한 3판에서는 파이어베이스를 활용한 실시간 채팅 앱과 맵 클러스터링 등 다양한 실습을 추가로 제공합니다. 여러 기능을 익히고 활용하여 맞춤형 앱을 개발해보세요. 리뷰 피할 수도, 피해서도 안 되는 Kotlin 안드로이드 개발에 처음 입문한 건 2015년 초, MVC 패턴이 주를 이뤘고, 이벤트 버스와 버터나이프가 언급되며, 간간히 Eclipse와 Android Studio를 같이 쓰던 때였다. 그때를 생각하면 지금이 양반이다 싶지만, 만족스러운 성장을 했느냐를 묻는다면 당당히 그렇다고 답변할 순 없을 것 같다. 안드로이드에 Kotlin이 대세가 된 것도 벌써 몇 년이 지났다. 회사에서는 여전히 Java를 사용하고 있었기에, Kotlin을 사용할 수밖에 없는 환경에 나를 몰아넣기로 했다. 그렇게 시도한 것이 1. MashUp(동아리) 과 2. 사내 프로젝트에 Kotlin 도입 이었다. 매시업 덕분에 2020년에 드디어 Kotlin과 직접적[1]으로 마주할 수 있었다. Kotlin과 안드로이드에 천천히 익숙해질 때쯤 사내 프로젝트[2]를 하나 맡게 되었다. 기획, 설계, 개발, 테스트, 배포, 가이드 제작까지 모두 직접(물론 혼자) 해야 하는 일이었다. 이미 이렇게 받은 일이 두 번째[3]이기에, 이번에는 새로운 도전을 해 보기로 했다. 이 프로젝트를 팀 내 첫 번째 순수 코틀린 프로젝트로 만들기로 결심[4]한 것이다. 그런데, 아무래도 Java에 익숙해져 있다 보니 코틀린에 손에 착 붙진 않았다. 가장 공들였던 부분이 바로 Null Safety, 지연 초기화, 스코프 함수, 그리고 확장 함수였다. 이 부분은 Kotlin 언어 이해도에 따라 설계 효율성이 달라지는데, 위 사진처럼 Kotlin 언어에 대해서도 친절하고 자세히 적혀 있어서 내가 짠 코드를 다시 한번 되돌아볼 수 있는 계기가 되었다. 책에는 확장 함수 내용이 포함되지 않아 아쉽긴 했지만, 확장 함수는 Kotlin의 특징 중 하나이기에 이 책에서 다루는 게 약간의 오버(?)처럼 느껴질 수도 있을 듯하다. 안드로이드 서비스 개발자의 숙명, 레이아웃(View) 다정함과 세심함에 놀랐던 파트이다. 이미 어느 정도 안드로이드 지식을 갖고 있는 나에게는 아는 내용이 대부분이었지만, 입문자도 어렵지 않게 따라갈 수 있도록 디테일을 잡았다. 에디터 구성을 우선적으로 설명하고, 그 아래 ‘여기서 잠깐’ 파트를 만들어 난감할 수 있는 상황에 대한 해결법을 함께 제시했다는 점이 인상깊었다. 후배가 생긴 이후로 '어디서부터 얼마나, 어떻게 설명해야 하는지’에 대해 늘 고민하던 나에게 깨달음이 되었다. 그 뒤에 나오는 내용은 위젯을 어떻게 배치할 수 있는지, 그리고 각 위젯에서 자주 사용하는 속성에 관한 내용을 설명하고 있었는데, 차근차근 훑어보며 늘상 책상에 두고 읽고 싶다고 생각했다. 업무 특성 상 레이아웃과 그리 친하진 않은지라 위젯 속상은 매번 ‘이게 뭐가 있었는데, 뭐더라…’ 라고 생각하며 검색[5]하곤 했었다. 이젠 귀찮은 검색 대신 잊어버릴 때마다 책을 여러 번 읽기로 다짐했다. 그 외에도 현업에서 개발할 때 자잘자잘하게 신경써야 하는 부분을 언급해 주어 고마운 책이었다. 특히, ‘권한 체크’ 가 필수인 몇 가지 항목들이 있는데, 위험 권한 승인 팝업을 띄우고 결과를 전달받는 예제 코드가 있다는 것이 꽤나 매력적[6]이었다. 무엇보다 후반부로 갈 수록 참고할 내용[7]이 많아져서, 두고두고 읽을 좋은 참고서를 만났다는 생각에 기분이 좋아졌다. 가장 좋았던 건, 매 챕터마다 시작 전 간략하게 무엇을 할 것인지 목표를 설명한다는 점이다. 그 부분만 잠깐 읽어 보면 이 챕터의 내용이 필요한 것인지, 그렇지 않은 것인지 구분할 수 있다는 이점이 있었다. 누구에게 추천할 것인가? 한빛미디어에서 제안한 이 책의 추천 독자는 다음과 같다. * 이 책이 필요한 독자 · 코틀린은 처음이다. · 만들고 싶은 앱이 있다. · 안드로이드 앱 개발자가 되고 싶다. · 입사 후 의지와 상관없이 업무상 앱 개발을 담당하고 있다. · 우연히 유튜브 강의로 접하고 본격적으로 앱 개발을 하고 싶다. 위 리스트 모두에게 추천하고 싶지만, 꼭 봐야만 하는 딱 하나의 독자를 고르자면 만들고 싶은 앱이 있는 독자이다. 이 책은 가벼이 넘길 수 있는 문제도 세심하게 알려주는 친절함이 돋보이는 책이지만, 프로젝트 베이스로 진행되는 책은 아니다. 그 말인 즉, 명확한 목표가 없다면 많은 것을 얻지 못할 수 있다는 것. 그러나 역으로, 내가 만들고 싶은 앱이 있고 그 방법에 대한 것을 고민하는 중이라면 누구보다 많은 것을 얻어갈 수 있다고 생각한다. 추가로, 코드 타이핑 없이 안드로이드 개발의 느낌을 살펴보고 싶다면 5장의 액티비티를 읽은 다음 4장의 위젯과 리소스 다루기를 읽어보는 것을 추천한다. 우선 책에 제시된 예제 코드들을 보며 흐름과 코드 구성을 한번 생각해 보고 여유가 될 때 4장의 위젯과 리소스를 직접 만들어 보아도 된다. 그리고 개인적으로는 언어’만’을 공부하는 것에 큰 흥미를 느끼지 못해서 코드로 부딪힌 다음 빈 지식을 도큐먼트를 읽으며 채우는 편이다. 그런 의미에서 개발의 기초 지식이 있는 분들은 초반의 Kotlin 언어 파트를 스킵하고 필요할 때마다 보는 것도 나쁘지 않은 선택이라고 생각한다. 꿀팁을 하나 남기자면, 한빛미디어에서 무료 동영상 강의를 제공한다. 아직 영상을 보진 못했지만, 영상 리스트로 봤을 땐 기본 지식이 없지만 당장 현업에 사용해야 할 때 급하게 볼 수 있을 정도의 강의인 것 같아서 종종 애용하지 않을까 싶다. 위 서평은 한빛미디어 &lt;나는 리뷰어다&gt; 활동을 위해서 책을 제공받아 작성되었습니다. 언제나 시도하긴 했었다. ↩︎ 안드로이드 라이브러리(SDK) 개발 관련 ↩︎ 안드로이드 SDK 개발기는 이 포스팅에 기록했다. ↩︎ 결심 이후 팀장님과 팀원들의 동의를 받아 시작했다. ↩︎ 자주 안 쓰다 보니 자꾸 까먹는다. 키워드가 생각이 날 듯 말 듯할 때 적당히 검색해서 사용하기 신공… ↩︎ 꼭 필요하지만 귀찮은 일이기에 베이스 코드를 미리 만들어 두면 도움이 될 듯하다. 어차피 늘상 사용해야 하는 것이기 때문. ↩︎ 코루틴, Room, 서비스, 구글 지도, 네트워크, 파이어베이스 등 안드로이드 개발시 언젠가 한 번은 꼭 사용하게 되는 것들에 관한 내용이 풍부했다. ↩︎","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"android","slug":"android","permalink":"https://d2fault.github.io/tags/android/"},{"name":"책","slug":"책","permalink":"https://d2fault.github.io/tags/%EC%B1%85/"}]},{"title":"[Diary] 2021년 회고하기","slug":"20211231-diary","date":"2021-12-31T13:36:42.000Z","updated":"2024-01-03T14:01:13.928Z","comments":true,"path":"2021/12/31/20211231-diary/","link":"","permalink":"https://d2fault.github.io/2021/12/31/20211231-diary/","excerpt":"2021년을 회고한다.","text":"회고 전 변명 2020 회고에는 회고 전 반성, 2021년 회고에는 회고 전 변명~! 같은 실수를 반복하는 인간이라지만 올해는 그러지 않기 위해 나름의 노력을 기울이긴 했다. 1월 초에 카페에 가서 회고에 쓸 내용 정리도 미리 해 놓았는데 하필 게으름이 발동할 게 뭐람. 정리만 해 두고 글을 쓰지 않은 내 죄이지 뭐. 그래도 한 가지 변명을 추가하자면, 연말 이사로 인해 정신이 하나도 없어서 그랬다. 10년 묵은 짐을 버리고 정리하고 치운다고 미리미리 고생했는데 치워도 치워도 끝이 없어서[1] 여기가 지옥이구나, 싶었는걸. 포기하지 않은 게 어디야! 2020년 회고 살펴보기 2020년을 코로나로 아쉽게 보냈기 때문일까, 2021년은 그것보단 안정적이길 바라는 모습이 회고에 담겨 있었다. 2021년은 사랑과 애정으로 따뜻함이 넘치는 한해가 되길 기도하며 비투비포유의 Show your love 을 새해 첫곡으로 선정했다. 그러지 않았어야 했다. 이 곡을 듣지 않는 게 더 좋을 뻔했다. 어둠이 내려 앞이 보이지 않아 길을 잃었어 이 세상은 왜 아름답기보단 아프기만 한지? 많은 사람이 넘어지고 많은 눈물이 넘쳐흘러 우린 필요해요 서로에게 힘이 돼야 해, oh 들으면서도 불안하긴 했어. 도입부 가사부터 희망, 행복이 아닌 아픔이잖아? Show your love를 듣고 Show my love로 행한 한해가 되어 버렸다. 유독 2021년은 마더 테레사의 마음으로 많이 울고, 많이 품고, 있는 사랑 없는 사랑 다 꺼내서 보듬어야만 편해질 수 있는 날들이 좀 많았던 것 같다. default: busy 어느 순간부터 바쁘다는 이야기를 입과 손끝에 달고 사는 것 같아서 최대한 이 단어를 사용하지 않기 위해 노력하는 중이다. 이런 노력에도 불구하고 2021년은 내내 바쁘고, 바쁘고, 바빴다고밖에 표현할 수 없다는 게 조금은 서글프다. 회사 신규 프로젝트만 두 개(물론 기존 업무는 그대로)에, 동아리 활동까지 병행한다고 몸이 남아나질 않았다. 내 실력이 좋았다면 이렇게까지 슬프진 않았을 거라는 생각에 알게 모르게 현타도 많이 느꼈다. 그래도 1.5마리 토끼는 잡았으니 불행 중 다행! 신규 프로젝트를 두 개나요? 저 혼자요? 네, 혼자요. 첫 번째 프로젝트는 그나마 나까지 두 명. 두 번째 프로젝트는 정말 오롯이 혼자. 이제 와서 하는 이야기지만, 많이 힘들고 괴로웠다. 잘못한 게 없는데 혼나고, 왜 혼나는지도 모르고 혼나고… 치욕스러워 울고, 억울해서 울고, 어려워서 울고, 힘들어서 울고… 글을 적다 보니 재택 근무 중 내가 너무 답답하고 바보 같아서 그대로 침대에 누워 엉엉 울었던 순간이 문득 떠오른다. 어차피 미래의 내가 해야 하는 일이었고, 해내지 못하리란 생각은 없었지만… 그땐 그냥 졌다. 때론 다 내려놓고 지는 게 추진력을 얻기 위한 방법이 되기도 하니까. 결론적으로 해냈으니(그것도 꽤나 잘) 됐다. 두 번째 토끼, 매시업 내 마음속 첫 번째 토끼이나, 현실적인 이유로 늘 두 번째 토끼가 되고 말아 늘 미안하고 고마운 마음 뿐이다. 부족한 실력임에도(물론 성장하곤 있다지만) 친절하게 알려주고, 도와주는 친구들이 있어 이만큼 버틸 수 있었다. 바쁜 건 내 사정이기에, 최소한 피해는 주지 않으려 많이 노력했지만 노력한 만큼의 아웃풋이 나오지 않아 더 미안하고 속상했다. 계속 하고 싶었지만 그럴 수 없었던 것 10기 팀 토닥토닥에서 만든 속닥속닥은 계속 갖고 가고 싶은 프로젝트였지만 그러지 못했다. 과중한 업무로 인한 야근으로 시간을 내기 어려웠고, 와중에 다음 기수까지 시작되어 이 프로젝트를 지속하는 것은 무리라는 생각이 들었다. 너무나도 귀여운 디자인과 많은 애정을 갖고 만든(기여도가 그리 높진 않았지만…) 프로젝트인 만큼 놓기가 어려웠다. 마음이 애려요. ㅠ_ㅠ 끝까지 해내려 노력했던 것 11기 팀 헬타버스의 헬시업은 생각보다 복잡해저버린 유저 시나리오로 인해 꽤 잦은 회의를 했던 것 같다. 개발 중에 이상한 게 생기면 당일 회의도 했었고, 또 각 파트끼리도 많은 이야기를 나눈 프로젝트였다. 초반에 비해 프로젝트 마무리 단계에서의 흥미가 많이 사라졌던 점이 가장 아쉽다. 목표했던 기여도(50%)에 미치진 못했지만 그래도 '내가 할 수 있는 일’을 했다는 뿌듯함을 느꼈고, 내 업무의 의미를 깨우친 계기가 되어 나에게 큰 의미가 되었다. 다음 기수에 볼 수 없는 친구들이 있다는 걸 조금 일찍 알았다면 더 좋았을 거다. 아마 나는 그 친구들을 종종 생각할 거야. (갑자기 분위기 고백) 어? 취미의 상태가? 역시 사람이 바쁘면 취미에 투자하는 시간부터 줄어드나 보다. 2019년 말에 미쳐 있었던 메이플 스토리는 확실하게 보내 버렸고, 20년 초에 찍먹했던 로스트아크도 조금 하다가 말았다. 그나마 남은 게 롤? 꽤나 진심으로 몇 달을 했던 것 같은데, 이마저도 연말엔 손도 못 댔다. 운동도 마찬가지다. 사회적 거리두기와의 밀고 당기기 덕분에 헬스장 운영 시간이 하루가 멀다하고 들쑥날쑥했고, 연초에 발목을 크게 접지른 덕분에 흥미를 잃었으며, 불가능해진 정시 퇴근으로 인해 운동 시간을 내기가 어려웠다. 설령 시간이 난다 한들 갈 힘이 없었다. 모든 힘을 다 쏟고 왔는데 무슨 힘으로 운동을 해요! 그래서 더 방에 처박혔나 보다. 넷플릭스와 유튜브를 반복하며 문화 생활을 즐겼다. 가장 기억에 남는 드라마는 선배, 그 립스틱 바르지 마요 와 그냥 사랑하는 사이 를 꼽겠다. 둘 다 원진아 배우가 주연으로 나온 작품인데, 그 립스틱 바르지 말라는 드라마 보다가 원진아의 매력에 스며들어 그런 것임! (실제로 그냥 사랑하는 사이 가 추천 영상으로 떴을 때 주연이 원진아라는 이유로 주저않고 선택했다.) 그나마 취미다운 취미로 남은 건 보컬. 만 2년을 꼬박 채웠다. 회사 일이 너무 바빠 한 달 정도 쉬었던 것 빼고는 거의 매 주 1시간씩 수업에 참여하고 있다. 아직 많이 부족하지만 이전에 비하면 양반이지. 너무 오래 다녀서 선생님이 징그럽다고 하셨다. (애정 섞인 징그러움이라고 믿을게요…?) 하면 할수록 실력이 늘긴 늘어서 신기하고, 욕심나고, 더 잘하고 싶다. _ 가장 큰 이벤트 이사. 드디어 이사. 몇 년 전부터 이야기만 나오던 이사를 2021년 12월 15일!!! 드디어 했다. 10년 묵은 짐 버린다고 고생도 많이 했고, 와서도 정리한다고 한참을 괴로워했다. 이삿날이 수요일이라 휴가 쓰기도 애매하고, 또 이사 있던 주 주말에는 해운대 여행 간다고 정신이 하나도 없었던 건 함정이다. 짐 정리도 안 됐는데 짐을 챙겨서 가려니 정신이 하나도 없었지만 그때 본 바다가 아직도 눈앞에 아른거린다. 바다 최고야, 늘 짜릿해. 회고를 마무리하며 이 회고가 쓰여져야 했던 건 21년 12월 31일, 회고 아웃라인 작성은 22년 1월 1~2일, 회고 초안 작성은 22년 3월 1일, 그리고 코로나 확진으로 인해 회고 업로드는 오늘(22년 3월 9일)이 되었다. 집에만 있으래서 집에만 있었는데 집에서 걸린 건 그냥 운이 없었다고밖에 생각되지 않는다. 2022년을 시작하며 스물이 떠올랐다. 나는 과연 그때보다 더 나은 사람일까. 그리고 곧 다가올 마흔이 두려워졌다. 그땐 지금보다 더 많은 것을 이루고, 많은 것을 알고 싶다는 욕심 때문이겠지. 가장 먼저, 운동 놓지 않고 꾸준히 하기를 꼽고 싶다. 운동으로 얻은 이점이 많아. 잠깐 쉴 수는 있겠지만 그만두지 않았으면 한다. 노래, 책, 운동은 올해도 안고 가는 걸로. 약간의 욕심을 부리자면 오토 트레이딩 시스템을 만들어 보고 싶기는 한데… 블로그 리뉴얼을 먼저 끝내고 꾸준히 포스팅하는 게 우선이라고 봅니다. 안드로이드 개발 실력은 지금보다 150% 올리고 싶습니다. (주관적인 수치 주의) 운동을 안 놓고 하긴 했다. 노래는 꾸준히 했고, 책은 많이 줄었지만 그래도 보긴 봤다. 오토 트레이딩 시스템은 생각만으로 그쳤고, 블로그 리뉴얼은 마무리하긴 했는데 적용하지 못했고, 포스팅도 꽤 많이 하긴 했으나 만족스럽진 못했다. (그래도 이전 포스팅에 비해 수준이 약간은 올라간 느낌이라 기분은 좋음) 개발 실력은 많이 늘었다. 고생한 만큼 늘었다. 대충 7점 만점에 4점 정도네. 올해 목표는 작년보다 심플하다. 작년보다 조금 더 여유롭고, 건강하고, 기초를 탄탄히 하는 해가 되었으면 한다. 욕심 대신 순간을 소중하게 여기고, 나에게 주어진 기회들과 행복을 누리는 한해가 되길. 어떤 선택을 하든 내가 최우선이 되었으면 하는 바람으로, 올해의 첫곡으로 비투비의 Dreamer 를 선정했다. Ey listen up Do what you wanna do It’s your life Dreamers don’t die Do what you wanna do 다 마음대로 해 네 마음대로 (다 마음대로 해 어때) 하고 싶은 대로 해 좋은 날에 (하고 싶은 대로 okay) 우린 아직도 꿈을 꾸고 가슴이 뜨겁게 뛰는 걸 I mean feel your heartbeat oh my baby Do what you wanna do 오늘따라 하늘이 높네 기분도 날아갈 듯해 (watcha wanna do, wanna do) 상쾌한 내음 한 모금해 뭐라도 해야 할 듯해 (watcha wanna do) Um wanna do do 어쩐지 하나도 두렵지 않음 Let’s do it do it dreams come true 앞이 보이지 않고 세상이 휘청거려도 힘차게 we need to be stronger oh baby 뜻대로 되지가 않고 자꾸 어긋난대도 흘러가는 시간을 타고 Do what you wanna do 다 마음대로 해 네 마음대로 (다 마음대로 해 어때) 하고 싶은 대로 해 좋은 날에 (하고 싶은 대로 okay) 우린 아직도 꿈을 꾸고 가슴이 뜨겁게 뛰는 걸 I mean feel your heartbeat oh my baby Do what you wanna do 지금 시작해도 절대 안 늦었어 it’s not too late (it’s never too late) 누가 뭐라 해도 do what you wanna do it’s ok (everything gonna be ok) 네 인생이니까 take control (take control) Right left forward back yeah wherever you wanna go (wherever) Do what you have to do until you can do what you wanna do 네 자신을 믿고 don’t be afraid (hey) 앞이 보이지 않고 세상이 휘청거려도 힘차게 we need to be stronger oh baby You’re the star of your life 아무도 대신 못 해 영원히 다시 오지 않을 이 밤을 위하여 Do what you wanna do 다 마음대로 해 네 마음대로 (다 마음대로 해 어때) 하고 싶은 대로 해 좋은 날에 (하고 싶은 대로 okay) 우린 아직도 꿈을 꾸고 가슴이 뜨겁게 뛰는 걸 I mean feel your heartbeat on my baby Do what you wanna do Do what you wanna do Do what you wanna do 다 마음 가는 대로 해 어때 모든 마음대로 하고 싶은 대로 해 okay Let’s do it do it do it 미치고 싶고 숨쉬고 싶고 아직도 난 꿈꾸고 싶어 아직도 난 아직도 찬란히 빛나고 있어 okay Do what you wanna do Do what you wanna do 다 마음 가는 대로 해 어때 모든 마음대로 하고 싶은 대로 해 okay Let’s do it do it do it 미치고 싶고 숨쉬고 싶고 아직도 난 꿈꾸고 싶어 아직도 난 아직도 찬란히 빛나고 있어 okay Whatever you want Do it 2022.03.01 현재까지도 남아 있는 짐덩이가 아주 많다. ↩︎","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Diary","slug":"Anything/Diary","permalink":"https://d2fault.github.io/categories/Anything/Diary/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://d2fault.github.io/tags/%ED%9A%8C%EA%B3%A0/"}]},{"title":"[Android] SDK를 어떻게 설계하고 개발했는가","slug":"20211031-how-to-architect-android-sdk","date":"2021-10-31T13:01:54.000Z","updated":"2024-01-03T14:01:13.917Z","comments":true,"path":"2021/10/31/20211031-how-to-architect-android-sdk/","link":"","permalink":"https://d2fault.github.io/2021/10/31/20211031-how-to-architect-android-sdk/","excerpt":"안드로이드 SDK를 기획, 설계, 개발, 테스트한 썰 푼다.","text":"개요 기존에 내가 하던 업무는 하이브리드 앱 개발을 위한 API를 설계하고, 제공하는 것이었다. 어쨌거나 유지보수이기 때문에 일은 늘 비슷했다. (어떻게든 구조를 개선해 보고자 노력했지만 혼자만의 노력이었다는 후문이^_ㅠ) 그러던 중 굉장히 갑작스럽게 SDK를 기획, 설계, 개발, 테스트까지 해야 하는 상황이 되었다. 그것도 상반기에 하나, 하반기에 하나 총 두 건이나… 유경험자나 인력은 당연히 없었기 때문에 바닥부터 시작해야 했다. 그래서 이 글은, SDK를 위해 북도 치고 장구도 친 삽질기이다. 설계부터 막막해요 안드로이드 개발자라면 새로운 프로젝트 설계 시 이미 만들어진 패턴(MVC, MVP, MVVM 등) 중 프로젝트에 적합한 패턴을 적용한다. 그리고 나 또한, 첫 번째 SDK를 설계할 때 MVVM 패턴을 적용하고자 했다. 결론은, “어떻게 저떻게 돌아는 가지만 이게 최선일까?” 의 SDK가 되고 말했다. 구조 설계에만 꽤 오랜 시간(약 1.5달)을 썼는데도 불구하고 왜 이런 결과물이 산출되었을까? 내가 제공하고자 하는 SDK의 기능이 MVVM 패턴과 똑 떨어지지 않았기 때문이다. 첫 번째 SDK 설계하기 이 SDK의 경우 특히 ‘통신’ 부분에 신경을 써야 했다. 요구 조건은 다음과 같다. 이 SDK는 커스텀 웹뷰를 제공한다. 웹뷰에 URL을 load하는 것은 SDK이다. (SDK에서 loadUrl을 호출한다. 네이티브 앱은 WebView를 import만 함.) 웹뷰에 load된 웹 사이트는 SDK가 제공하는 API를 호출하고, 응답을 받아야 한다. 단말 내에 설치된 다른 앱과 Intent로 통신해야 한다. 특정 API의 경우 서버와 통신해야 하며, 그 결과를 웹에게 전달해야 한다. SDK에 붙은 화살표가 무려 세 개! 이 구조에서 MVVM이라, 거의 우겨넣은 것과 다름이 없었다. 어쨌거나 기존 구조에서 사용하든 무한 callback 대신, ViewModel에 정의해 둔 LiveData의 값을 바꾸어 호출에 따른 응답을 전달하도록 구조를 개선한 것은 꽤 의미있는 시도였다. 그러나 이것도 LiveData대신 RxJava를 사용하는 것이 더 낫지 않았을까 싶다. 두 번째 SDK 설계하기 이 SDK의 경우 최근에 설계하고 개발 중인 건으로 디테일한 정보를 오픈할 수는 없지만, 간략하게나마 요구 조건을 살펴보자. Native App은 하고자 하는 동작을 함수로 호출할 수 있다. SDK는 이미 설치된 다른 여러 앱들과 Intent로 통신한다. SDK는 호출된 함수의 결과를 callback으로 전달해 주어야 한다. 추후 init key check 과정이나 로깅이 필요할 경우, 서버와 통신해야 할 수도 있다. 두 번째 SDK의 특징은 어떠한 View도 제공하지 않는다는 것이다. 흔히 사용하는 패턴을 적용할 수 없었기에 내맘대로 구조를 잡고 패키지를 분리했다. Native App에서 호출하는 함수가 담긴 class는 service 패키지에, 상수는 constants 패키지에, Intent receiver는 receiver 패키지에 위치시켰다. 그런데 Native App에게 이 기능을 '어떻게 제공’해야 하는지는 아무리 고민해도 결론이 안 났다. 난관에 봉착했다. 힌트 찾아 삼만리 보통 SDK는 aar 형태로 배포하기 때문에 타인의 코드를 참고하는 게 쉽지 않다. 이가 없으면 잇몸이라고, 순간적으로 모두에게 열려 있는 도큐먼트가 떠올랐다. 유레카! 역시 답은 카카오 API 가이드 문서에 있었다. LinkClient.instance.isKakaoLinkAvailable(context) 과 LinkClient.instance.customTemplate(context, templateId) 를 보고 머리를 탁 쳤…지만 코틀린 조무래기 입장에서는 저 형태를 어떻게 만들어내야 할지도 고민이었다. 그 순간 갑자기 매셥 안드팀의 점냥(재료)님이 떠올랐습니다. ^^ (늘 이렇게 고민하는 상황이 되면 누군가를 붙잡고 이야기를 막 쏟아내는데 그러다 보면 답이 나와서 신기하다. 되도 않는 이야기 늘 들어주시는 주변 분들께 감사를 전합니다.) 카카오 API 도큐먼트와 점냥님의 도움으로 SDK 제공 부분까지 설계할 수 있었다. (번외) 이 값은 숨기고 싶은데? SDK를 포함한 테스트 앱 개발 중 SDK에서만 사용하고 싶은 함수나 값들이 테스트 앱에서도 접근이 되는 것을 확인했다. 테스트 앱에서 접근을 막으려면 public 도, private 도 아닌 그 사이의 접근 제어자가 필요했는데 코틀린이 이걸? internal 을 사용하니 모든 게 깔끔하게 해결됐다. 예를 들어, class 생성시 internal 을 붙이면 해당 class는 같은 모듈(SDK) 에서만 접근이 가능하다. 아직까진 Java가 더 익숙하기에 Java로 개발했으면 어떻게 설계했을까 생각해 보았는데, class 내에 protected 를 열심히 선언해 주지 않았을까 싶다. (그런데 class 전체를 숨기고 싶을 땐 어떻게 해야 하지? Java 눈 감아) 무엇을 느꼈나요? 두 SDK를 직접 기획, 설계, 개발, 테스트까지 도맡아 하며 알게 모르게 실력이 향상되었나 보다. 처음으로 SDK 설계할 땐 “아직 4년차인데 내가 할 수 있을까?” 라는 생각이 지배적이었다면, 두 번째는 구조부터 떠올랐을 정도의 성장이랄까. 이번 개발 건으로 SDK에 흥미를 느꼈고, 기왕이면 이 커리어를 계속 갖고 가고 싶다는 생각을 했다. 그리고 무엇보다, 유저 친화적인 설계를 위해 노력한 내 자신 칭찬해. 사용하는 입장에서 제공하는 입장이 되어 보니 카카오가 SDK를 리뉴얼한 이유를 깨달았다. 사용할 땐 '아, 수정 개발 귀찮게! 카카오는 이걸 왜 다 바꾼 거야?'의 스탠스였다면, 지금은 부정적인 반응을 예상했음에도 불구하고 과감하게 뒤엎은 카카오를 리스펙한다. 더 멀리, 더 오래 가기 위한 결단이었겠지. (사실, 네이버가 아닌 카카오 API 도큐먼트를 참고한 이유도 리뉴얼 사실을 알고 있었기 때문이다. ^^;) 아쉬운 건, 함께 논의할 사람이 없다는 점이다. 다행스럽게도 주변에 안드로이드 개발자가 많아서(매셥 짱!) 궁금한 게 생길 때마다 함께 답을 찾아가곤 있지만 아무래도 업무이다 보니 디테일한 내용을 공유할 수는 없었다. 머리 맞대고 함께 성장할 사람이 있으면 좋겠다. 혹은 사수라도. 마지막으로, 디자인 패턴에 대해 열린 마음을 가지게 되었다. 패턴이라고 할 게 없는 앱을 유지보수하며 늘 패턴에 목말라 있었다. 지금에 와서 생각해 보면, 다들 사용하는 것을 사용하지 않는 것에 대한 불안감 때문이 아니었나 싶다. MVVM을 적용해 보고 그에 어긋나는 부분을 발견하며 이것이 최선이 아님을 몸소 깨닫다 보니 패턴은 만능이나 절대적인 게 아닌 취사선택의 대상임이 더욱 확실해졌다. 때로는 구글에서 제안한 아키텍쳐보다 내가 고안(?)한 아키텍쳐가 더 나을 수 있음을…! 마무리하며 하고 싶은 말은 많았지만 막상 업무에 직결되는 이야기를 덜어내니 공유할 수 있는 내용이 별로 없어서 아쉽다. 요즘은 1차 릴리즈 목표치의 70% 정도 개발을 완료해 두었고, 테스트 앱을 만들고 있다. 이용 가이드도 직접 만들어야 하기 때문에 할 일이 태산이긴 하지만 그래도 4년차에 SDK 개발을 리딩(?)한 커리어가 흔한 커리어는 아니라는 생각으로 즐겁게 개발하고 있다. 그리고 무엇보다, 팀 내 최초 Kotlin 프로젝트를 생성했다는 것만으로도 뿌듯하고 감격스럽다. 이 시도로 kotlin과 많이 친해졌다. 초기 코드와 지금 코드를 비교하면 엄청난 변화를 느낄 수 있다고요! 어제 짠 코드가 오늘 부끄럽다면 잘하고 있다는 거니까. (요새는 범위 지정 함수와 확장 함수를 눈여겨보는 중이다. 아직까진 kotlin 코드에서 Java가 느껴져요. ㅠ)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://d2fault.github.io/categories/Programming/Android/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://d2fault.github.io/tags/kotlin/"},{"name":"android","slug":"android","permalink":"https://d2fault.github.io/tags/android/"},{"name":"sdk","slug":"sdk","permalink":"https://d2fault.github.io/tags/sdk/"},{"name":"architect","slug":"architect","permalink":"https://d2fault.github.io/tags/architect/"}]},{"title":"[Android] Fullscreen(Full Window, 전체 화면) Custom Dialog 만들기","slug":"20210829-fullscreen-custom-dialog","date":"2021-08-29T14:01:35.000Z","updated":"2024-01-03T14:01:13.914Z","comments":true,"path":"2021/08/29/20210829-fullscreen-custom-dialog/","link":"","permalink":"https://d2fault.github.io/2021/08/29/20210829-fullscreen-custom-dialog/","excerpt":"이번 포스팅에서는 전체 화면으로 Dialog를 띄우는 방법에 대해 알아볼 것이다. 전체 화면으로 동작하는 Dialog를 만드는 방법으로는 크게 두 가지가 있다.","text":"개요 이번 포스팅에서는 전체 화면으로 Dialog를 띄우는 방법에 대해 알아볼 것이다. 전체 화면으로 동작하는 Dialog를 만드는 방법으로는 크게 두 가지가 있다. Dialog처럼 보이는 Activity를 만들어 띄우기 Dialog를 Customizing하여 Fullscreen으로 띄우기 둘 중 어떤 것이 베스트라고 할 수는 없지만, 기왕이면 '다이얼로그’라는 이름답게 2번 방식을 따라 보기로 했다. 최초 작성 코드 언어는 java였으나 kotlin으로 변경하였고, findViewById 대신 ViewBinding 을 적용하였다. 완성본 미리 보기 SHOW DIALOG 버튼 클릭시 Fullscreen으로 동작하는 Dialog가 출력되고, SUBMIT/CANCEL 버튼 클릭 이벤트와 동시에 Toast가 출력되는 예제 앱이다. 코드 작성 MyCustomDialog 라는 이름의 Project를 empty activity로 생성하고, build.gradle 에 viewBinding 사용 선언을 우선 해 주어야 한다. build.gradle123456android &#123; ... viewBinding &#123; enabled = true &#125;&#125; app 수준의 build.gradle 에 위 코드를 추가하고 sync 버튼을 눌러 준다. 레이아웃 작업하기 activity_main.xml 파일 정 가운데에 SHOW_DIALOG 버튼을 생성한다. activity_main.xml1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;Button android:id=&quot;@+id/showDialogButton&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;SHOW DIALOG&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; tools:ignore=&quot;HardcodedText&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; dialog_full_activity.xml 파일을 res/layout 에 생성한 다음 아래 코드를 넣어 준다. dialog_full_activity.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#E6003049&quot;&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:padding=&quot;20dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;1.0&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintVertical_bias=&quot;0.0&quot;&gt; &lt;TextView android:id=&quot;@+id/titleTextView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginBottom=&quot;21dp&quot; android:lineSpacingExtra=&quot;4sp&quot; android:textColor=&quot;#ee6c4d&quot; android:textSize=&quot;16.5sp&quot; app:layout_constraintBottom_toTopOf=&quot;@id/messageTextView&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; tools:text=&quot;@string/default_dialog_title&quot; /&gt; &lt;TextView android:id=&quot;@+id/messageTextView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:lineSpacingExtra=&quot;4sp&quot; android:textColor=&quot;#FFFFFF&quot; android:textSize=&quot;22.5sp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; tools:text=&quot;@string/default_dialog_message&quot; /&gt; &lt;Button android:id=&quot;@+id/submitButton&quot; android:layout_width=&quot;138dp&quot; android:layout_height=&quot;0dp&quot; android:layout_marginTop=&quot;30dp&quot; android:layout_marginEnd=&quot;3.75dp&quot; android:backgroundTint=&quot;#012a4a&quot; android:letterSpacing=&quot;-0.05&quot; android:lineSpacingExtra=&quot;1.3sp&quot; android:text=&quot;@string/default_dialog_submit_caption&quot; android:textColor=&quot;#ffffff&quot; android:textSize=&quot;13.5sp&quot; app:layout_constraintEnd_toStartOf=&quot;@id/cancelButton&quot; app:layout_constraintHorizontal_chainStyle=&quot;packed&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/messageTextView&quot; app:layout_constraintVertical_chainStyle=&quot;packed&quot; /&gt; &lt;Button android:id=&quot;@+id/cancelButton&quot; android:layout_width=&quot;138dp&quot; android:layout_height=&quot;0dp&quot; android:layout_marginStart=&quot;3.75dp&quot; android:layout_marginTop=&quot;30dp&quot; android:backgroundTint=&quot;#012a4a&quot; android:letterSpacing=&quot;-0.05&quot; android:lineSpacingExtra=&quot;1.3sp&quot; android:text=&quot;@string/default_dialog_cancel_caption&quot; android:textColor=&quot;#ffffff&quot; android:textSize=&quot;13.5sp&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toEndOf=&quot;@+id/submitButton&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/messageTextView&quot; /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 이대로 실행할 경우 error가 발생한다. strings.xml 에 필요한 값이 누락되어 있기 때문이다. res/values/strings.xml 파일을 다음과 같이 수정해 보자. strings.xml123456789&lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;MyCustomDialog&lt;/string&gt; &lt;!-- Fullscreen custom dialog --&gt; &lt;string name=&quot;default_dialog_title&quot;&gt;다이얼로그 타이틀&lt;/string&gt; &lt;string name=&quot;default_dialog_message&quot;&gt;다이얼로그 메시지&lt;/string&gt; &lt;string name=&quot;default_dialog_submit_caption&quot;&gt;확인&lt;/string&gt; &lt;string name=&quot;default_dialog_cancel_caption&quot;&gt;취소&lt;/string&gt;&lt;/resources&gt; 모든 레이아웃 작업이 간단히 끝났다. CustomDialogMaker 생성하기 CustomDialogMaker는 object로, Fullscreen Dialog를 쉽게 생성할 수 있도록 만들어 주는 일종의 유틸이다. getDialog 를 통해 어느 곳에서나 Custom Dialog 내 text를 수정하여 출력하는 기능을 제공한다. 우선, CustomDialogMaker.kt 에서 확인 버튼과 취소 버튼 각각의 이벤트를 전달할 수 있도록 interface 를 생성하자. CustomDialogListener.kt1234interface CustomDialogListener &#123; fun onClickSubmitButton() fun onClickCancelButton()&#125; 각 버튼의 클릭 이벤트가 들어왔을 때 각각 이벤트에 따라 위 작성된 interface 를 target으로 실질적 구현부(ex-Activity)에서 이벤트를 수신하도록 했다. 말로 풀어 쓰니 어려운데, 아래 코드(CustomDialogMaker.kt)를 확인하자. CustomDialogMaker.kt12345678910111213141516171819202122232425262728293031object CustomDialogMaker &#123; fun getDialog( context: Context, title: String, message: String, submitCaption: String, cancelCaption: String, target: CustomDialogListener ) &#123; val dialog = Dialog(context, R.style.FullWindowDialog) val dialogBinding = DialogFullActivityBinding.inflate(dialog.layoutInflater) dialog.setContentView(dialogBinding.root) dialogBinding.titleTextView.text = title dialogBinding.messageTextView.text = message dialogBinding.submitButton.text = submitCaption dialogBinding.cancelButton.text = cancelCaption dialogBinding.submitButton.setOnClickListener &#123; target.onClickSubmitButton() dialog.dismiss() &#125; dialogBinding.cancelButton.setOnClickListener &#123; target.onClickCancelButton() dialog.dismiss() &#125; dialog.show() &#125;&#125; CustomDialogMaker.getDialog(인자) 로 호출할 때, 이것을 호출한 곳에서 onClickSubmitButton(), onClickCancelButton() 이벤트를 처리하도록 한 코드이다. findViewById 대신 viewBinding 을 이용하여 코드를 경량화하였다. MainActivity 수정하기 MainActivity.kt 파일에서는 ViewBinding 대신 findViewById 를 이용하여 showDialogButton 에 onClickListener 를 추가하였고, 버튼 클릭시 Dialog 가 출력되도록 코드를 작성하였다. MainActivity.kt1234567891011121314151617181920212223242526class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val showDialogButton = findViewById&lt;Button&gt;(R.id.showDialogButton) showDialogButton.setOnClickListener &#123; CustomDialogMaker.getDialog( this, &quot;title&quot;, &quot;message&quot;, &quot;submit&quot;, &quot;cancel&quot;, object : CustomDialogListener &#123; override fun onClickSubmitButton() &#123; Toast.makeText(applicationContext, &quot;SUBMIT!&quot;, Toast.LENGTH_SHORT).show() &#125; override fun onClickCancelButton() &#123; Toast.makeText(applicationContext, &quot;CANCEL!&quot;, Toast.LENGTH_SHORT).show() &#125; &#125;) &#125; &#125;&#125; 위 예시와 같이 CustomDialogMaker.getDialog(values..) 를 통해 CustomDialog 를 손쉽게 가져다 사용할 수 있었다. 마무리하며 위 형태가 베스트 케이스인지에 대해선 확신이 없으나, Custom Dialog의 전반적인 Layout은 유지하고 싶으나 Button의 text나 title, message의 변경이 필요할 때 사용하기 위해 작성하였다. dialog builder를 이용하여 생성하는 방법이 가장 쉬우나, 그 경우에는 fullscreen을 어떻게 세팅해 주어야 할지 감이 오지 않았다. 혹, 이 글을 읽는 분들 중 dialog builder를 이용해 fullscreen을 설정하는 방법을 아는 분이 계신다면 댓글로 아이디어 공유 부탁드립니다. 전체 코드는 github repository 에 업로드하였다. java/kotlin 두 가지 버전으로 작성하였으며, branch를 이동하여 확인할 수 있다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://d2fault.github.io/categories/Programming/Android/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://d2fault.github.io/tags/kotlin/"},{"name":"android","slug":"android","permalink":"https://d2fault.github.io/tags/android/"},{"name":"java","slug":"java","permalink":"https://d2fault.github.io/tags/java/"},{"name":"customdialog","slug":"customdialog","permalink":"https://d2fault.github.io/tags/customdialog/"},{"name":"fullscreen","slug":"fullscreen","permalink":"https://d2fault.github.io/tags/fullscreen/"}]},{"title":"[Android] AudioFocus 알아보기(2) - 커스텀과 확장","slug":"20210726-android-audio-focus-2","date":"2021-07-26T12:56:55.000Z","updated":"2024-01-03T14:01:13.913Z","comments":true,"path":"2021/07/26/20210726-android-audio-focus-2/","link":"","permalink":"https://d2fault.github.io/2021/07/26/20210726-android-audio-focus-2/","excerpt":"지난 포스트 에서 작성한 코드인 AudioFocusHelper.java 에 약간의 기능을 덧붙이고, Build.VERSION_CODES.O 미만인 단말에서도 동작할 수 있도록 수정해 볼 것이다. 말은 거창하지만 그리 많이 수정할 예정은 아니다.","text":"개요 지난 포스트 에서 작성한 코드인 AudioFocusHelper.java 에 약간의 기능을 덧붙이고, Build.VERSION_CODES.O 미만인 단말에서도 동작할 수 있도록 수정해 볼 것이다. 말은 거창하지만 그리 많이 수정할 것은 아니다. 무엇을 수정할 것인가 우선, AudioFocus 가 Build.VERSION_CODES.O 미만인 단말에서도 잘 동작해야 하기 때문에 이 부분의 코드를 고쳐보려 한다. 그전에, 지난 포스팅에서 작성한 코드에 TODO를 먼저 붙여 보자. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class AudioFocusHelper implements AudioManager.OnAudioFocusChangeListener &#123; private static final String TAG = AudioFocusHelper.class.getSimpleName(); private static AudioManager audioManager; private static AudioFocusRequest audioFocusRequest; public AudioFocusHelper(@Nonnull Context context) &#123; Log.d(TAG, &quot;Create AudioFocusHelper&quot;); // TODO: 1. Build.VERSION_CODES.O 미만인 단말에서의 생성자 세팅 추가 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE); AudioAttributes mAudioAttributes = new AudioAttributes.Builder() .setUsage(AudioAttributes.USAGE_MEDIA) .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC) .build(); audioFocusRequest = new AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN) .setAudioAttributes(mAudioAttributes) .setAcceptsDelayedFocusGain(true) .setOnAudioFocusChangeListener(this) .setWillPauseWhenDucked(true) .build(); &#125; &#125; public void requestAudioFocus() &#123; Log.d(TAG, &quot;AudioFocus &gt;&gt; called requestAudioFocus() / Build.VERSION: &quot; + Build.VERSION.SDK_INT); // TODO: 2. Build.VERSION_CODES.O 미만 단말에서의 AudioFocus Request 기능 추가 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; Log.d(TAG, &quot;AudioFocus &gt;&gt; requestAudioFocus&quot;); audioManager.requestAudioFocus(audioFocusRequest); &#125; &#125; // TODO: 3. abandonAudioFocus() function 추가 @Override public void onAudioFocusChange(int focusChange) &#123; switch (focusChange) &#123; case AudioManager.AUDIOFOCUS_GAIN: // 이제부터 AudioFocus는 우리 앱의 소유! Log.d(TAG, &quot;AudioFocus &gt;&gt; AUDIOFOCUS_GAIN&quot;); break; case AudioManager.AUDIOFOCUS_GAIN_TRANSIENT: // 일시적으로 AudioFocus를 가져온다. Log.d(TAG, &quot;AudioFocus &gt;&gt; AUDIOFOCUS_GAIN_TRANSIENT&quot;); break; case AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK: // 15초 이상 점유하면 안 된다. 앱의 소리가 나지만, Background App의 사운드가 작게 들릴 수 있다. Log.d(TAG, &quot;AudioFocus &gt;&gt; AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK&quot;); break; case AudioManager.AUDIOFOCUS_LOSS: Log.d(TAG, &quot;AudioFocus &gt;&gt; AUDIOFOCUS_LOSS&quot;); break; case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT: // 일시적인 LOSS로, 잠깐 사용한 App이 점유를 끝내면 가장 마지막에 GAIN한 App이 AudioFocus를 점유한다. Log.d(TAG, &quot;AudioFocus &gt;&gt; AUDIOFOCUS_LOSS_TRANSIENT&quot;); break; case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK: // 볼륨을 낮추는 것을 권장한다. Log.d(TAG, &quot;AudioFocus &gt;&gt; AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK&quot;); break; case AudioManager.AUDIOFOCUS_REQUEST_FAILED: // 요청 실패할 경우의 로직을 추가한다. Log.d(TAG, &quot;AudioFocus &gt;&gt; AUDIOFOCUS_REQUEST_FAILED&quot;); break; &#125; &#125;&#125; 1번부터 3번까지의 TODO를 추가해 보았다. 1번부터 천천히 수정해 보자. 1. Build.VERSION_CODES.O 미만인 단말에서의 생성자 세팅 추가 이 코드는 아주 간단하다. Build.VERSION_CODES.O 미만인 단말에서는 AudioManager 생성만 해 주면 된다. 그래서 별도의 else 처리 없이, if 문 안에 있던 AudioManager 를 밖으로 빼 준다. 123456789101112131415161718public AudioFocusHelper(@Nonnull Context context) &#123; Log.d(TAG, &quot;Create AudioFocusHelper&quot;); // 이렇게 위로 빼 주면 됨 audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; // audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE); AudioAttributes mAudioAttributes = new AudioAttributes.Builder() .setUsage(AudioAttributes.USAGE_MEDIA) .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC) .build(); audioFocusRequest = new AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN) .setAudioAttributes(mAudioAttributes) .setAcceptsDelayedFocusGain(true) .setOnAudioFocusChangeListener(this) .setWillPauseWhenDucked(true) .build(); &#125;&#125; 2. Build.VERSION_CODES.O 미만 단말에서의 AudioFocus Request 기능 추가 Oreo, API level 26보다 낮은 단말에서 AudioFocus 를 얻고 싶다면 다음의 코드를 사용하자. 123456789public void requestAudioFocus() &#123; Log.d(TAG, &quot;AudioFocus &gt;&gt; called requestAudioFocus() / Build.VERSION: &quot; + Build.VERSION.SDK_INT); // TODO: 2. Build.VERSION_CODES.O 미만 단말에서의 AudioFocus Request 기능 추가 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; audioManager.requestAudioFocus(audioFocusRequest); &#125; else &#123; audioManager.requestAudioFocus(this, AudioManager.USE_DEFAULT_STREAM_TYPE, AudioManager.AUDIOFOCUS_GAIN); &#125;&#125; requestAudioFocus(OnAudioFocusChangeListener l, int streamType, int durationHint) 형태를 따라 적절한 값을 넣어 주면 된다. 3. abandonAudioFocus() function 추가 앞서 우리는 AudioFocus 를 요청만 했지 반납하지 않았다. 서비스가 종료되거나, 더이상의 Audio가 필요하지 않을 땐 AudioFocus 를 반납하는 것이 인지상정! 이 코드도 굉장히 짧다. 12345678public void abandonAudioFocus() &#123; Log.d(TAG, &quot;AudioFocus &gt;&gt; called abandonAudioFocus()&quot;); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; audioManager.abandonAudioFocusRequest(audioFocusRequest); &#125; else &#123; audioManager.abandonAudioFocus(this); &#125;&#125; 너무 쉽죠? 전체 코드 보기 Oreo 미만 단말에서 AudioFocus 를 요청할 수 있고, 반납 기능이 추가된 AudioFocusHelper.java 코드 전체는 다음과 같다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class AudioFocusHelper implements AudioManager.OnAudioFocusChangeListener &#123; private static final String TAG = AudioFocusHelper.class.getSimpleName(); private static AudioManager audioManager; private static AudioFocusRequest audioFocusRequest; public AudioFocusHelper(@Nonnull Context context) &#123; Log.d(TAG, &quot;Create AudioFocusHelper&quot;); audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; AudioAttributes mAudioAttributes = new AudioAttributes.Builder() .setUsage(AudioAttributes.USAGE_MEDIA) .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC) .build(); audioFocusRequest = new AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN) .setAudioAttributes(mAudioAttributes) .setAcceptsDelayedFocusGain(true) .setOnAudioFocusChangeListener(this) .setWillPauseWhenDucked(true) .build(); &#125; &#125; public void requestAudioFocus() &#123; Log.d(TAG, &quot;AudioFocus &gt;&gt; called requestAudioFocus() / Build.VERSION: &quot; + Build.VERSION.SDK_INT); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; audioManager.requestAudioFocus(audioFocusRequest); &#125; else &#123; audioManager.requestAudioFocus(this, AudioManager.USE_DEFAULT_STREAM_TYPE, AudioManager.AUDIOFOCUS_GAIN); &#125; &#125; public void abandonAudioFocus() &#123; Log.d(TAG, &quot;AudioFocus &gt;&gt; called abandonAudioFocus()&quot;); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; audioManager.abandonAudioFocusRequest(audioFocusRequest); &#125; else &#123; audioManager.abandonAudioFocus(this); &#125; &#125; @Override public void onAudioFocusChange(int focusChange) &#123; switch (focusChange) &#123; case AudioManager.AUDIOFOCUS_GAIN: // 이제부터 AudioFocus는 우리 앱의 소유! Log.d(TAG, &quot;AudioFocus &gt;&gt; AUDIOFOCUS_GAIN&quot;); break; case AudioManager.AUDIOFOCUS_GAIN_TRANSIENT: // 일시적으로 AudioFocus를 가져온다. Log.d(TAG, &quot;AudioFocus &gt;&gt; AUDIOFOCUS_GAIN_TRANSIENT&quot;); break; case AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK: // 15초 이상 점유하면 안 된다. 앱의 소리가 나지만, Background App의 사운드가 작게 들릴 수 있다. Log.d(TAG, &quot;AudioFocus &gt;&gt; AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK&quot;); break; case AudioManager.AUDIOFOCUS_LOSS: Log.d(TAG, &quot;AudioFocus &gt;&gt; AUDIOFOCUS_LOSS&quot;); break; case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT: // 일시적인 LOSS로, 잠깐 사용한 App이 점유를 끝내면 가장 마지막에 GAIN한 App이 AudioFocus를 점유한다. Log.d(TAG, &quot;AudioFocus &gt;&gt; AUDIOFOCUS_LOSS_TRANSIENT&quot;); break; case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK: // 볼륨을 낮추는 것을 권장한다. Log.d(TAG, &quot;AudioFocus &gt;&gt; AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK&quot;); break; case AudioManager.AUDIOFOCUS_REQUEST_FAILED: // 요청 실패할 경우의 로직을 추가한다. Log.d(TAG, &quot;AudioFocus &gt;&gt; AUDIOFOCUS_REQUEST_FAILED&quot;); break; &#125; &#125;&#125; 위의 코드에서 나는 OnAudioFocusChangeListener 를 implement 하여 구현하였지만, class 내에서 직접 new 로 선언해 주어도 문제가 되지 않는다. 이전 코드는 그런 형식으로 되어 있었는데, implement 하는 방식이 더 깔끔하게 구현될 것 같아서 약간의 리팩토링 과정을 거쳐 수정하였다. 아무튼, 이대로 싱겁게 이번 포스팅 끝!","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://d2fault.github.io/categories/Programming/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://d2fault.github.io/tags/android/"},{"name":"audiofocus","slug":"audiofocus","permalink":"https://d2fault.github.io/tags/audiofocus/"},{"name":"webview","slug":"webview","permalink":"https://d2fault.github.io/tags/webview/"},{"name":"java","slug":"java","permalink":"https://d2fault.github.io/tags/java/"}]},{"title":"[Android] AudioFocus 알아보기(1) - 왜, 어떻게 사용하는가","slug":"20210710-android-audio-focus-1","date":"2021-07-19T14:29:55.000Z","updated":"2024-01-03T14:01:13.912Z","comments":true,"path":"2021/07/19/20210710-android-audio-focus-1/","link":"","permalink":"https://d2fault.github.io/2021/07/19/20210710-android-audio-focus-1/","excerpt":"AudioFocus가 적용되어 있지 않은 애플리케이션에 AudioFocus를 적용해야만 하는 일이 생겼다. 지금까지는 쓸 일도, 그럴 필요도 없었기에 이 친구의 존재를 모르고 있었는데 적용할 일이 생겼으니 공부해 보자 싶었다.","text":"개요 AudioFocus가 적용되어 있지 않은 애플리케이션에 AudioFocus를 적용해야만 하는 일이 생겼다. 지금까지는 쓸 일도, 그럴 필요도 없었기에 이 친구의 존재를 모르고 있었는데 적용할 일이 생겼으니 공부해 보자 싶었다. 이번 포스팅에서는 AudioFocus를 왜 써야 하는지, 그리고 어떻게 사용해야 하는지에 대해 적어보려고 한다. AudioFocus가 뭐야? Android OS에게 “나 지금 미디어 필요해! 쓴다!” 하고 통보하는 기능으로, 일종의 약속이다. AudioFocus를 요청할 때에는 어떤 용도로 오디오를 사용하는지에 대한 정보를 함께 전달해야 한다. 용도에 대한 정보는 AudioAttributes 인스턴스 생성 후 setUseage() 와 setContentType() 를 통해 세팅할 수 있으며, 다음의 값 중 하나를 가진다. (번역은 셀프입니다. ㅎㅎ;😉 setUseage List 값 설명 USAGE_UNKNOWN Usage value to use when the usage is unknown. USAGE_MEDIA Usage value to use when the usage is media, such as music, or movie soundtracks. USAGE_VOICE_COMMUNICATION Usage value to use when the usage is voice communications, such as telephony or VoIP. USAGE_VOICE_COMMUNICATION_SIGNALLING Usage value to use when the usage is in-call signalling, such as wite a “busy” beep, or DTMF tones. USAGE_ALARM Usage value to use when the usage is an alarm (e.g. wake-up alarm). USAGE_NOTIFICATION Usage value to use when the usage is notification. See other notification usages for more specialized uses. USAGE_NOTIFICATION_RINGTONE Usage value to use when the usage is telephony ringtone. USAGE_NOTIFICATION_COMMUNICATION_REQUEST Usage value to use when the usage is a request to enter/end a communication, such as a VoIP communication or video-conference. USAGE_NOTIFICATION_COMMUNICATION_INSTANT Usage value to use when the usage is notification for an “instant” communication such as a chat, or SMS. USAGE_NOTIFICATION_COMMUNICATION_DELAYED Usage value to use when the usage is notification for a non-immediate type of communication such as e-mail. USAGE_NOTIFICATION_EVENT Usage value to use when the usage is to attract the user’s attention, such as a reminder or low battery warning. USAGE_ASSISTANCE_ACCESSIBILITY Usage value to use when the usage is for accessibility, such as with* a screen reader. USAGE_ASSISTANCE_NAVIGATION_GUIDANCE Usage value to use when the usage is driving or navigation directions. USAGE_ASSISTANCE_SONIFICATION Usage value to use when the usage is sonification, such as with user interface sounds. USAGE_GAME Usage value to use when the usage is for game audio. USAGE_ASSISTANT Usage value to use for audio responses to user queries, audio instructions or help utterances. setContentType List 값 설명 CONTENT_TYPE_UNKNOWN Content type value to use when the content type is unknown, or other than the ones defined. CONTENT_TYPE_SPEECH Content type value to use when the content type is speech. CONTENT_TYPE_MUSIC Content type value to use when the content type is music. CONTENT_TYPE_MOVIE Content type value to use when the content type is a soundtrack, typically accompanying a movie or TV program. CONTENT_TYPE_SONIFICATION Content type value to use when the content type is a sound used to accompany a user action, such as a beep or sound effect expressing a key click, or event, such as the type of a sound for a bonus being received in a game. These sounds are mostly synthesized or short Foley sounds. AudioFocus를 뺏길 땐 어떻게 해? Android는 다 계획이 있다, 이 말이야! 이 경우를 대비해서 Listener(AudioManager.OnAudioFocusChangeListener) 를 제공한다. 개발자는 이 Listener에서 처리할 수 있는 이벤트는 다음과 같다. AudioFocus Change Listener Event List Event 설명 AUDIOFOCUS_NONE Used to indicate no audio focus has been gained or lost, or requested. AUDIOFOCUS_GAIN Used to indicate a gain of audio focus, or a request of audio focus, of unknown duration. AUDIOFOCUS_GAIN_TRANSIENT Used to indicate a temporary gain or request of audio focus, anticipated to last a short amount of time. Examples of temporary changes are the playback of driving directions, or an event notification. AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK Used to indicate a temporary request of audio focus, anticipated to last a short amount of time, and where it is acceptable for other audio applications to keep playing after having lowered their output level (also referred to as “ducking”).Examples of temporary changes are the playback of driving directions where playback of music in the background is acceptable. AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE Used to indicate a temporary request of audio focus, anticipated to last a short amount of time, during which no other applications, or system components, should play anything.Examples of exclusive and transient audio focus requests are voice memo recording and speech recognition, during which the system shouldn’t play any notifications, and media playback should have paused. AUDIOFOCUS_LOSS Used to indicate a loss of audio focus of unknown duration. AUDIOFOCUS_LOSS_TRANSIENT Used to indicate a transient loss of audio focus. AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK Used to indicate a transient loss of audio focus where the loser of the audio focus can lower its output volume if it wants to continue playing (also referred to as “ducking”), as the new focus owner doesn’t require others to be silent. 어떻게 사용해? 음, Helper 라는 단어 사용을 지양해야 한다고 하는데 마땅한 단어가 떠오르지 않는다. 그래서 어쩔 수 없이 AudioFocusHelper.java class를 만들게 되었다. ^^; 필요한 곳에서 AudioFocus 를 context 와 함께 생성한다. 이후, AudioFocus 가 필요할 때 requestAudioFocus() 함수를 호출하면 깔끔하게 완성! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class AudioFocusHelper implements AudioManager.OnAudioFocusChangeListener &#123; private static final String TAG = AudioFocusHelper.class.getSimpleName(); private static AudioManager audioManager; private static AudioFocusRequest audioFocusRequest; public AudioFocusHelper(@Nonnull Context context) &#123; Log.d(TAG, &quot;Create AudioFocusHelper&quot;); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE); AudioAttributes mAudioAttributes = new AudioAttributes.Builder() .setUsage(AudioAttributes.USAGE_MEDIA) .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC) .build(); audioFocusRequest = new AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN) .setAudioAttributes(mAudioAttributes) .setAcceptsDelayedFocusGain(true) .setOnAudioFocusChangeListener(this) .setWillPauseWhenDucked(true) .build(); &#125; &#125; public void requestAudioFocus() &#123; Log.d(TAG, &quot;AudioFocus &gt;&gt; called requestAudioFocus() / Build.VERSION: &quot; + Build.VERSION.SDK_INT); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; Log.d(TAG, &quot;AudioFocus &gt;&gt; requestAudioFocus&quot;); audioManager.requestAudioFocus(audioFocusRequest); &#125; &#125; @Override public void onAudioFocusChange(int focusChange) &#123; switch (focusChange) &#123; case AudioManager.AUDIOFOCUS_GAIN: // 이제부터 AudioFocus는 우리 앱의 소유! Log.d(TAG, &quot;AudioFocus &gt;&gt; AUDIOFOCUS_GAIN&quot;); break; case AudioManager.AUDIOFOCUS_GAIN_TRANSIENT: // 일시적으로 AudioFocus를 가져온다. Log.d(TAG, &quot;AudioFocus &gt;&gt; AUDIOFOCUS_GAIN_TRANSIENT&quot;); break; case AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK: // 15초 이상 점유하면 안 된다. 앱의 소리가 나지만, Background App의 사운드가 작게 들릴 수 있다. Log.d(TAG, &quot;AudioFocus &gt;&gt; AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK&quot;); break; case AudioManager.AUDIOFOCUS_LOSS: Log.d(TAG, &quot;AudioFocus &gt;&gt; AUDIOFOCUS_LOSS&quot;); break; case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT: // 일시적인 LOSS로, 잠깐 사용한 App이 점유를 끝내면 가장 마지막에 GAIN한 App이 AudioFocus를 점유한다. Log.d(TAG, &quot;AudioFocus &gt;&gt; AUDIOFOCUS_LOSS_TRANSIENT&quot;); break; case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK: // 볼륨을 낮추는 것을 권장한다. Log.d(TAG, &quot;AudioFocus &gt;&gt; AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK&quot;); break; case AudioManager.AUDIOFOCUS_REQUEST_FAILED: // 요청 실패할 경우의 로직을 추가한다. Log.d(TAG, &quot;AudioFocus &gt;&gt; AUDIOFOCUS_REQUEST_FAILED&quot;); break; &#125; &#125;&#125; 마무리하며 필수 요건이 아닌 약속이라고 표현한 이유가 있다. 사실상 AudioFocus 를 요청하지 않아도 사운드 출력에는 문제가 없다. Android 플랫폼 생태계를 무시하고, ‘난 무조건 재생해야 해!’ 라는 억지를 부리고 싶다면 AudioFocus 없이 미디어를 출력해 버리면 된다. 혹은 AUDIOFOCUS_LOSS 이벤트를 받자마자 다시 GAIN하는 방법도 있지만, 당연히 권장하지 않는다. 플랫폼 위에 올라가는 서비스 개발자는 플랫폼의 약속을 이행하는 것이 좋다. 이 자그마한 규약들은 각각의 앱들이 최대한 ‘정상 범주’ 내에서 동작할 수 있도록 만들어졌다. AudioFocus 를 무시하고 재생하는 앱이 하나일 경우에도 문제이지만, 여러 앱이 이것을 무시하고 재생한다면 UX가 와장창 깨지고 말 것이다. 알람도 울리고, 음악도 재생되고, 또 다른 앱에서 게임 소리도 나고, 또 다른 앱에서 영상이 재생되는 등의 복합 상황이 발생할 수 있다. 플랫폼의 약속은, 이런 복합 상황을 어느 정도 Android OS에게 '위임’한다는 의미를 포함한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://d2fault.github.io/categories/Programming/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://d2fault.github.io/tags/android/"},{"name":"audiofocus","slug":"audiofocus","permalink":"https://d2fault.github.io/tags/audiofocus/"},{"name":"webview","slug":"webview","permalink":"https://d2fault.github.io/tags/webview/"},{"name":"java","slug":"java","permalink":"https://d2fault.github.io/tags/java/"}]},{"title":"[JAVA] BitMask에 관한 자그마한 고찰, 그리고 EnumSet","slug":"20210706-java-bitmask-and-enumset","date":"2021-07-05T16:30:18.000Z","updated":"2024-01-03T14:01:13.911Z","comments":true,"path":"2021/07/06/20210706-java-bitmask-and-enumset/","link":"","permalink":"https://d2fault.github.io/2021/07/06/20210706-java-bitmask-and-enumset/","excerpt":"BitMask 를 사용하는 이유와, 적용하게 된 계기를 적어 보고자 한다. 그러나 결국 EnumSet을 사용하기로 결정하였기 때문에, BitMask 대신 EnumSet 사용을 권장한다. 이 글은 '왜' 사용해야 하는가와 '어떤 장점'이 있는지에 초점을 맞추어 작성하였다.","text":"개요 BitMask 를 사용하는 이유와, 적용하게 된 계기를 적어 보고자 한다. 그러나 결국 EnumSet 을 사용하기로 결정하였기 때문에, BitMask 대신 EnumSet 사용을 권장한다. 단, 이 포스팅에서 BitMask 와 EnumSet 을 디테일하게 다루지는 않을 것이다. 이 글은 ‘왜’ 사용해야 하는가와 '어떤 장점’이 있는지에 초점을 맞추어 작성하였다. BitMask요? 갑자기요? 스무 살, C언어 강의를 듣던 언젠가, 어렴풋이 들었던 것도 같다. (심지어 그 당시 교수님도 그리 중요하게 다루지 않으셨고, 나는 A+이지렁!) 지금도 잘 모르지만 그땐 더욱 몰랐으니 논외로 치고, 처음 BitMask 를 이해해야만 했던 것은 약 1년 전이다. 우리 앱[1]이 특정 앱에게 intent로 정보를 요청하고, 수신해야 했는데 이때 수신한 값이 BitMask 형태라는 것이다. 헤헤. 청천벽력 같았다. ‘어차피 intent에 data 담아서 줄 거면 그 값 그대로 주면 되지 굳이?’ 라는 생각이 들었지만, 그렇게 준다는 걸 어떡해. 앞으로 쓸 일도 없을 것 같고, 대충 이런 게 있구나 정도로만 이해하고 넘어갔다. 코드 구경, 이해, 깨달음, 적용 다른 업무로 옆 파트 과장님과 의견 교환 중에 우연히 과장님의 코드를 볼 기회가 생겼다. 업무 관련해서 조언을 구했는데, 과장님께서 본인 코드[2] 를 적절히 고치면 웬만해서 해결될 거라고 하셨다. 그렇다. 예상했겠지만, 이 코드 안에 BitMask 를 사용한 비즈니스 로직이 포함되어 있었다. 후. 이렇게 다시 만날 줄 몰랐다. 그러나 더는 피할 곳이 없었다. 이전엔 이미 마스킹된 값을 풀어내는 것에 그쳤지만, 이번엔 이것을 제대로 적용해 볼 수 있는 기회였다. 과장님께서 코드까지 주셨는데 두려울 게 뭐가 있겠습니까. 그래서 BitMask가 뭔데? 말 그대로 bit 에 관련된 것이다. bit 는 이진 숫자를 뜻하는 말로, 컴퓨터에서 사용되는 데이터의 최소 단위이다. 맞다, 0과 1! 그런데 왜 bit 에 mask 가 붙는 걸까? BitMask 는 0과 1로만 이루어진 bit 의 특성을 이용한 테크닉의 일종이다. 결론만 말하자면, 이 테크닉은 ‘조건 지옥’ 에서 조금이나마 벗어날 수 있도록 해 준다. 아래 코드를 보자. 1234567891011121314151617181920212223242526public class HobbyManager &#123; // 0000 0000 부터 1000 0000 까지 총 9가지의 기준을 가질 수 있다. public static final int NONE = 0x0; // 0000 0000 public static final int WALKING = 0x1; // 0000 0001 public static final int READING = 0x2; // 0000 0010 public static final int SINGING = 0x4; // 0000 0100 public static final int RUNNING = 0x8; // 0000 1000 public static final int PROGRAMMING = 0x10; // 0001 0000 public static final int SWIMMING = 0x20; // 0010 0000 public static final int DANCING = 0x40; // 0100 0000 public static final int SLEEPING = 0x80; // 1000 0000 private static int hobbyFlags; public static boolean hasHobby(int flag) &#123; return (flag &amp; hobbyFlags) == flag; &#125; public static void addHobby(int flag) &#123; hobbyFlags |= flag; &#125; public static void setHobbyFlags(int flags) &#123; hobbyFlags = flags; &#125;&#125; 작명이 영 별로이긴 하지만, 위 코드는 누군가의 취미를 설정하고, 추가하고, 특정 취미 보유 여부를 판단할 수 있도록 한다. 사용 방법은 간단하다. 모든 함수가 static 함수로 선언되어 있기에 코드 어느 곳에서나, 필요할 때 위의 함수를 호출하기만 하면 된다. 12345678// 초기 취미 SettingHobbyManager.setHobbyFlags(HobbyManager.WALKING | HobbyManager.SINGING | HobbyManager.DANCING);// 신규 취미 추가HobbyManager.addHobby(HobbyManager.PROGRAMMING);// 취미 보유 여부 확인HobbyManager.hasHobby(HobbyManager.SINGING); 사실, HobbyManager 를 작성한 본질적인 이유는 취미 보유 여부 확인 이라고 해도 과언이 아니다. 만약, BitMask 를 사용하지 않는다면 어떤 코드를 작성할 수 있을까? 1234567891011121314ArrayList&lt;String&gt; hobbies = new ArrayList&lt;&gt;();hobbies.add(&quot;WALKING&quot;);hobbies.add(&quot;SINGING&quot;);hobbies.add(&quot;DANCING&quot;);hobbies.add(&quot;PROGRAMMING&quot;);public boolean hasHobby(@NonNull String hobby) &#123; for (i = 0; i &lt; hobbies.length; i++) &#123; if (hobby.equals(hobbies.get(i))) &#123; return true; &#125; &#125; return false;&#125; 적당히 못난 코드로 작성해 보았다. hasHobby 에서 판단하고 싶은 hobby 를 전달받고, 유저의 취미 리스트를 0부터 하나씩 비교하여 존재할 경우 true, 아니면 false 를 반환하게 된다. 물론, 이렇게 개발해도 크리티컬한 문제는 없다. 이런 코드들이 쌓이고 쌓이면 문제가 될 수는 있겠지만 말이다. 그렇지만 코드가 예쁘고, 조금 더 효율적이면 기분이 조크든요. 기왕 하는 거 예쁘게 작성하면 모두가 행복합니다! 다시 돌아와서 막상 적용하니 문제가 생겼다. 위의 코드를 예시로 들면, 우리 앱에서 지원하고 싶은 취미가 9가지가 넘는단 사실이다. 이 경우에 int 형 대신 long 을 사용해서 더 많은 기준을 잡을 수 있다고는 하는데, 관련 예시가 없어 선뜻 적용하기가 어려웠다. 방법을 찾기 위해 열심히 구글링을 하다가, BitMask 대신 사용할 수 있는 엄청난 것을 발견했다. (자바로 안드로이드 개발하지만 자바를 잘 모르는, 또 나만 몰랐겠지?) 나와 같은 고민을 하는 사람이 없도록, Java는 위대했던 거시다. 결론 EnumSet 쓰세요. 두 번 쓰세요. 특징을 정리하면 다음과 같다. EnumSet 에서 제공하는 모든 메서드는 산술 비트 연산을 사용하여 구현되므로 일반적인 연산 속도가 굉장히 빠르다. HashSet 과 같은 다른 Set 구현체와 비교했을 때, 데이터가 예상 가능한 순서로 저장되어 있다. 계산시 하나의 비트만이 필요하므로 더 빠르다. HashSet 처럼 데이터 저장 버킷을 찾을 때 hash code를 계산할 필요가 없다. EnumSet 은 내부적으로 big vector로 표현된다. 비트 벡터의 특성상 더 작은 메모리를 사용한다. bit flag, BitMask는 고전적인 방법(…)이라고 한다. 굳이 쓰지 말고, 내부적으로 bit flag를 사용하는 EnumSet 을 사용하자. 그럼, 위의 예시 코드를 바꿔 봐야지! 123456789101112131415161718192021222324public class HobbyManager &#123; public enum Hobbies &#123; NONE, WALKING, READING, SINGING, RUNNING, PROGRAMMING, SWIMMING, DANCING, SLEEPING, // 신규 취미 2종 추가 DRAWING, BAKING &#125; private static EnumSet&lt;Hobbies&gt; hobbyFlags; public static boolean hasHobby(Hobbies flag) &#123; return hobbyFlags.contains(flag); &#125; public static void addHobby(Hobbies flag) &#123; hobbyFlags.add(flag); &#125; public static void setHobbyFlags(EnumSet&lt;Hobbies&gt; flags) &#123; hobbyFlags = flags; Log.i(TAG, &quot;hobbyFlags Flags: &quot; + hobbyFlags); &#125;&#125; 다음과 같이 사용하면 된다. 12345678910// 초기 취미 SettingEnumSet&lt;HobbyManager.Hobbies&gt; hobbyEnumSet = EnumSet.of(HobbyManager.Hobbies.WALKING, HobbyManager.Hobbies.SINGING, HobbyManager.Hobbies.DANCING);HobbyManager.setHobbyFlags(hobbyEnumSet);// 신규 취미 추가HobbyManager.addHobby(HobbyManager.Hobbies.PROGRAMMING);// 취미 보유 여부 확인HobbyManager.hasHobby(HobbyManager.Hobbies.SINGING); 이번 개발 건에서는 '보유 여부 확인’만 하면 되어서 이정도 코드로 충분했으나, 만일 ‘제거’ 가 필요하다면 EnumSet 에서 지원하는 remove 를 HobbyManager 에 적용하여 확장하면 된다. Easy! 참고 10진수를 2진수 코드화 비트마스크(BitMask)는 무엇인가? Java 데이터 형식 범위 Java enum의 사용 Enum, 자바의 열거타입을 알아보자 EnumSet in Java 모 기업에서 Android Application 개발을 하고 있음. 다만, 일반적인 Android App과는 약간 다른 형태로, 특성 상 타 앱들과 intent를 주고받는 일이 잦다. ↩︎ 같은 팀이기에 서로의 코드는 언제든지 열람 가능하다. ↩︎","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"Java","slug":"Programming/Java","permalink":"https://d2fault.github.io/categories/Programming/Java/"}],"tags":[{"name":"android","slug":"android","permalink":"https://d2fault.github.io/tags/android/"},{"name":"bitmask","slug":"bitmask","permalink":"https://d2fault.github.io/tags/bitmask/"},{"name":"enumset","slug":"enumset","permalink":"https://d2fault.github.io/tags/enumset/"}]},{"title":"[Book] 열정의 배신(하고 싶은 일만 하면 정말 행복해질까)","slug":"20210509-book-review-so-good-they-cant-ignore-you","date":"2021-05-09T09:04:16.000Z","updated":"2024-01-03T14:01:13.907Z","comments":true,"path":"2021/05/09/20210509-book-review-so-good-they-cant-ignore-you/","link":"","permalink":"https://d2fault.github.io/2021/05/09/20210509-book-review-so-good-they-cant-ignore-you/","excerpt":"‘업의 본질’에 대한 탐구 끝에 얻은 일의 절대 원칙 열정을 따르는 대신, 열정이 당신을 따르게 하라! 자신이 꿈꾸는 일, 좋아하는 일은 천직처럼 따로 있으며, 그 일을 찾으면 저절로 행복해지고 성공한다는 이른바 ‘열정론’이 우리 사회에 만연해 있다.","text":"책 소개 이미지를 클릭하시면 네이버 책으로 이동합니다. 책 정보 ‘업의 본질’에 대한 탐구 끝에 얻은 일의 절대 원칙 열정을 따르는 대신, 열정이 당신을 따르게 하라! 자신이 꿈꾸는 일, 좋아하는 일은 천직처럼 따로 있으며, 그 일을 찾으면 저절로 행복해지고 성공한다는 이른바 ‘열정론’이 우리 사회에 만연해 있다. 칼 뉴포트는 “열정을 따르라”는 조언이 틀렸을뿐더러 위험하기까지 하다고 단언한다. 이 오랜 믿음은 사실 결함투성이다. 대부분의 사람들은 애초에 열정을 품고 있지 않으며, 또 열정은 일을 사랑하게 되는 법과도 무관하다. 오히려 이를 맹신하다가는 현실의 벽에 부닥쳐 실패하기 십상이다. “열정을 따르지 마라”는 대원칙을 입증한 후 뉴포트는, 그렇다면 ‘사람들은 어떻게 자신의 일을 사랑하게 되는가’에 대한 탐구를 시작한다. 벤처 투자자, 프리랜서 소프트웨어 개발자, 방송작가, 코미디언, 기업가, 컴퓨터 프로그래머, 뮤지션, 과학자, 고고학자 등 다양한 직업에서 큰 만족감을 이끌어 내고 있는 사람들을 인터뷰하면서, 그는 또 다른 중요한 3가지 원칙을 발견해 낸다. “누구도 무시하지 못할 실력을 쌓아라” “지위보다 자율성을 추구하라” “작은 생각에 집중하고, 큰 실천으로 나아가라”가 바로 그것이다. 이상의 4가지 원칙이야말로 자신이 하는 일을 사랑할 수 있게 해 주는 핵심 전략이다. 저자는 이런 큰 원칙들 아래 ‘커리어 자산을 쌓아라’ ‘장인 마인드셋을 갖추어라’ ‘자율성을 추구하되 함정에 빠지지 마라’ ‘사람들이 기꺼이 돈을 낼 일을 하라’ ‘사명감을 갖춰라’ ‘의식적 훈련에 매진하라’ ‘작은 도전에 승부를 걸어라’ ‘자신을 마케팅하라’ 등 구체적인 실천법을 제시한다. 그리고 다채로운 인물의 경험담과 연구 자료를 통해 그런 방법들을 실제로 어떻게 구현할 수 있는지 세세히 설명하면서 매력적인 커리어를 성취하는 로드맵을 제시한다. 예스24 제공 리뷰 하고 싶은 일만 하면 정말 행복해질까? 궁금했다. 요즘의 내가 버거워서, 도피하고 싶은 마음이 가득해서, 재능이라곤 애매한 재능밖에 없는 것 같아서, 하고 싶은 일만 하면 지금보다 더 행복할 수 있을지 궁금했다. 평소 잘 읽지 않는 자기계발서가 눈에 들어왔다는 건 생각보다 더 큰 격변의 시기를 보내는 중임을 증명하는 게 아닐까. 바쁘다. 의도해서 벌인 일과, 의도하지 않았지만 생겨난 일들이 혼재한다. 나는 생각보다도 더 도태된 인간이었고, 이 알을 깨려 하는 노력이 올바른 방향의 노력인지 확신할 수 없었다. 그냥, 과거에도 비슷한 일들이 있었고, 그럴 때마다 버텨냈고, 버티다 보면 지나갔기에 또 버티고 있었을 뿐이다. 내 자신을 나약하다고 생각했다. 남들은 너무 열심히, 열정적으로, 잘 사는 것처럼 보였으니까. 내가 제일 못났는데, 그래서 나아가야 하는데 너무 더뎠다. 습득이 빠르지 않다는 건 알고 있었지만, 시간에 쫓기니 느릿느릿한 내가 못내 답답했다. 무엇이든 잘하게 되려면 시간이 걸린다는 점을 강조합니다. 자신만 해도 라디오 진행에서 즐거움을 얻기까지 오랜 세월이 필요했다고 고백하지요. “일을 통해 스스로를 단련하는 게 중요합니다. 실력이 갖춰질 때까지요. 그 기간이 가장 힘든 단계죠.” 우연히 만난 이 책이 나를 위로했다. 그냥 나는 가장 힘든 단계를 지나고 있을 뿐이라고, 반짝거리는 그들 또한 가장 힘든 단계를 거쳤다고 했다. 맞지, 내가 보는 건 그저 결과일 뿐이니까. 그냥 회사에 출근해 시키는 일만 한다면 안데르스 에릭슨이 이 장의 앞부분에서 설명한 대로 정체기 이전의 ‘적당한 수준’까지는 도달할 수 있겠죠. 의식적 훈련을 통해 이 정체기를 넘어 경쟁자가 거의 없는 영역으로 올라설 수 있습니다. 하지만 이런 성과를 이룬 사람들이 극히 적은 이유는 바로 콜빈이 경고한 대로 의식적 훈련은 대개 ‘즐거움’과는 거리가 멀기 때문이죠. 타성에 젖지 않으려 노력했지만 천천히 멈추는 중이었던 것 같다. 정체기 이전의 '적당한 수준’이라는 문장이 머리를 쿵 쳤다. ‘내 이야기잖아?’ 나의 주요 업무는 '구조 개선’이나, '성능 개선’이 목표가 되어야 할 정도로 안정되어 있었다. 그리고 그 사실은 모든 사람이 알았나 보다. 지금 와서 생각해 보면 신규 프로젝트가 툭 떨어진 게 당연한 수순이었다. 그 프로젝트가 너무 버겁고 힘겨웠다. 즐겁지 않았고, 재미도 없었고, 그러다 보니 하기가 싫었다. 하하! 내가 하고 있던 게 의식적 훈련이라고? 의식적 훈련을 묘사할 때 저는 “한계를 넘어선다”는 표현을 즐겨 씁니다. 제 개인적 경험에서 나온 표현이기도 하죠. 새로운 수학적 기술을 배우는 과정은 의식적 훈련의 전형이라고 할 수 있는데, 이럴 때 제 머릿속에서는 육체적 과로와 비슷한 불편함이 느껴지거든요. 마치 제 뉴런들이 새롭게 재배열되는 듯한 기분이 들곤 합니다. 어느 수학자나 인정하듯이 이런 한계를 넘어서는 느낌은 이미 익숙한 기술을 적용할 때의 즐거움과는 전혀 다르죠. 하지만 이 한계 극복 과정이 실력을 키우기 위한 전제 조건이라는 점 또한 모든 수학자들은 인정합니다. 위 문장을 읽으며 유튜브에서 우연히 본 영상이 떠올랐다. 심각한 슬럼프를 겪었다던 아이유는 그 슬럼프를 넘어서기 위해 쉼과 새로운 도전을 택했다. 그리고 그 도전 너머에 즐거움이 있었다고 한다. 이제 저는 ‘압박감’을 긍정적으로 받아들일 줄 알게 됐죠. 압박감이 주는 불편함을 피해야 할 대상으로 여기지 않고, 보디빌더가 공들여 근육을 만들 때 타는 듯한 고통을 느끼는 것과 마찬가지로 뭔가 제대로 하고 있을 때 느껴지는 신호라고 생각하게 된 겁니다. 아마 아이유도 이젠 압박감을 긍정적으로 받아들이고 있지 않을까? 내가 아이유가 되어 보지도, 그만큼의 성공을 이뤄 보지도 못해서 확신할 수는 없지만 지금까지의 행보로 보면 음, 그럴 것 같다는 생각이 든다. 책을 읽으며 나를 되돌아봤다. 하면 하는대로 실력이 늘고, 해낼 자신감이 있었던 순간엔 일이 재미있었다. 이런 순간들이 모여 나를 정체기 이전의 '적당한 수준’까지 만들어 주었다. 지금 내가 느끼는 압박감은 긍정적인 것이며, 정체된 알을 깨고 나오려는 시도로 인해 생긴 힘듦과 어려움이다. 그렇다면 난 제대로 가고 있는 게 맞다. 내년의 내가 이 글을 볼 때 '그땐 그랬지, 귀엽네!'의 마음이길 바라며, 이 확신을 잊지 않기 위해 기록한다.","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"책","slug":"책","permalink":"https://d2fault.github.io/tags/%EC%B1%85/"}]},{"title":"[Diary] 매시업 10기 해커톤 회고하기","slug":"20210301-diary","date":"2021-03-01T07:25:17.000Z","updated":"2024-01-03T14:01:13.893Z","comments":true,"path":"2021/03/01/20210301-diary/","link":"","permalink":"https://d2fault.github.io/2021/03/01/20210301-diary/","excerpt":"Ready, 1월 9일, 기다리고 기다리던 해커톤 팀이 발표됐다. 우리 팀은 iOS & Android 팀으로, 디자이너와 서버(Spring)까지 총 12명!","text":"Ready, 1월 9일, 기다리고 기다리던 해커톤 팀이 발표됐다. 우리 팀은 iOS &amp; Android 팀으로, 디자이너와 서버(Spring)까지 총 12명! 모든 것들을 비대면으로 진행하게 되어 어색함을 내려놓기까지 약간의 시간이 걸렸지만 주기적인 아이디어 회의와 깨알 같은 온라인 회식을 통해 하나의 팀으로 거듭났다. 😊 매주 한 번 이상, 1회 최소 2시간 이상의 찐-한 회의로 굉장히 끈끈해졌다는 후문. 해커톤 아이디에이션이 어느 정도 진행된 후에 아주 오랜 시간(거의 4-5시간?)의 온라인 회식을 함께했다. 참석 준비물은 맛있는 술과 안주! 우리는 각종 게임(어몽어스, 테트리스, 캐치마인드 등)을 섭렵하였는데, 마지막 게임은 결국 ‘말을 놓지 못하는 자, 마셔라!’ 로 귀결되었다. (팀장님의 발언 쿨타임이 점멸 쿨타임과 같다는 썰이 있습니다.) 긴 설명 대신, 사진 한 장으로 우리의 우정 인증하기! 카메라 안 켜고 진행한 회의가 더x99999 많았답니다. (사진 원본이 궁금하다면 매시업 11기에 도전하세요! 🥰) Get set, 노션을 만들고, 규칙을 정하고, 아이디어를 공유하고, 최종적으로 우리의 아이템이 결정되었다. 시작, 진짜_시작, 진짜_진짜_시작, 진짜_정말_최종_시작의 느낌이지만 아이템이 정해진 이후 우리는 더 분주해졌다. 회원 가입 유무, 오픈 방 유무, 관리자에게 어떤 권한까지 줄지 등 함께 정할 것들이 너무나도 많았다. 자칫 잘못하면 빙빙 돌 수도 있는 애매한 것들임에도 불구하고 회의 전 명확한 안건 설정으로 시간 낭비를 막아낼 수 있었다. 기획의 디테일이 잡혀갈수록 디자이너들은 바빠졌다. IA, Wireframe 그리고 실제 디자인 가이드까지 80% 이상의 완성물을 해커톤 전까지 우리에게 공유해 주었다. 디스코드에서 밤낮없이 회의하던 갓 디자이너들의 모습이 아직도 눈에 선하다. (한편으론 내가 그 멋진 디자인을 망칠까 걱정이 된다.) 어느 정도 디자인이 완성되던 그때, 디스코드에 서버 개발자들이 자주 등장했다. 지난 해커톤 팀의 경우 기획과 Wireframe만 대략적으로 잡고 모든 파트가 해커톤 당일에 0부터 시작했었는데 이번엔 다들 비대면에 익숙해져서 그런지 해커톤 전부터 무언가를 계속 준비하고 있었다. 그렇게 우리 팀의 서버는 전체적 구조 및 DB 설계가 완성된 상태로 해커톤을 맞이했다. 모바일 개발자들은 해커톤 전 github에 repository를 생성하였고, 애플리케이션 전체의 근간이 되는 베이스 코드를 작성하였다. 해커톤 당일에 UI 작업을 쉽게 하기 위해 밑작업을 해둔 셈이었다. Go! 모두가 바랐던 수도권의 5인 이상 집합 금지는 풀리지 않았다. 팀 전체(12명)는 절대로 모일 수 없었기에, 파트별로 모이기로 협의! 디자인과 서버는 건대, iOS는 판교, 그리고 안드로이드는 홍대에서 옹기종기 모여 작업하였다. 대면으로 하는 맛(?)은 덜했지만 우리를 연결해준 디스코드와 카카오톡 덕분에 큰 어려움은 없었다. 우리(안드로이드)의 해커톤 목표는 UI 작업 끝내기였다. 안드로이드 개발을 하지만 서비스와 거리가 먼 나의 개발 속도는 생각보다도 너무 너무 느려서 팀원들에게 굉장히 미안했다. 파트를 이끄는 것은 힘들지라도 맡은 건 어떻게든 끝내는 팀원이고 싶었기에 할 수 있는 건 빠르게, 검색으로도 잘 나오지 않거나 정말 모르겠는 건 힌트를 얻어가는 방식으로 개발했다. 작년 해커톤보다 성장한 건 확실한데, 성장한 수준이 그리 높지 않아서 좋아해야 할지 슬퍼해야 할지 모르겠다는 건 함정. (ㅠㅠ) UI를 다 붙이려는 목표까진 달성하지 못했다. UI 진척도를 대략 80% 언저리까진 맞췄지만, 중간에 코드 머지하는 과정에서 약간의 이슈가 생겨 시연이 불가능했던 점은 아쉬웠다. 그래도 내 파트를 모두 개발한 것 뿐만 아니라(팀원보다 쉬운 페이지를 맡긴 했지만) 추가적으로 무언가를 더 해냈다는 점에서 나를 굉장히 칭찬하고 싶다! 그리고 우리는 실패했지만 iOS의 시연 영상 덕분에 엄청난 상을 받았다! 완성도 제일 높은 애플리케이션 상이라니! &gt;_&lt; 모든 팀들의 발표를 듣고 투표까지 마무리한 후 아주 잠깐 기절했었는데 정신을 차려보니 우리 팀이 상을 받다뇨?! 밤샘 피로가 싹 없어지(지는 않았지만)는 기분이었다. 마지막으로 갓 디자이너들과 갓 개발자들 덕분에 즐겁고 행복한 해커톤이었다. 디자인과 서버가 이렇게 빨리 나오리라고는 상상도 못했는데 열정을 가지고 열심히 한 우리 팀원들 너무너무 대단하다! 아는 것도 별로 없는 느림보 데리고 개발한다고 고생한 우리 파트원들에게도 고맙고, 포기하지 않고 목표한 바를 이뤄낸 나에게도 고맙다. 두 명의 디자이너와 열 명의 개발자, TEAM TDTD(토닥토닥)의 속닥속닥 서비스 배포까지 모두 함께 잘 달렸으면 좋겠습니다. 🥰 iOS 개발자들이 찍은 감성 가득한 해커톤 새벽의 하늘. 실물로 보는 게 더 더 더 예뻤다고 합니다. 아름다운 풍경 함께 보지 못해서 슬펐어요. ㅠ_ㅠ Github Repository 링크 TDTD_Android TDTD_iOS TDTD_Backend","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Diary","slug":"Anything/Diary","permalink":"https://d2fault.github.io/categories/Anything/Diary/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://d2fault.github.io/tags/%ED%9A%8C%EA%B3%A0/"},{"name":"해커톤","slug":"해커톤","permalink":"https://d2fault.github.io/tags/%ED%95%B4%EC%BB%A4%ED%86%A4/"},{"name":"매시업","slug":"매시업","permalink":"https://d2fault.github.io/tags/%EB%A7%A4%EC%8B%9C%EC%97%85/"}]},{"title":"[Kotlin] 코루틴(Coroutine) Context and Dispatchers","slug":"20210221-coroutine-context-and-dispatchers","date":"2021-02-20T16:46:05.000Z","updated":"2024-01-03T14:01:13.888Z","comments":true,"path":"2021/02/21/20210221-coroutine-context-and-dispatchers/","link":"","permalink":"https://d2fault.github.io/2021/02/21/20210221-coroutine-context-and-dispatchers/","excerpt":"코루틴의 context 중 Dispatchers를 공부해 본다.","text":"Coroutine Context and Dispatchers 코루틴은 항상 Kotlin 표준 라이브러리에 정의된 컨텍스트에서 실행된다. 코루틴 context에는 다양한 요소가 있으며, 그중 가장 중요한 요소는 이전 포스팅에서 다룬 job과 이번 포스팅에 다룰 Dispatchers이다. ※ IntelliJ나 Android Studio가 설치되어 있지 않다면 Kotlin 공식 사이트에서 지원하는 온라인 IDE(Kotlin Playground)를 사용하여 아래 코드를 실행할 수 있다. Dispatchers and threads 코루틴은 코루틴 컨텍스트에서 실행되는데, 코루틴 컨텍스트에 이 Dispatchers가 있다. Dispatchers는 코루틴을 어떤 스레드 혹은 스레드풀에서 실행할지 결정한다. 모든 코루틴 빌더는 optional로 CoroutineContext parameter를 가지고 있다. 123456789101112131415161718fun main() = runBlocking&lt;Unit&gt; &#123; // 코루틴이 main thread에서 실행됨 launch &#123; // context of the parent, main runBlocking coroutine println(&quot;main runBlocking : I&#x27;m working in thread $&#123;Thread.currentThread().name&#125;&quot;) &#125; // 코루틴이 main thread에서 실행됨 launch(Dispatchers.Unconfined) &#123; // not confined -- will work with main thread println(&quot;Unconfined : I&#x27;m working in thread $&#123;Thread.currentThread().name&#125;&quot;) &#125; // 코루틴이 DefaultDispather-worker-1에서 실행됨 launch(Dispatchers.Default) &#123; // will get dispatched to DefaultDispatcher println(&quot;Default : I&#x27;m working in thread $&#123;Thread.currentThread().name&#125;&quot;) &#125; // 코루틴이 MyOwnThread에서 실행됨 launch(newSingleThreadContext(&quot;MyOwnThread&quot;)) &#123; // will get its own new thread println(&quot;newSingleThreadContext: I&#x27;m working in thread $&#123;Thread.currentThread().name&#125;&quot;) &#125; &#125; 위 코드 실행 결과는 다음과 같은데, 1234Unconfined : I&#39;m working in thread mainDefault : I&#39;m working in thread DefaultDispatcher-worker-1newSingleThreadContext: I&#39;m working in thread MyOwnThreadmain runBlocking : I&#39;m working in thread main 왠지 모르게 복잡해 보이는 이름을 출력한 Dispatchers.Default 가 특별(?)하게 느껴질 수도 있다. 그러나 Dispatcher.Default 는 global scope에서 실행했던 코루틴들이 실행되는 스레드를 뜻한다(==기본 스레드). 그러니까, global로 실행하나 Dispatchers.Default 로 실행하나 결국 같은 스레드라는 의미이다. 코루틴을 생성할 때마다 newSingleThreadContext 를 만드는 방식은 비용이 높은 방식이다. 새차원님의 강의에 따르면, 위 예시의 방식으로 작성하는 것보다 다음과 같이 12345newSingleThreadContext().use &#123; launch(it) &#123; println(&quot;newSingleThreadContext: I&#x27;m working in thread $&#123;Thread.currentThread().name&#125;&quot; &#125;&#125; 사용하는 것이 좋다고 한다. 왜냐하면 newSingleThreadContext 를 호출하면 새로운 스레드를 만들게 되고, 이 경우 close 를 하지 않으면 메모리 누수가 발생할 수 있기 때문이다. use 를 사용할 경우 close 처리를 알아서 해 주기 때문에 이 방식을 권장한다. 그리고 당연히 Dispatchers 를 지정하지 않아도 코루틴 실행에는 문제가 없다. Unconfined vs confined dispatcher Dispatchers.Unconfined 는 호출한 스레드에서 코루틴을 시작하지만, 첫번째 suspension point까지만 그 스레드에 머물러 있다. 중단 이후 코루틴이 재개(resume)되면 resume을 명령한 코루틴 스레드에서 수행된다. Dispatchers.Unconfined 는 어떤 스레드에서 동작해도 무관할 때에 사용하면 된다. 즉, Dispatchers.Unconfined 는 시작 스레드와 종료 스레드가 같지 않기 때문에 프로그램의 규모가 커질 경우 어디서 종료될지 예측이 어려워진다. 도큐먼트에서는 특수한 상황(사실 어떤 상황에 도움이 될지 잘 모르겠다.)에는 도움이 될 수 있는 진보된 매커니즘이라고 소개하는데, 웬만해서 사용하지 않는 것이 좋을 것 같다. 반면, 코루틴 컨텍스트 요소들은 보통 부모 코루틴 스코프의 컨텍스트 요소가 자식 컨텍스트 요소에게 상속된다. 특히 runBlocking 코루틴의 기본 디스패처는 호출한 스레드에 국한되기 때문에 이를 상속하는 것은 그 스레드에만 국한되도록 하는 효과가 있다. 예측 가능한 FIFO 스케줄링이 필요할 때 confined dispatcher를 사용하면 된다. 123456789101112fun main() = runBlocking&lt;Unit&gt; &#123; launch(Dispatchers.Unconfined) &#123; // not confined -- will work with main thread println(&quot;Unconfined : I&#x27;m working in thread $&#123;Thread.currentThread().name&#125;&quot;) delay(500) println(&quot;Unconfined : After delay in thread $&#123;Thread.currentThread().name&#125;&quot;) &#125; launch &#123; // context of the parent, main runBlocking coroutine println(&quot;main runBlocking: I&#x27;m working in thread $&#123;Thread.currentThread().name&#125;&quot;) delay(1000) println(&quot;main runBlocking: After delay in thread $&#123;Thread.currentThread().name&#125;&quot;) &#125; &#125; 위의 코드를 실행해 보면 다음의 결과를 볼 수 있다. launch 에 별다른 디스패처 세팅을 하지 않은 코루틴은 runBlocking 을 따라 호출한 스레드에 국한되어 실행된다. 반면 Dispatchers.Unconfined 세팅을 한 코루틴은 delay 전과 후에 코루틴이 실행되는 스레드가 다르다. Debugging coroutines and threads Debugging with IDEA 코루틴은 한 스레드에서 중단된 후 다른 스레드에서 재개될 수 있다. 단일 스레드 디스패처에서조차 어떤 코루틴이 언제, 어디서 수행 중이었는지 알아내는 건 어렵다. 일반적으로 스레드를 사용하는 애플리케이션을 디버깅할 땐 각각의 로그마다 현재 수행 중인 스레드의 이름을 붙여 출력한다. 이 기능은 보통 logging framework에서 지원하며, 코루틴 프레임워크 또한 디버깅 기능을 제공한다. 단, 디버깅 기능은 kotlinx-coroutines-core 버전 1.3.8 이상에서만 지원한다. JVM 옵션에 -Dkotlinx.coroutines.debug 을 추가하면 Thread 명에 추가로 코루틴 이름까지 출력되는 것을 확인할 수 있다. 코루틴 디버거를 사용하여 디버그 모드로 애플리케이션을 실행하면 다음과 같은 기능을 사용할 수 있다. 각 코루틴의 상태 확인 실행 중인 코루틴과 일시 중지된 코루틴 모두에 대한 변수 값 확인 전체 코루틴 생성 스택과 내부 호출 스택 확인 각 코루틴의 상태와 스택이 포함된 전체 정보 [참고] Android Studio에 VM 옵션 설정하기 Help &gt; Edit Custom VM Options 클릭 VM 옵션을 한 번도 수정한 적이 없다면 새로운 studio.vmoptions 를 생성하라는 메시지가 출력됨 → Yes 클릭 오픈된 studio.vmoptions 파일에 위의 VM 옵션을 추가한다. 자세한 내용은 공식 도큐먼트를 참고하자. Debugging using logging 디버거가 없는 애플리케이션을 디버깅하기 위해 로그에 스레드 이름을 출력하는 방법이 있다. JVM 옵션을 추가하는 위의 방식이 더 발전된 방식이기에 위의 방법을 권장한다. 12345678910111213fun log(msg: String) = println(&quot;[$&#123;Thread.currentThread().name&#125;] $msg&quot;)fun main() = runBlocking&lt;Unit&gt; &#123; val a = async &#123; log(&quot;I&#x27;m computing a piece of the answer&quot;) 6 &#125; val b = async &#123; log(&quot;I&#x27;m computing another piece of the answer&quot;) 7 &#125; log(&quot;The answer is $&#123;a.await() * b.await()&#125;&quot;) &#125; 위 코드의 출력 결과는 다음과 같다. 123[main @coroutine#2] I&#39;m computing a piece of the answer[main @coroutine#3] I&#39;m computing another piece of the answer[main @coroutine#1] The answer is 42 Jumping between threads 코루틴이 처음 실행했던 스레드에서 벗어나서 다른 스레드에 갔다가 다시 처음 스레드로 복귀하는 형태의 예제이다. 예를 들어, 안드로이드 메인 스레드에서 백그라운드 스레드에 갔다가 다시 메인스레드로 돌아오는 듯한 기능을 쉽게 만들 수 있게 해 주는 중요한 기능이다. 123456789101112131415fun log(msg: String) = println(&quot;[$&#123;Thread.currentThread().name&#125;] $msg&quot;)fun main() &#123; newSingleThreadContext(&quot;Ctx1&quot;).use &#123; ctx1 -&gt; newSingleThreadContext(&quot;Ctx2&quot;).use &#123; ctx2 -&gt; runBlocking(ctx1) &#123; log(&quot;Started in ctx1&quot;) withContext(ctx2) &#123; log(&quot;Working in ctx2&quot;) &#125; log(&quot;Back to ctx1&quot;) &#125; &#125; &#125; &#125; 여기서 가장 중요한 부분은 withContext() 이다. withContext() 에 스레드를 지정해 주면 그 스레드에서 코루틴을 실행하고, 실행이 끝나면 다시 원래 스레드(ctx1)로 돌아온다. 실행 결과는 다음과 같다. 123456## Ctx1에서 Started in ctx1 로그 출력[Ctx1 @coroutine#1] Started in ctx1## Ctx2에서 Working in ctx2 로그 출력[Ctx2 @coroutine#1] Working in ctx2## 다시 Ctx1으로 돌아와서 Back to ctx1 로그 출력[Ctx1 @coroutine#1] Back to ctx1 Job in the context 코루틴 컨텍스트에서 Job 을 탐색해 보자. 123fun main() = runBlocking&lt;Unit&gt; &#123; println(&quot;My job is $&#123;coroutineContext[Job]&#125;&quot;) &#125; 위 코드를 실행하면 다음과 같이 출력된다. 1My job is &quot;coroutine#1&quot;:BlockingCoroutine&#123;Active&#125;@573fd745 이건, “코루틴 컨텍스트에서 Job 엘리먼트를 꺼내 보았더니 존재(BlockingCoroutine 로)하더라.” 라는 의미이다. Children of a coroutine 코루틴이 실행될 때 Job 사이에 부모-자식 관계가 있다는 것을 보여주는 예제이다. 하나의 새로운 코루틴이 실행되면 그 코루틴은 부모 코루틴의 자식이 된다. 단, GlobalScope.launch 는 부모-자식 관계가 없는 독립 스코프로, 별도로 Job 이 생성된다. 1234567891011121314151617181920212223fun main() = runBlocking&lt;Unit&gt; &#123; // launch a coroutine to process some kind of incoming request val request = launch &#123; // it spawns two other jobs, one with GlobalScope GlobalScope.launch &#123; println(&quot;job1: I run in GlobalScope and execute independently!&quot;) delay(1000) println(&quot;job1: I am not affected by cancellation of the request&quot;) &#125; // and the other inherits the parent context launch &#123; delay(100) println(&quot;job2: I am a child of the request coroutine&quot;) delay(1000) println(&quot;job2: I will not execute this line if my parent request is cancelled&quot;) &#125; &#125; delay(500) // 부모 코루틴을 취소했을 때 둘 중 어느 코루틴이 취소될까? request.cancel() delay(1000) // delay a second to see what happens println(&quot;main: Who has survived request cancellation?&quot;)&#125; 부모 코루틴이 취소되면 자식 코루틴 또한 취소된다. 그래서 위 예제의 결과는 12345job1: I run in GlobalScope and execute independently! [DefaultDispatcher-worker-1]job2: I am a child of the request coroutine [main]## 부모 코루틴 취소 요청 이후 job1은 취소되지 않음(부모-자식 관계 X)job1: I am not affected by cancellation of the request [DefaultDispatcher-worker-2]main: Who has survived request cancellation? [main] 위와 같이 출력되며, job2: I will not execute this line if my parent request is cancelled 로그는 출력되지 않는다. Parental responsibilities 부모 코루틴은 모든 자식 코루틴의 실행 완료를 기다리기 때문에 join 을 사용하지 않아도 된다. 123456789101112131415fun main() = runBlocking&lt;Unit&gt; &#123; // launch a coroutine to process some kind of incoming request val request = launch &#123; repeat(3) &#123; i -&gt; // launch a few children jobs launch &#123; delay((i + 1) * 200L) // variable delay 200ms, 400ms, 600ms println(&quot;Coroutine $i is done&quot;) &#125; &#125; println(&quot;request: I&#x27;m done and I don&#x27;t explicitly join my children that are still active&quot;) &#125; // 없어도 잘 동작함 request.join() // wait for completion of the request, including all its children println(&quot;Now processing of the request is complete&quot;)&#125; 13 라인의 request.join() 을 지우고 위의 코드를 실행해 보면 좋을 것 같다. 부모가 자식 코루틴의 실행을 기다리기 때문에 join() 없이도 정상 동작함을 확인할 수 있다. Naming coroutines for debugging 디버깅을 위한 이름 설정 팁을 알려주는 예시이다. CoroutineName 이라는 컨텍스트 요소를 사용하면 스레드 이름과 동일하게 코루틴 이름을 지정할 수 있다. 만일 디버깅 모드라면 CoroutineName 은 코루틴 수행 중인 스레드 이름에 함께 출력된다. 12345678910111213141516fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; log(&quot;Started main coroutine&quot;) // run two background value computations val v1 = async(CoroutineName(&quot;v1coroutine&quot;)) &#123; delay(500) log(&quot;Computing v1&quot;) 252 &#125; val v2 = async(CoroutineName(&quot;v2coroutine&quot;)) &#123; delay(1000) log(&quot;Computing v2&quot;) 6 &#125; log(&quot;The answer for v1 / v2 = $&#123;v1.await() / v2.await()&#125;&quot;)&#125; 결과는 다음과 같다. 1234[main @coroutine#1] Started main coroutine[main @v1coroutine#2] Computing v1[main @v2coroutine#3] Computing v2[main @coroutine#1] The answer for v1 &#x2F; v2 &#x3D; 42 모든 코루틴이 main 스레드에서 실행된 사실과 함께 CoroutineName() 을 이용하여 지정해준 이름이 로그에 출력됨을 확인할 수 있었다. Combining context elements CoroutineContext에 여러 요소를 정의할 수 있으며, 이때 + 연산을 사용할 수 있다. 아래 예제에서는 Dispatchers 와 CoroutineName 을 함께 사용하였다. 12345fun main() = runBlocking&lt;Unit&gt; &#123; launch(Dispatchers.Default + CoroutineName(&quot;test&quot;)) &#123; println(&quot;I&#x27;m working in thread $&#123;Thread.currentThread().name&#125;&quot;) &#125; &#125; 다음과 같은 실행 결과를 얻을 수 있다. 1I&#39;m working in thread DefaultDispatcher-worker-1 @test#2 Coroutine Scope 생명 주기가 있는 객체에서 코루틴을 사용할 땐 메모리 누수 방지를 위해 꼭 코루틴을 취소해 주어야 한다. 아래 코드와 같이 하나의 코루틴 스코프를 생성하고, 그 스코프를 이용하여 동작하도록 하는 방식으로 개발하는 것이 유지보수에 용이하다. 123456789101112131415161718192021222324252627282930class Activity &#123; // mainScope라는 코루틴 스코프 생성 private val mainScope = CoroutineScope(Dispatchers.Default) fun destroy() &#123; // 화면 destory시 mainScope cancel mainScope.cancel() &#125; fun doSomething() &#123; // launch ten coroutines for a demo, each working for a different time repeat(10) &#123; i -&gt; mainScope.launch &#123; delay((i + 1) * 200L) // variable delay 200ms, 400ms, ... etc println(&quot;Coroutine $i is done&quot;) &#125; &#125; &#125;&#125; // class Activity endsfun main() = runBlocking&lt;Unit&gt; &#123; val activity = Activity() activity.doSomething() // run test function println(&quot;Launched coroutines&quot;) delay(500L) // delay for half a second println(&quot;Destroying activity!&quot;) // 모든 코루틴 스코프가 삭제된다! activity.destroy() delay(1000) // visually confirm that they don&#x27;t work &#125; 28 라인의 activity.destroy() 를 없애고, 29 라인의 delay(1000) 을 delay(3000) 으로 변경하여 테스트해 보는 것도 의미가 있다. 3초 후에 main() 이 끝나야 하지만 코루틴 스코프를 취소하지 않기에 코루틴이 계속 동작한다. (메모리 누수 발생 위험) 참고 ktx 유저는 lifecycleScope 와 viewmodelScope 를 사용하는 것이 좋다. 취소 작업을 알아서 처리하기 때문에 별도로 작업하지 않아도 된다. Thread-local data 가끔 스레드 로컬 데이터를 코루틴으로 전달하거나 혹은 코루틴 간에 전달하는 기능이 유용할 때가 있다. 그러나 코루틴은 특정 스레드에 국한되어 실행되지 않음으로, 이런 기능을 직접 구현하기 위해선 많은 작업이 필요하다. ThreadLocal 을 위해 asContextElement() 확장 함수를 사용할 수 있다. 이 함수는 ThreadLocal 의 값을 저장했다가 코루틴이 속한 컨텍스트가 변경될 때마다 해당 값을 복원한다. (조금 다르지만 static 변수로 저장하는 느낌! 그런 느낌으로만 이해했다.) 1234567891011121314val threadLocal = ThreadLocal&lt;String?&gt;() // declare thread-local variablefun main() = runBlocking&lt;Unit&gt; &#123; threadLocal.set(&quot;main&quot;) println(&quot;Pre-main, current thread: $&#123;Thread.currentThread()&#125;, thread local value: &#x27;$&#123;threadLocal.get()&#125;&#x27;&quot;) // asContextElement 주목 val job = launch(Dispatchers.Default + threadLocal.asContextElement(value = &quot;launch&quot;)) &#123; println(&quot;Launch start, current thread: $&#123;Thread.currentThread()&#125;, thread local value: &#x27;$&#123;threadLocal.get()&#125;&#x27;&quot;) yield() println(&quot;After yield, current thread: $&#123;Thread.currentThread()&#125;, thread local value: &#x27;$&#123;threadLocal.get()&#125;&#x27;&quot;) &#125; job.join() println(&quot;Post-main, current thread: $&#123;Thread.currentThread()&#125;, thread local value: &#x27;$&#123;threadLocal.get()&#125;&#x27;&quot;) &#125; 실행 결과는 다음과 같다. 1234Pre-main, current thread: Thread[main @coroutine#1,5,main], thread local value: &#39;main&#39;Launch start, current thread: Thread[DefaultDispatcher-worker-1 @coroutine#2,5,main], thread local value: &#39;launch&#39;After yield, current thread: Thread[DefaultDispatcher-worker-2 @coroutine#2,5,main], thread local value: &#39;launch&#39;Post-main, current thread: Thread[main @coroutine#1,5,main], thread local value: &#39;main&#39; 그런데 이 방식은 코루틴을 실행하는 스레드가 다를 경우 코루틴에서 접근한 스레드 로컬 변수는 예상하지 못한 값을 들고 있을 수도 있다. 이런 상황을 방지하기 위해서 ensurePresent 메서드를 사용하고, 부적절한 사용시 fail-fast 를 사용하는 것이 좋다. 스레드 로컬 변수에 다른 값을 업데이트하고 싶다면 withContext 를 사용하면 된다. 자세한 내용은 asContextElement 를 참조하자. 참고 코루틴 공식 문서 - Coroutine Context and Dispatchers 새차원의 코틀린 코루틴 강좌 #6 - Coroutine Context and Dispatchers 아키텍처 구성요소와 함께 Kotlin 코루틴 사용 코루틴 공식 가이드 자세히 읽기 - Part 5 [Android] 코루틴 Coroutine Context and Dispatchers","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://d2fault.github.io/categories/Programming/Android/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://d2fault.github.io/tags/kotlin/"},{"name":"coroutine","slug":"coroutine","permalink":"https://d2fault.github.io/tags/coroutine/"},{"name":"Android","slug":"Android","permalink":"https://d2fault.github.io/tags/Android/"},{"name":"context","slug":"context","permalink":"https://d2fault.github.io/tags/context/"},{"name":"dispatchers","slug":"dispatchers","permalink":"https://d2fault.github.io/tags/dispatchers/"}]},{"title":"[Kotlin] 코루틴(Coroutine) Composing Suspending Functions","slug":"20210219-coroutine-composing-suspending-functions","date":"2021-02-18T16:25:50.000Z","updated":"2024-01-03T14:01:13.886Z","comments":true,"path":"2021/02/19/20210219-coroutine-composing-suspending-functions/","link":"","permalink":"https://d2fault.github.io/2021/02/19/20210219-coroutine-composing-suspending-functions/","excerpt":"이번 포스팅에서는 코루틴의 일시 중단 함수를 조합하여 활용하는 방법을 알아본다.","text":"Composing Suspending Functions 이번 포스팅에서는 코루틴의 일시 중단 함수를 조합하여 활용하는 방법을 알아본다. ※ IntelliJ나 Android Studio가 설치되어 있지 않다면 Kotlin 공식 사이트에서 지원하는 온라인 IDE(Kotlin Playground)를 사용하여 아래 코드를 실행할 수 있다. Sequential by default 아래 코드는 어떤 유용한 기능(?) 두 가지를 순차적으로 실행 및 조합하여 결과를 내도록 구현되어 있다. 1234567891011121314151617181920fun main() = runBlocking&lt;Unit&gt; &#123; val time = measureTimeMillis &#123; val one = doSomethingUsefulOne() val two = doSomethingUsefulTwo() println(&quot;The answer is $&#123;one + two&#125;&quot;) &#125; println(&quot;Completed in $time ms&quot;) &#125;suspend fun doSomethingUsefulOne(): Int &#123; // pretend we are doing something useful here delay(1000L) return 13&#125;suspend fun doSomethingUsefulTwo(): Int &#123; // pretend we are doing something useful here, too delay(1000L) return 29&#125; 코루틴에서는 일반 코드처럼 작성하면 비동기적인 기능일지라도 순차적으로 실행한다. 즉, 위의 코드는 doSomethingUsefulOne() 실행 doSomethingUsefulTwo() 실행 println(&quot;The answer is $&#123;one + two&#125;&quot;) 실행 순서로 진행된다. Concurrent using async 만약 두 연산에 dependency가 없다면 동시에 실행하는 것이 리소스를 효율적으로 사용할 수 있을 것이다. 아래 코드를 참고하자. 123456789101112131415161718fun main() = runBlocking&lt;Unit&gt; &#123; val time = measureTimeMillis &#123; val one = async &#123; doSomethingUsefulOne() &#125; val two = async &#123; doSomethingUsefulTwo() &#125; println(&quot;The answer is $&#123;one.await() + two.await()&#125;&quot;) &#125; println(&quot;Completed in $time ms&quot;) &#125;suspend fun doSomethingUsefulOne(): Int &#123; delay(1000L) // pretend we are doing something useful here return 13&#125;suspend fun doSomethingUsefulTwo(): Int &#123; delay(1000L) // pretend we are doing something useful here, too return 29&#125; 코루틴 빌더인 async 키워드를 사용하면 비동기를 비동기처럼(?) 동작하게 할 수 있다. Lazily started async async 로 실행하는 코루틴을 ‘나중에’ 실행하는 방법을 보여주는 예제이다. 123456789101112131415161718192021fun main() = runBlocking&lt;Unit&gt; &#123; val time = measureTimeMillis &#123; val one = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulOne() &#125; val two = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulTwo() &#125; // some computation one.start() // start the first one two.start() // start the second one println(&quot;The answer is $&#123;one.await() + two.await()&#125;&quot;) &#125; println(&quot;Completed in $time ms&quot;) &#125;suspend fun doSomethingUsefulOne(): Int &#123; delay(1000L) // pretend we are doing something useful here return 13&#125;suspend fun doSomethingUsefulTwo(): Int &#123; delay(1000L) // pretend we are doing something useful here, too return 29&#125; async 의 매개변수에 start = CoroutineStart.LAZY 를 추가하게 되면 해당 코루틴은 바로 실행되지 않는다. LAZY 가 걸린 코루틴을 start() 하거나 await() 를 해 줄 때 비로소 값을 받을 수 있다. async 는 인자를 받을 수 있는데, 아무 인자도 넣지 않으면 바로 실행하는(start = CoroutineStart.Default) 것이 default이다. 즉, start() 나 await() 를 만나지 않아도 내부적으로는 이미 그 코루틴이 실행된 상태라는 의미이다. 다음의 코드를 실행해 보면 이해가 조금 쉬울 듯하다. 1234567891011121314151617181920212223fun main() = runBlocking&lt;Unit&gt; &#123; var a = 0 var b = 0 val time = measureTimeMillis &#123; val one = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulOne() &#125; val two = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulTwo() &#125; // some computation one.start() // start the first one two.start() // start the second one println(&quot;The answer is $&#123;one.await() + two.await()&#125;&quot;) &#125; println(&quot;Completed in $time ms&quot;) &#125;suspend fun doSomethingUsefulOne(): Int &#123; delay(1000L) // pretend we are doing something useful here return 13&#125;suspend fun doSomethingUsefulTwo(): Int &#123; delay(1000L) // pretend we are doing something useful here, too return 29&#125; 참고 start() 코루틴을 시작한다. 시작할 수 있으면 true, 없으면 false 를 반환한다. await() 이미 start() 된 코루틴의 경우 실행된 값을 반환하고, start() 되기 전 코루틴이라면 실행 및 값을 반환한다. Async-style functions 이렇게 사용하지 마라고 권고하는 내용의 예제이다. async-style의 함수는 exception이 발생했을 때 돌이킬 수 없는 상황에 봉착하게 된다. (exception이 발생되어도 코루틴이 죽지 않고 좀비로 남는 모습을 볼 수 있음.) 123456789101112131415161718192021222324252627282930313233// note that we don&#x27;t have `runBlocking` to the right of `main` in this examplefun main() &#123; val time = measureTimeMillis &#123; // somethingUseful~ 함수는 suspend 함수가 아님(누구나 실행 가능) val one = somethingUsefulOneAsync() val two = somethingUsefulTwoAsync() // but waiting for a result must involve either suspending or blocking. // here we use `runBlocking &#123; ... &#125;` to block the main thread while waiting for the result runBlocking &#123; println(&quot;The answer is $&#123;one.await() + two.await()&#125;&quot;) &#125; &#125; println(&quot;Completed in $time ms&quot;)&#125;fun somethingUsefulOneAsync() = GlobalScope.async &#123; // doSomethingUseful~ 함수는 suspend 함수임 doSomethingUsefulOne()&#125;fun somethingUsefulTwoAsync() = GlobalScope.async &#123; doSomethingUsefulTwo()&#125;suspend fun doSomethingUsefulOne(): Int &#123; delay(1000L) // pretend we are doing something useful here return 13&#125;suspend fun doSomethingUsefulTwo(): Int &#123; delay(1000L) // pretend we are doing something useful here, too return 29&#125; 코루틴을 아무 곳에서나 마구 사용할 수 있게 만든 위와 같은 코드는 절대적으로 지양해야 한다. Structured concurrency with async 이전 예제에서 안 좋은 코드를 예로 들었다면, 이번 코드는 권장하는 스타일을 제안한다. 123456789101112131415161718192021222324fun main() = runBlocking&lt;Unit&gt; &#123; val time = measureTimeMillis &#123; println(&quot;The answer is $&#123;concurrentSum()&#125;&quot;) &#125; println(&quot;Completed in $time ms&quot;) &#125;// coroutineScope로 감싸서 suspend function으로 바꿔주었다.// suspend function은 아무 곳에서나 호출할 수 있는 형태가 아닌 코루틴 내에서만 사용 가능suspend fun concurrentSum(): Int = coroutineScope &#123; val one = async &#123; doSomethingUsefulOne() &#125; val two = async &#123; doSomethingUsefulTwo() &#125; one.await() + two.await()&#125;suspend fun doSomethingUsefulOne(): Int &#123; delay(1000L) // pretend we are doing something useful here return 13&#125;suspend fun doSomethingUsefulTwo(): Int &#123; delay(1000L) // pretend we are doing something useful here, too return 29&#125; 위의 예제처럼 scope 안에서 suspending function들을 조립해서 사용해야 한다. exception이 발생할 경우 코루틴 블록 내부의 모든 코루틴이 취소되어 우리의 코드는 안전할 것임. 코루틴 좀비 해결! Cancellation propagated coroutines hierarchy 아래 예제는 async 로 작성된 코루틴에서 exception이 발생할 경우 어떤 결과가 나타날지 시뮬레이션해 보는 코드이다. 1234567891011121314151617181920212223fun main() = runBlocking&lt;Unit&gt; &#123; try &#123; failedConcurrentSum() &#125; catch(e: ArithmeticException) &#123; println(&quot;Computation failed with ArithmeticException&quot;) &#125;&#125;suspend fun failedConcurrentSum(): Int = coroutineScope &#123; val one = async&lt;Int&gt; &#123; try &#123; delay(Long.MAX_VALUE) // Emulates very long computation 42 &#125; finally &#123; println(&quot;First child was cancelled&quot;) &#125; &#125; val two = async&lt;Int&gt; &#123; println(&quot;Second child throws an exception&quot;) throw ArithmeticException() &#125; one.await() + two.await()&#125; asnyc 로 실행된 코루틴 중 하나의 코루틴에서 exception이 발생할 경우, 이 exception은 다른 코루틴에게 영향을 주어 결국 모든 코루틴이 중단되게 한다. 정리 일반 코드처럼 코틀린 코드를 작성할 경우 순서대로 동작한다. 일반 비동기 코드처럼 동시에 실행하고 싶다면 코루틴 빌더인 async 를 이용하자. 코루틴을 일반 함수로 감싸 아무 곳에서나 실행할 수 있는 미친 짓은 절대로 하지 말자. (exception 터질 때 감당 불가) 참고 코루틴 공식 문서 - Composing Suspending Functions 새차원의 코틀린 코루틴 강좌 #4 - Composing Suspending Functions","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://d2fault.github.io/categories/Programming/Android/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://d2fault.github.io/tags/kotlin/"},{"name":"coroutine","slug":"coroutine","permalink":"https://d2fault.github.io/tags/coroutine/"},{"name":"android","slug":"android","permalink":"https://d2fault.github.io/tags/android/"}]},{"title":"[Kotlin] 코루틴(Coroutine) Cancellation and Timeouts","slug":"20210114-coroutine-cancellation-and-timeouts","date":"2021-01-17T16:45:51.000Z","updated":"2024-01-03T14:01:13.885Z","comments":true,"path":"2021/01/18/20210114-coroutine-cancellation-and-timeouts/","link":"","permalink":"https://d2fault.github.io/2021/01/18/20210114-coroutine-cancellation-and-timeouts/","excerpt":"Composing Suspending Functions 이번 포스팅에서는 코루틴의 일시 중단 함수를 조합하여 활용하는 방법을 알아본다.","text":"Cancellation and Timeouts 이번 게시글에서는 코루틴의 취소와 timeout 처리에 대해 알아보자. ※ IntelliJ나 Android Studio가 설치되어 있지 않다면 Kotlin 공식 사이트에서 지원하는 온라인 IDE(Kotlin Playground)를 사용하여 아래 코드를 실행할 수 있다. Cancelling coroutine execution launch 에서 반환되는 job 객체는 코루틴을 취소할 수 있는 기능을 제공해 준다. 12345678910111213fun main() = runBlocking &#123; val job = launch &#123; repeat(1000) &#123; i -&gt; println(&quot;job: I&#x27;m sleeping $i ...&quot;) delay(500L) &#125; &#125; delay(1300L) // delay a bit println(&quot;main: I&#x27;m tired of waiting!&quot;) job.cancel() // cancels the job job.join() // waits for job&#x27;s completion println(&quot;main: Now I can quit.&quot;)&#125; job.cancel() 을 이용하여 실행 중인 job 을 취소할 수 있다. Cancellation is cooperative 코루틴이 취소되기 위해서는 일종의 조건이 필요하다. 그래서 협력적(cooperative)이라는 단어를 사용한 듯하다. 123456789101112131415161718fun main() = runBlocking &#123; val startTime = System.currentTimeMillis() val job = launch(Dispatchers.Default) &#123; var nextPrintTime = startTime var i = 0 while (i &lt; 5) &#123; // computation loop, just wastes CPU // print a message twice a second if (System.currentTimeMillis() &gt;= nextPrintTime) &#123; println(&quot;job: I&#x27;m sleeping $&#123;i++&#125; ...&quot;) nextPrintTime += 500L &#125; &#125; &#125; delay(1300L) // delay a bit println(&quot;main: I&#x27;m tired of waiting!&quot;) job.cancelAndJoin() // cancels the job and waits for its completion println(&quot;main: Now I can quit.&quot;)&#125; 얼핏 보기에는 위의 코드가 정상적으로 취소될 것 같지만 실제 돌려보면 취소가 되지 않는 것을 볼 수 있다. 코루틴을 취소하려면 해당 코루틴에 suspend 함수가 포함되어야 하는데 위의 launch 안에는 어떠한 suspend 함수도 포함되지 않았기에 원하는 결과가 나오지 않은 것이다. 위의 코드를 취소 가능한 코드로 만드려면 어떻게 해야 할까? 이전 포스팅에 정리했던 대표적인 suspend 함수, delay 를 호출하면 된다. if 문 안에 살짝 추가해 보자. 12345678910111213141516171819fun main() = runBlocking &#123; val startTime = System.currentTimeMillis() val job = launch(Dispatchers.Default) &#123; var nextPrintTime = startTime var i = 0 while (i &lt; 5) &#123; if (System.currentTimeMillis() &gt;= nextPrintTime) &#123; // 이곳에 delay를 추가했다. delay(1L) println(&quot;job: I&#x27;m sleeping $&#123;i++&#125; ...&quot;) nextPrintTime += 500L &#125; &#125; &#125; delay(1300L) println(&quot;main: I&#x27;m tired of waiting!&quot;) job.cancelAndJoin() println(&quot;main: Now I can quit.&quot;)&#125; delay() 하나 추가했을 뿐인데 아주 정상적으로 종료된다. Making computation code cancellable 1. Suspend 함수를 주기적으로 호출 공식적으로 cancellable한 코드로 만드는 방법 두 가지 중 첫 번째 방법이다. 바로 yield! yield를 사용하면 일시중지 및 재개시 exception까지 처리할 수 있다. 12345678910111213141516171819202122232425fun main() = runBlocking &#123; val startTime = System.currentTimeMillis() val job = launch(Dispatchers.Default) &#123; // try-catch로 error message를 출력 try &#123; var nextPrintTime = startTime var i = 0 while (i &lt; 5) &#123; if (System.currentTimeMillis() &gt;= nextPrintTime) &#123; // 이곳에 yield를 추가했다. yield() println(&quot;job: I&#x27;m sleeping $&#123;i++&#125; ...&quot;) nextPrintTime += 500L &#125; &#125; &#125; catch (e: Exception) &#123; kotlin.io.println(&quot;Exception [$e]&quot;) &#125; &#125; delay(1300L) println(&quot;main: I&#x27;m tired of waiting!&quot;) job.cancelAndJoin() println(&quot;main: Now I can quit.&quot;)&#125; 2. 명시적으로 상태(isActive)를 체크하여 코루틴 취소 cancel 요청이 들어오면 isActive 상태가 false 로 변경되어 while 문에서 탈출할 수 있다! 아래 코드로 확인하자. 123456789101112131415161718fun main() = runBlocking &#123; val startTime = System.currentTimeMillis() val job = launch(Dispatchers.Default) &#123; var nextPrintTime = startTime var i = 0 while (isActive) &#123; // cancellable computation loop // print a message twice a second if (System.currentTimeMillis() &gt;= nextPrintTime) &#123; println(&quot;job: I&#x27;m sleeping $&#123;i++&#125; ...&quot;) nextPrintTime += 500L &#125; &#125; &#125; delay(1300L) // delay a bit println(&quot;main: I&#x27;m tired of waiting!&quot;) job.cancelAndJoin() // cancels the job and waits for its completion println(&quot;main: Now I can quit.&quot;)&#125; isActive 를 사용하여 취소될 경우, yield와 다르게 exception 을 던지지 않는다는 차이가 있다. Closing resources with finally 코루틴 종료시 리소스를 어떻게 해제할 수 있는지 알아보는 예제이다. 서버와 통신하거나, DB를 사용할 때 갑자기 코루틴이 종료된다면 해당 리소스를 닫아 주어야 하는데, 이번 예제를 통해 그 방법을 배울 수 있다. 1234567891011121314151617fun main() = runBlocking &#123; val job = launch &#123; try &#123; repeat(1000) &#123; i -&gt; println(&quot;job: I&#x27;m sleeping $i ...&quot;) delay(500L) &#125; &#125; finally &#123; // finally에서 해제해 주면 됨! println(&quot;job: I&#x27;m running finally&quot;) &#125; &#125; delay(1300L) // delay a bit println(&quot;main: I&#x27;m tired of waiting!&quot;) job.cancelAndJoin() // cancels the job and waits for its completion println(&quot;main: Now I can quit.&quot;)&#125; finally 블록 안에 리소스 처리 코드를 작성해 주면 된다. Run non-cancellable block 이미 cancel된 코루틴 안에서 또 코루틴을 호출하여 종료해야 하는 특수 케이스의 예이다. 123456789101112131415161718192021fun main() = runBlocking &#123; val job = launch &#123; try &#123; repeat(1000) &#123; i -&gt; println(&quot;job: I&#x27;m sleeping $i ...&quot;) delay(500L) &#125; &#125; finally &#123; // withContext에 NonCancellable을 전달 withContext(NonCancellable) &#123; println(&quot;job: I&#x27;m running finally&quot;) delay(1000L) println(&quot;job: And I&#x27;ve just delayed for 1 sec because I&#x27;m non-cancellable&quot;) &#125; &#125; &#125; delay(1300L) // delay a bit println(&quot;main: I&#x27;m tired of waiting!&quot;) job.cancelAndJoin() // cancels the job and waits for its completion println(&quot;main: Now I can quit.&quot;) &#125; IDE에서 실행해 보면 종료된 코루틴 안에 코루틴이 돌아서 해당 코루틴이 종료되기 전까지 main 함수가 종료되지 않는 것을 확인할 수 있다. &quot;아직 잠깐 기다려!!! 나 일 하나만 더 하고!!!&quot;의 느낌을 받았다. withTimeout 코루틴을 실행할 때 특정 시간이 지나면 이 코루틴은 취소된다! 라고 timeout을 지정하는 방식이다. 12345678fun main() = runBlocking &#123; withTimeout(1300L) &#123; repeat(1000) &#123; i -&gt; println(&quot;I&#x27;m sleeping $i ...&quot;) delay(500L) &#125; &#125;&#125; 위 예제에서는 1.3초 이후 timeout으로 인해 작업이 중단되지만, runBlocking 으로 내부에서 실행했기 때문에 exception이 발생한다. 이 exception을 해결할 수 있는 키워드를 다음 예제에서 소개한다. withTimeoutOrNull 12345678910fun main() = runBlocking &#123; val result = withTimeoutOrNull(1300L) &#123; repeat(1000) &#123; i -&gt; println(&quot;I&#x27;m sleeping $i ...&quot;) delay(500L) &#125; &quot;Done&quot; // will get cancelled before it produces this result &#125; println(&quot;Result is $result&quot;)&#125; 위의 코드를 실행해 보면 Result is null 이 출력될 것이다. Asynchronous timeout and resources withTimeout 은 해당 블록에서 실행 중인 코드에 대해 비동기로 처리되며, 내부 블록이 반환되기 직전 어디에서든 발생할 수 있다. 블록 내부에서 수정 중인 리소스를 외부에서 사용할 경우 이를 염두하여 코드를 작성해야 한다. 12345678910111213141516171819202122var acquired = 0class Resource &#123; init &#123; acquired++ &#125; // Acquire the resource fun close() &#123; acquired-- &#125; // Release the resource&#125;fun main() &#123; runBlocking &#123; repeat(100_000) &#123; // Launch 100K coroutines launch &#123; val resource = withTimeout(60) &#123; // Timeout of 60 ms delay(50) // Delay for 50 ms Resource() // Acquire a resource and return it from withTimeout block &#125; resource.close() // Release the resource &#125; &#125; &#125; // Outside of runBlocking all coroutines have completed println(acquired) // Print the number of resources still acquired&#125; 컴퓨터 상황이나 사양에 따라 위 코드 결과가 0이 될 수도, 0이 아닐 수도 있다. 그러나 실제로 이 코드에서 0이 아닌 값을 보기 위해서는 예제의 시간을 조정해야 할 것이다. 이 문제를 해결하기 위해 withTimeout 블록에서 return하는 것과 반대로 리소스에 대한 참조를 변수에 저장해둘 수 있다. 123456789101112131415161718192021222324252627var acquired = 0class Resource &#123; init &#123; acquired++ &#125; // Acquire the resource fun close() &#123; acquired-- &#125; // Release the resource&#125;fun main() &#123; runBlocking &#123; repeat(100_000) &#123; // Launch 100K coroutines launch &#123; var resource: Resource? = null // Not acquired yet try &#123; withTimeout(60) &#123; // Timeout of 60 ms delay(50) // Delay for 50 ms resource = Resource() // Store a resource to the variable if acquired &#125; // We can do something else with the resource here &#125; finally &#123; resource?.close() // Release the resource if it was acquired &#125; &#125; &#125; &#125; // Outside of runBlocking all coroutines have completed println(acquired) // Print the number of resources still acquired&#125; 위 코드는 항상 0을 반환한다. 좀 쉽게 풀어서 쓰자면, 외부 리소스를 코루틴 안에서 사용할 때 리소스 참조 변수를 선언 finally 에서 리소스 해제 이 두 가지를 기억하면 좋을 것이다. 참고 코루틴 공식 문서 - Cancellation and Timeouts 새차원의 코틀린 코루틴 강좌 #3 - Cancellation and Timeouts","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://d2fault.github.io/categories/Programming/Android/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://d2fault.github.io/tags/kotlin/"},{"name":"coroutine","slug":"coroutine","permalink":"https://d2fault.github.io/tags/coroutine/"},{"name":"android","slug":"android","permalink":"https://d2fault.github.io/tags/android/"}]},{"title":"[Kotlin] 코루틴(Coroutine) 기본 개념 이해하기","slug":"20210113-coroutine-basic","date":"2021-01-13T13:39:41.000Z","updated":"2024-01-03T14:01:13.883Z","comments":true,"path":"2021/01/13/20210113-coroutine-basic/","link":"","permalink":"https://d2fault.github.io/2021/01/13/20210113-coroutine-basic/","excerpt":"Coroutine? 루틴의 일종으로, 협동 루틴으로 이해하면 쉽다. 코루틴의 \"Co\"는 with, together를 뜻한다. 코루틴은 자신의 실행이 마지막으로 중단된 지점 다음의 포인트부터 동작을 재개한다. 즉, 순차 실행이 가능하다.","text":"Coroutine? 루틴의 일종으로, 협동 루틴으로 이해하면 쉽다. 코루틴의 &quot;Co&quot;는 with, together를 뜻한다. 코루틴은 자신의 실행이 마지막으로 중단된 지점 다음의 포인트부터 동작을 재개한다. 즉, 순차 실행이 가능하다. (tmi) 코루틴 최초의 출판물은 1963년에 등장했다. 러닝 커브는 다음 그림 참고(출처 바로가기) ※ IntelliJ나 Android Studio가 설치되어 있지 않다면 Kotlin 공식 사이트에서 지원하는 온라인 IDE(Kotlin Playground)를 사용하여 아래 코드를 실행할 수 있다. Your First Coroutine 아래 코드를 실행하면, 12345678fun main() &#123; GlobalScope.launch &#123; // launch a new coroutine in background and continue delay(1000L) // non-blocking delay for 1 second (default time unit is ms) println(&quot;World!&quot;) // print after delay &#125; println(&quot;Hello,&quot;) // main thread continues while coroutine is delayed Thread.sleep(2000L) // block main thread for 2 seconds to keep JVM alive&#125; Would!Hello, 가 출력될까? 예상했겠지만, 당연히 답이 아니다. main() 이 실행되고, GlobalScope.launch 에서 1초의 딜레이가 걸린다. 이때 딜레이는 GlobalScope.launch 에만 영향을 주기에 main() 의 코드는 그대로 실행되며, 우리 모두가 아는 Hello,World! 의 출력을 확인할 수 있다. 정확히는 Hello, 출력 후 1초의 딜레이, 그리고 World! 출력 후 1초 딜레이 이후 해당 프로그램이 종료될 것이다. 정리 코루틴은 가벼운 스레드의 일종으로 볼 수 있다. coroutine builder인 launch 를 이용하여 코루틴을 생성할 수 있다. launch 를 사용하기 위해서는 CoroutineScope인 GlobalScope를 사용해야 한다. GlobalScope.launch &#123;&#125; 는 therad &#123;&#125; 로 변환될 수 있다. Bridging blocking and non-blocking worlds Thread.sleep(2000L) 로 끝난 코드를 runBlocking 으로 바꿔보는 예제이다. 이전에, delay 와 sleep 의 차이를 짚고 넘어가자. delay 일시 중단되는(suspend) 함수 sleep thread를 blocking하는 함수 즉, 이번 예제의 목표는 main() 함수에서 suspend 함수 사용법을 배우는 것이다. 아래 코드를 참고하자. 12345678910fun main() &#123; GlobalScope.launch &#123; // launch a new coroutine in background and continue delay(1000L) println(&quot;World!&quot;) &#125; println(&quot;Hello,&quot;) // main thread continues here immediately runBlocking &#123; // but this expression blocks the main thread delay(2000L) // ... while we delay for 2 seconds to keep JVM alive &#125;&#125; runBlocking 을 사용하면 blocking하는 코루틴을 생성할 수 있다. 정리 코루틴 빌더인 runBlocking 을 사용하면 내부 코루틴이 완료될 때까지 메인 스레드가 blocking되어 프로그램이 중단되지 않는다. 코드를 조금 더 깔끔하게 작성할 수는 없을까? 12345678fun main() = runBlocking &#123; GlobalScope.launch &#123; // launch a new coroutine in background and continue delay(1000L) println(&quot;World!&quot;) &#125; println(&quot;Hello,&quot;) // main coroutine continues here immediately delay(2000L) // delaying for 2 seconds to keep JVM alive&#125; main() 함수를 runBlocking 으로 감싸서 전체 flow가 완료되기 전까지 종료되지 않는 코드로 변신! Waiting for a job delay 없이 비동기 작업을 깔끔하기 처리하기 위해서는 job 객체에 join() 하는 방법이 있다. 12345678910fun main() = runBlocking &#123; // launch로 코루틴을 생성하면 job 객체를 반환한다. val job = GlobalScope.launch &#123; delay(1000L) println(&quot;World!&quot;) &#125; println(&quot;Hello,&quot;) // job에 join을 하면 launch로 생성한 코루틴이 종료될 때까지 기다렸다가 프로그램을 종료한다. job.join() // wait until child coroutine completes&#125; 위의 코드를 보고 ‘그럼 runBlocking은 불필요한 것 아닌가?’ 하는 생각이 들어 코드를 지우고 실행하니 정상적으로 동작하지 않았다. join()[1] 은 suspend function으로, 코루틴 내부나 다른 suspend function에서만 실행할 수 있다! 잊지 말 것! 여기서 잠깐! 그럼 main 에 job 을 100개 가지는 코루틴은 job 마다 join 을 전부 해 줘야 하는 걸까? 호엥? 너무 비효율적이잖아? Structured concurrency 그래서 코루틴에서는 이런 비효율을 개선하기 위해 runBlocking 과 launch 의 관계성을 확립하는 구조를 제안한다. 코드를 보자. 12345678fun main() = runBlocking &#123; // this: CoroutineScope, this 생략 가능 this.launch &#123; // launch a new coroutine in the scope of runBlocking delay(1000L) println(&quot;World!&quot;) &#125; println(&quot;Hello,&quot;)&#125; GlobalScope 에서 launch 하지 말고 runBlocking 에서 launch 로 코루틴을 생성하는 방법이다. 이렇게 생성할 경우 코루틴이 몇 개가 생성되든 main 함수는 해당 job 들이 모두 끝나기 전까지 프로그램을 종료하지 않는다. Scope builder 위와 비슷한 방법으로 coroutineScope 를 이용해서 범위를 선언할 수도 있다. 코루틴 범위를 만들고 그 안에서 만들어진 모든 자식 코루틴이 완료되기 전까지 끝나지 않는 방식이다. 언뜻 보면 structured concurrency와 비슷해 보이지만 차이점이 있다. runBlocking 대기하기 위해 현재 스레드를 차단한다. coroutineScope 다른 용도로 사용하기 위해 기본 스레드 상태를 해제한다. 아래 코드 실행 순서를 눈여겨보자. 123456789101112131415fun main() = runBlocking &#123; launch &#123; delay(200L) println(&quot;1. Task from runBlocking&quot;) &#125; coroutineScope &#123; launch &#123; delay(500L) println(&quot;2. Task from nested launch&quot;) &#125; delay(100L) println(&quot;3. Task from coroutine scope&quot;) &#125; println(&quot;4. Coroutine scope is over&quot;)&#125; 편의를 위해 문장에 번호를 추가했다. 어떤 순서로 실행될까? 이 코드를 처음 봤을 때 4-3-1-2 순서[2]로 실행된다고 생각했지만 정답이 아니었다. 위의 코드는 3-1-2-4 순서로 실행된다. 즉, coroutineScope 가 완료되지 않은 상태에서도 3. Task from coroutine scope 바로 뒤에 1. Task from runBlocking 이 실행됨을 알 수 있다. 정리 delay 대신 job.join() 을 이용하면 비동기 작업이 깔끔해진다. join() 은 코루틴 내부나 다른 suspend function에서만 실행할 수 있다. join() 오조 오억 개 쓰기 싫으면 structured concurrency 사용해라. runBlocking 은 대기하기 위해 현재 스레드를 차단(coroutineScope 의 플로우가 모두 실행되기 전까지 4번 문장을 출력하지 않음)한다. coroutineScope 는 다른 스레드를 실행하기 위해 현재 스레드를 suspend한다. 즉, 코루틴을 생성한 최상위 함수가 동일한 스레드에서 계속 실행될 수 있다. Extract function refactoring 코루틴 내부에서 호출할 함수에 delay 등의 suspend 함수를 사용하고 싶다면 다음 코드를 주목하자. 12345678910fun main() = runBlocking &#123; launch &#123; doWorld() &#125; println(&quot;Hello,&quot;)&#125;// this is your first suspending functionsuspend fun doWorld() &#123; delay(1000L) println(&quot;World!&quot;)&#125; 정리 일반 함수를 suspend 함수로 바꾸고 싶다면 suspend 를 붙이면 된다. (심플) Global coroutines are like daemon threads 코루틴이 계속 실행되고 있다고 해서 스레드가 실행 중이라고 볼 수 없다. 프로세스가 살아 있을 때에만 동작할 수 있다. 123456789fun main() = runBlocking &#123; GlobalScope.launch &#123; repeat(1000) &#123; i -&gt; println(&quot;I&#x27;m sleeping $i ...&quot;) delay(500L) &#125; &#125; delay(1300L) // just quit after delay&#125; 위의 코드를 실행시켜 보면 1.3초 이후에는 main 함수가 종료되고, 이와 동시에 repeat() 도 멈추는 것을 확인할 수 있다. 즉, 메인 프로세스가 종료될 경우 그 안에 생성된 코루틴의 동작 또한 모두 중지된다. 참고 코루틴 공식 문서 - Basics 새차원의 코틀린 코루틴 강좌 #2 - basics stack overflow - runBlocking vs coroutineScope 잊지 말자고는 했지만 사실 에러 로그를 너무나도 명확하게 출력해 준다. Suspend function 'join' should be called only from a coroutine or another suspend function ↩︎ coroutiuneScope 를 launch 로 바꿀 경우 4-3-1-2 순서로 실행된다. ↩︎","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://d2fault.github.io/categories/Programming/Android/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://d2fault.github.io/tags/kotlin/"},{"name":"coroutine","slug":"coroutine","permalink":"https://d2fault.github.io/tags/coroutine/"},{"name":"android","slug":"android","permalink":"https://d2fault.github.io/tags/android/"}]},{"title":"[Diary] 2020년 회고하기","slug":"20201231-diary","date":"2020-12-31T13:36:42.000Z","updated":"2024-01-03T14:01:13.866Z","comments":true,"path":"2020/12/31/20201231-diary/","link":"","permalink":"https://d2fault.github.io/2020/12/31/20201231-diary/","excerpt":"","text":"회고 전 반성 늦었다. 그것도 아주 많이. 이 회고는 분명 작년 12월 31일 이전에 작성[1]되어야만 했다. 여느 때와 마찬가지인 여유로운 연말이었으나 아무것도 하지 못했다. 블로그 리뉴얼, 그리고 회고로 마무리하는 2020년! 계획만큼은 완벽했는데. 내 연말 루틴[2]을 박살 낸 코로나 핑계를 대고 싶지만 (응, 아니야~ 너 데스크톱 사서 메이플스토리만 했어…) 왠지 모르게 마음 한쪽이 콕콕 쑤시는 게, 하자면 할 수 있는 상황이었음을 잘 알기 때문일 거야. 반성합니다. 2021년 연말은 절대, 네버, 이렇게 (이따위로) 보내지 않겠습니다. 2019년 회고 살펴보기 야망이 넘치는 모습을 2019년 회고에서 찾아볼 수 있었다. 내년의 곡은 오마이걸의 게릴라(Guerilla)! 때를 기다리고 덮칠 거야!!! PO야망WER!!! 갑자기 그때의 내가 떠오른다. 어떤 사건 때문에 야망을 품을 수밖에 없었는데, 힘듦을 추진력으로 잘 써먹었다고 생각한다. 충분히 칭찬할 일이야! 2020: 혼돈의 카오스 넘치는 야망으로 해결할 수 없는 크리티컬한 문제가 있었다. 이름하여 COVID-19. 2020년은 코로나를 빼곤 설명할 수 없다. 어색하던 마스크는 필수가 되었고, 마스크 없이 살던 삶은 까마득해졌다. 나란 사람 청개구리 심보 가득한 집순이. 강제 집콕은 행복했지만, 너무 괴로웠다. 재택근무 좋아요, 강제 집콕 싫어요. 그래도 포기할 수 없어, 매시업 문을 두드릴 여유와 용기가 없어서 생각만 삼 년을 했다. 그런데 더는 실력 없이 고여가는 내 모습을 두고볼 수 없었다. 행동하지 않으면 끝일 것만 같은 불안함이 나를 움직였다. 결단과 행동이 늘 좋은 결과로 나타나는 것은 아니지만 운이 따랐나 보다. 그렇게 매시업은 봄과 함께 찾아왔다. 말로만 하던 코틀린을 드디어? 맛만 봤다. 코틀린 인 액션 책을 보긴 했는데, 그리고 예제를 만들긴 했는데 세상이 바뀌어도 너무 바뀌었다. 안드로이드를 잠깐 놓은 동안, 단말 종속성이 있고 뷰가 없는 안드로이드 개발을 하는 동안 천지개벽이 일어났네? 겁이 났다. ‘시작은 했는데 잘할 수 있을까?’ 총체적 난국이라는 말은 이럴 때 쓰는 건가 봐. 사실 코틀린만의 문제는 아냐 헤헤, 라떼는 분명 MVC만 썼던 것 같은데 뭐가 이렇게 많지요? (ㅋㅎㅋㅎㅋㅎ) MVP, MVVM, MVI요? Data Binding에, rxjava나 coroutine 그리고 koin과 hilt 모두 처음인데다가, room도 안 쓰고 있었으니 말 다했지. 사실 아직도 잘 모른다. 많은 것을 쥐고 싶었는데 이렇다할 결과는 아직이다. 난 습득과 적용이 빠른 사람은 아니다. 이번 고비를 넘기기까지 많은 시간이 필요하겠지만, 그래도 처음보다 지금이 낫다면 성공한 거 아냐? 이 합리화는 남들보다 느린 나를 위로하는 나만의 방식이다. iOS요? 제가요? 네, 제가요. 드디어 입문했네요. 거창한 목표로 시작한 건 아니었다. 맥북 유저로 늘 ‘맥북도 쓰는데 언젠가 iOS 개발 한번 해야지!’ 라고 생각하던 중 좋은 기회가 왔달까. 비대면으로 시작해서 대면으로 끝났던, 그래서 더 좋았던 스터디. 이 스터디를 처음부터 끝까지 열정적으로 이끌어준 친구에게 진심으로 감사하다. 그 친구의 칭찬과 작은 성취로 바닥을 기던 자신감을 조금은 회복했으니까. 아이러니하게도 iOS 스터디 내내 안드로이드를 처음 시작한 그때가 떠올랐다. 개발이 재미있어서 나를 새벽까지 몰아세우는 게 너무 오랜만이었기 때문이겠지. 아쉬움이 남는 첫 해커톤, TICH 해커톤이 끝나고 쓴 회고를 보면, 팀이 아닌 내가 문제였다는 결론에 이른다. 빈 부분이 어딘지 알았으니까 조금씩 채워가면 된다고 해 줘! (ㅠㅠ) 온라인으로요? 이것까지요? 온라인 모각작, 온라인 스터디, 랜선 회식 등 온라인으로 할 수 있는 모든 것을 매시업과 함께하며 집 밖을 나가지 않으면 생산적인 일을 하지 못하던 (하더라도 아주 드문) 내가 바뀌었다. 진절머리나는 코로나가 준 유일한 이점은 비대면으로 이동 시간이 줄고, 온라인으로 무언가를 함께하는 게 자연스러워졌다는 거 아닐까. 비대면이 익숙해지는 요즈음, 상상 속 미래에 사는 기분이다. 재미있는데 재미없어 재미가 없는데 있어: Data 2월부터 시작된 데이터 분석은 정체성 혼란을 야기했다. 머리를 쥐어짜도 안 나오는 쿼리로 괴로움에 허우적댔고, gephi라는 비주얼라이징 툴도 사용해 봤다. 그래도 어찌저찌 나름 의미 있는 분석 결과과 나와서 천만다행이었다. 덕분에 다섯 번의 발표를 진행한 건 함정. 폭풍 칭찬 들은 건 안 함정!!! 그런데 왜 ADSP 시험은 떨어졌을까! 공부 안 하고 떨어진 거면 억울하지나 않지! 억지로 공부한다고 주말을 헌납했는데 공부 방법이 잘못됐었다. 단원 끝에 있는 문제가 아닌 맨 뒤에 포함된 기출문제를 풀었어야 했는데 그거 빼고 다 푼 거 실화냐. 어쨌거나 자격증 공부는 너무너무 싫다. 재미가 하나도 없어. 어찌저찌 AI 관련 사내 자격증을 땄고, 또 어찌저찌 텐서플로우 입문까진 했다. 잠깐 놓았더니 다 까먹은 건 비밀이긴 한데, 적어놓고 보니 1년 내내 데이터와 싸웠다는 사실은 명백하네. 해야 해서 한 일이지만 의미가 있는 일이라 좋았다. 의미 없는 해야만 하는 일보다 백 배 천 배는 나으니까! 문화생활? 0, 0, 0, 0 뮤지컬 0회, 연극 0회, 콘서트 0회, 페스티벌 0회에 빛나는 2020. 뮤지컬은 정말 가고 싶었는데 썸씽로튼 예매까지 다 하고 취소하길 몇 번, 결국 코로나가 마음에 걸려서 못 갔다. 온라인 콘서트는 고민만 하다가 drop. 콘서트는 역시 스탠딩이지. 직접 가서 부딪히는 맛으로 가는 건데 이게 뭐냐고. 하긴, 영화관도 거의 못 갔는데 다른 문화를 즐길 수 있었을리가 없다. 그래도 꾸준했던 취미 취미 없이 행복할 수 없는 사람이다. 코로나가 득실대도 숨구멍을 포기할 순 없지! 밖에서 즐기는 문화생활 대신, 집에서 안전하게 즐길 수 있는 것들 위주로 지속했다. 그중 대표적인 취미는 독서! Notion에 읽은 책을 정리하기 시작했다. 읽을 때 와장창 읽는 건 기분 탓인 줄 알았는데 표로 확인하니 기분이 이상하네. 그래도 어떻게 일 년에 무려 35권의 책을 완독했다! 요새 내 문장력과 단어 수준이 떨어지는 걸 느껴서 의도적으로 소설을 많이 읽으려 한다. 여전히 노래도 열심히 부른다. 정말 많이 늘었다. 시간 투자 대비 아웃풋이 나쁘지 않아서 뿌듯하다. 많은 사람들 앞에서 부르기엔 부족함이 많지만 취미로 부르는 거니까 괜찮아! Garageband를 이용해서 해본 녹음도 너무 재미있었다. (사흘 가지고 놀았다. ㅋㅋ) 2월부터 하려고 했던 운동은 6월이 되어서야 시작했다. 코로나 무서워서 미루기엔 영영 못할 것 같아서 눈 딱 감고 질렀다. 효과는 뛰어났다! 힘이 없던 손가락과 팔에 힘이 생겼고, 체력이 조금씩 늘기 시작했다. 체력이 느니 여유가 생겼고, 여유가 생기니 퇴근 이후의 삶이 풍요로워졌다. 그리고 가장 큰 변화! 운동한 게 아까워서 좋아하는 술을 다 참는다. 그래도 술 좋아! 처음이자 마지막이 된 차박도 있었다. 난 차박에 늘 진심이었다고! 마침 스트레스가 극에 달한 상태여서 행동했다. 밤에 보는 한강이 그렇게 좋은 줄 몰랐지. 기회가 되면 또 가려고 한다. 새벽에 비가 와서 우중 차박까지 경험해서 더 더 행복했다. 사실 차박보다 당일치기 여행을 더 자주 다녔다. 운전도 취미가 돼서 행복하다. 포천, 속초, 주문진, 인천, 청주 등 최대한 사람들과 마주치지 않는 선에서 안전하게 즐기고 돌아왔다. 2020 어워즈 올해의 명반 스텔라장-STELLA I 질리지 않는 띵곡 정세운-온도차 비투비-My Lady 기억에 남는 영화 삼진그룹 토익반 기분 좋았던 책 달러구트 꿈 백화점 Best of best 책 여자의 독서 역사의 쓸모 사랑의 생애 을의 철학 그리고 진급했다. 연초에는 큰 생각 없었는데 평가 기간이 다가올수록 쫄렸던 그 기분 잊지 못한다. 진급이라 쓰고 누락 피하기라고 읽지만 나 하나를 위해 희생하고 도와준 사람들이 너무 많았음을 알기에 여전히 미안하고 감사하다. 한편으로는 걱정도 된다. 신입 때와 지금을 비교하면 크게 달라진 건 없는 것 같은데, 시간이 나를 대리로 만들었다. 조금 더 책임감 있는, 믿을 수 있는 사람이 되어야겠다. 회고를 마무리하며 매년 회고를 쓰면 작년 목표를 평가하는 재미를 느낄 수 있다. 내년에 무조건 개발 동호회든 동아리든 스터디든 어디라도 들어갈 것이다. 강제성을 부여해서 올해보다 더 이룬 게 많은 해로 만들 것임. 그렇게 얻은 거 기록으로 남기는 건 덤. 몇 년째 적성 못 찾고 헤매는데, 코틀린 이용한 안드로이드 개발 먼저 시작할 것이다. 언제까지 이대로 있을 순 없다. 꾸준한 보컬 레슨과 한 달에 한 권 이상 책 읽고 필사하기도 잊을 수 없지. 분명 2019보다 구체적인 목표라고 적혀 있었는데 어디가 구체적인 건지 잘 모르겠다. 개발 동아리 성공, 얻은 거 기록으로 남기기 실패, 코틀린 안드로이드 성공, 보컬 레슨 성공, 한 달에 한 권 이상 책 읽기 성공, 필사하기 실패. 총 4/6으로 이룬 거 50% 넘었다! 작년에 이루지 못했던 2019 목표도 일부 이뤄서[3] 신기하고 재미있다. 그럼 2021년 목표도 세워는 게 인지상정! 가장 먼저, 운동 놓지 않고 꾸준히 하기를 꼽고 싶다. 운동으로 얻은 이점이 많아. 잠깐 쉴 수는 있겠지만 그만두지 않았으면 한다. 노래, 책, 운동은 올해도 안고 가는 걸로. 약간의 욕심을 부리자면 오토 트레이딩 시스템을 만들어 보고 싶기는 한데… 블로그 리뉴얼을 먼저 끝내고 꾸준히 포스팅하는 게 우선이라고 봅니다. 안드로이드 개발 실력은 지금보다 150% 올리고 싶습니다. (주관적인 수치 주의) 어쨌거나 (본론), 2021년은 사랑과 애정으로 따뜻함이 넘치는 한해가 되길 기도하며 비투비포유의 Show your love 을 새해 첫곡으로 선정했다. 어둠이 내려 앞이 보이지 않아 길을 잃었어 이 세상은 왜 아름답기보단 아프기만 한지? 많은 사람이 넘어지고 많은 눈물이 넘쳐흘러 우린 필요해요 서로에게 힘이 돼야 해, oh 모두가 필요해 L-O-V-E 나도 알아 요새 많이 힘들었지 (I know) 귀 빌려줄 테니, 말해봐 문제가 뭔지 I’ll be here for you whenever you need (woo) 이제 말해줘 어렵지 않아, babe 사랑이란 말 아끼지 말고 Everybody singing “Show Your Love” (ooh-ooh) Show your love (ooh-ooh) 사랑보다 더 큰 힘은 없어, 그것뿐이면 돼 Say your love (ooh-ooh), say your love (ooh-ooh) 사랑이 더 더 퍼지게 다시 웃을 수 있게 Just like a star, I’ll be by your side 어둠을 밝혀 내가 너의 빛이 되어 줄게 (yeah, yeah) 두려워하지 마 (eh) 거짓말 같은 이 밤도 모든 게 꿈처럼 희미해질 거야 서로 꼭 안아줘, show your love, I love ya (ay, eh) 이제 말해줘 어렵지 않아, babe 사랑이란 말 아끼지 말고 Everybody singing, “Show Your Love” (ooh-ooh) Show your love (ooh-ooh) 사랑보다 더 큰 힘은 없어, 그것뿐이면 돼 Say your love (ooh-ooh), say your love (ooh-ooh) 사랑이 더 더 퍼지게 다시 웃을 수 있게 Two is better than one 'cause we’ll be stronger together 우린 사랑이 필요해, yeah, we need each other 힘들다고 약한 건 절대 아니니까 모두가 필요해 가끔 someone to lean on You never know, know that life goes on 다시금 온 세상에 필 웃음꽃 love 소리 높여 노래 불러, 더 크게 소리 질러 온 세상에 닿도록 show your love Everybody singing Show Your Love (ooh-ooh) Show your love (ooh-ooh) 사랑보다 더 큰 힘은 없어, 그것뿐이면 돼 Say your love (ooh-ooh), say your love (ooh-ooh) 사랑이 더 더 퍼지게 다시 웃을 수 있게 La-la-la-la-la-la-la-la-la-la-la La-la-la-la-la-la-la, love La-la-la-la-la-la-la-la-la-la-la La-la-la-la-la, 다시 웃을 수 있게 사랑보다 더 큰 힘은 없대. 사랑하고 감사하며 살아가야지. P.S. 회고 마무리까지 디스코드에서 함께 놀아준 black-jin, MW, MJ 고맙습니다! 작성 일자만 살짝 바꿔서 올린 건 함정. 지금은 2021년 2월이다. 무려 2월이다. 2월, 2월, 2월!!! ↩︎ 카페에서 맥북과 함께 일년을 회고하며 보내는 것을 의미한다. 사람 구경도 하고, 유튜브도 좀 보고 그런 거… ↩︎ 운동 시작한 거! ↩︎","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Diary","slug":"Anything/Diary","permalink":"https://d2fault.github.io/categories/Anything/Diary/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://d2fault.github.io/tags/%ED%9A%8C%EA%B3%A0/"}]},{"title":"[Movie] 카페 벨에포크","slug":"20200531-movie-la-belle-epoque","date":"2020-05-31T12:24:16.000Z","updated":"2021-03-04T05:31:57.826Z","comments":true,"path":"2020/05/31/20200531-movie-la-belle-epoque/","link":"","permalink":"https://d2fault.github.io/2020/05/31/20200531-movie-la-belle-epoque/","excerpt":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 결혼 생활을 적나라하게 그린 영화여서 원래 없던 환상마저 부서졌다. 아무리 운명적인 만남으로 시작하더라도 끝은 정해져 있는 건가 싶기도 하고.","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 결혼 생활을 적나라하게 그린 영화여서 원래 없던 환상마저 부서졌다. 아무리 운명적인 만남으로 시작하더라도 끝은 정해져 있는 건가 싶기도 하고. 그런데 역설적으로 '돌아가고 싶은 순간’을 생각하게 하는 작품이었다. 내가 나이를 더 먹는다면 지금 이 순간으로 돌아오고 싶어질까? 아직까진 모르겠다. 난 아직 돌리고 싶은 순간이 없다. 최선의 선택으로 이루어진 최선의 삶을 사는 중이라는 생각은 틀림을 인정하기 싫은 내 억지일까? 마냥 억지라고 하기엔 난 꽤 잘 살고 있는걸. 뜬금없지만 영화를 본 다음날 우연히 들은, 항상 듣던 이 곡의 느낌이 미묘하게 달라졌다. 생경해. 평점 매우 괜찮은 영상미와 인상적인 배우들의 연기, 생각하게 하는 시나리오. (9.0/10.0)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Android] 무선으로 adb 연결하기(Feat.wifi)","slug":"20200418-adb-connect-without-usb","date":"2020-04-18T05:18:12.000Z","updated":"2021-03-04T05:31:57.826Z","comments":true,"path":"2020/04/18/20200418-adb-connect-without-usb/","link":"","permalink":"https://d2fault.github.io/2020/04/18/20200418-adb-connect-without-usb/","excerpt":"개요 다른 기기에는 잘만(이라고 하지만 잘 안 붙었음) 붙던 adb가 핸드폰에 붙이려니 잘 안 붙어서 정리해 본다. adb 무선 연결 방법 컴퓨터(노트북)와 스마트폰을 같은 Wifi, 혹은 공유기에 연결한다. USB 케이블을 이용, 컴퓨터와 스마트폰을 연결한다.","text":"개요 다른 기기에는 잘만(이라고 하지만 잘 안 붙었음) 붙던 adb가 핸드폰에 붙이려니 잘 안 붙어서 정리해 본다. adb 무선 연결 방법 컴퓨터(노트북)와 스마트폰을 같은 Wifi, 혹은 공유기에 연결한다. USB 케이블을 이용, 컴퓨터와 스마트폰을 연결한다. 스마트폰에 뜨는 alert에서 '이 컴퓨터에서 디버그 허용’을 선택해 준다. cmd나 terminal을 열어 다음의 명령어를 입력한다. 이 설정 안 해 줘서 안 붙었던 거였음. 1adb tcpip 5555 adb를 찾을 수 없다는 로그가 찍힐 경우 adb가 설치된 경로에서 실행하거나 환경 변수를 설정하고 cmd 창을 다시 켜서 실행하면 됨. 정상 실행시 restarting in TCP mode port: 5555 라는 로그가 뜨고 adb가 재실행될 것이다. 스마트폰의 USB 연결을 해제한다. 스마트폰의 IP를 알아낸다. public IP가 아닌 private IP로 연결해야 하며, 설정 - Wifi - Wifi 고급 설정(또는 Wifi 설정) - IP 주소 로 확인 가능하다. (핸드폰마다 접근 방식 다를 수 있음.) 다음의 명령어를 입력한다. 1adb connect &lt;IP&gt;:5555 connected to &lt;IP&gt;:5555 로그가 찍히면 성공! 번외 adb 연결된 기기 확인 adb devices adb 연결 해제 adb disconnect adb server 중지 adb kill-server adb server 시작 adb start-server 참고 블로그 미르의 IT 정복기","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://d2fault.github.io/categories/Programming/Android/"}],"tags":[{"name":"adb","slug":"adb","permalink":"https://d2fault.github.io/tags/adb/"}]},{"title":"[Android] R 에러로 인한 Build 실패 해결 방법","slug":"20200323-solving-r-error","date":"2020-03-23T00:13:23.000Z","updated":"2021-03-04T05:31:57.791Z","comments":true,"path":"2020/03/23/20200323-solving-r-error/","link":"","permalink":"https://d2fault.github.io/2020/03/23/20200323-solving-r-error/","excerpt":"개요 본격적으로 코틀린 안드로이드 개발을 하기도 전에 벌써 괴롭다. Toolbar에 검색 기능을 넣고 싶어 R.menu를 추가하려고 했더니… unsolved reference menu 에러가 났다. 이것저것 버전 변경도 시도해 봤지만 결과는 실패.","text":"개요 본격적으로 코틀린 안드로이드 개발을 하기도 전에 벌써 괴롭다. Toolbar에 검색 기능을 넣고 싶어 R.menu를 추가하려고 했더니… unsolved reference menu 에러가 났다. 이것저것 버전 변경도 시도해 봤지만 결과는 실패. 하, 그런데 막상 해결해 보니 너무 간단해서 우울하다. 분명 했던 방법인데 왜 기억이 안 났지? 이걸 보는 모든 분들에게 안드로이드 신의 가호가 있길. ㅠㅠ 1차 시도: Clean and Rebuild 우선적으로 할 수 있는 건 기존의 build 찌꺼기를 날리고 다시 빌드하는 방법이다. Build - Clean Project 를 과감하게 클릭한다. Build - Rebuild Project 로 다시 빌드한다. 웬만하면 여기에서 다 해결이 된다. 그 말은, 해결되지 않는 경우도 있다는 뜻이다. (내 경우가 그랬다.) 2차 시도: Cache 삭제 및 IDE 재시작 두 번째로 할 수 있는 방법은 Cache를 싸악 지우는 방법이다. File - Invalidate Caches / Restart 를 선택하자. 캐시 삭제와 재시작을 동시에 실행하자. 어지간하면 여기에서 해결이 된다. 결론 12345while(!success) &#123; cleanProject(); rebuildProject(); invalidateCaches();&#125; (클린 - 리빌드 - 캐시 삭제 및 재시작 반복 외의 다른 방법은 모르겠다는 뜻)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://d2fault.github.io/categories/Programming/Android/"}],"tags":[]},{"title":"[Git] Windows에서 clone 시 Authentication failed 에러 해결","slug":"20200115-resolve-authentication-failure-on-git-clone","date":"2020-01-15T06:04:26.000Z","updated":"2021-03-04T05:31:57.765Z","comments":true,"path":"2020/01/15/20200115-resolve-authentication-failure-on-git-clone/","link":"","permalink":"https://d2fault.github.io/2020/01/15/20200115-resolve-authentication-failure-on-git-clone/","excerpt":"git clone 자격 증명 에러 gitlab 사용 시 clone할 때 아래와 같이 Access denied가 나는 경우가 있다. 이 문제는 높은 확률로 ID와 PW가(자격 증명) 맞지 않아 생긴다. 해결 방법 윈도우에 저장된 자격 증명을 바른 ID, PW로 편집하거나 삭제 후 재로그인하면 해결된다.","text":"git clone 자격 증명 에러 gitlab 사용 시 clone할 때 아래와 같이 Access denied가 나는 경우가 있다. 1234$ git clone https://gitlab.com/d2fault/sample.gitCloning into &#x27;sample&#x27;...remote: HTTP Basic: Access deniedfatal: Authentication failed for &#x27;https://gitlab.com/d2fault/sample.git/&#x27; 이 문제는 높은 확률로 ID와 PW가(자격 증명) 맞지 않아 생긴다. 해결 방법 윈도우에 저장된 자격 증명을 바른 ID, PW로 편집하거나 삭제 후 재로그인하면 해결된다. 이 포스팅에서는 Windows 10을 기준으로 설명할 것이나, 제어판에만 진입하면 이후 프로세스는 동일하다. 시작(윈도우) 버튼 - 설정 버튼(톱니바퀴) 를 클릭한다. 설정 검색 창에서 제어판을 검색한다. 제어판으로 새 윈도우가 뜨면, 사용자 계정을 클릭한다. 아래와 같이, 자격 증명 관리자가 뜬다. 자격 증명 관리자를 클릭해도 되고, 바로 Windows 자격 증명 관리를 선택해도 된다. Windows 자격 증명 관리를 선택하면 윈도우에 저장된 모든 자격 증명이 출력된다. 여기에서, 접근이 제한되었던 git의 주소를 선택하면 자격 증명을 편집하거나 제거할 수 있는 버튼이 나온다. 편집 버튼을 누르면 ID와 PW를 설정할 수 있다. 올바른 ID와 PW를 입력한 다음 clone을 시도한다. 동일 증상이 반복될 경우 ID와 PW가 틀렸을 확률이 매우 높으므로 확인해 보아야 한다.","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Others","slug":"IT/Others","permalink":"https://d2fault.github.io/categories/IT/Others/"}],"tags":[{"name":"git","slug":"git","permalink":"https://d2fault.github.io/tags/git/"},{"name":"tip","slug":"tip","permalink":"https://d2fault.github.io/tags/tip/"},{"name":"자격 증명","slug":"자격-증명","permalink":"https://d2fault.github.io/tags/%EC%9E%90%EA%B2%A9-%EC%A6%9D%EB%AA%85/"}]},{"title":"[Android] Kotlin으로 안드로이드 개발하기(1) - Hello World!","slug":"20200103-develop-android-with-kotlin-1","date":"2020-01-03T09:05:46.000Z","updated":"2024-01-03T14:01:13.864Z","comments":true,"path":"2020/01/03/20200103-develop-android-with-kotlin-1/","link":"","permalink":"https://d2fault.github.io/2020/01/03/20200103-develop-android-with-kotlin-1/","excerpt":"개요 개발 환경은 다 세팅되어 있다고 가정한 상태로 포스팅을 시작할 것이다. 안알못 (안드로이드를 알지 못하는) 의 마음으로 Hello World!부터 찍어 본다. 혹시 모를 상황을 대비해 캡처도 잊지 않았습니다.","text":"개요 개발 환경은 다 세팅되어 있다고 가정한 상태로 포스팅을 시작할 것이다. 안알못 (안드로이드를 알지 못하는) 의 마음으로 Hello World!부터 찍어 본다. 혹시 모를 상황을 대비해 캡처도 잊지 않았습니다. 차근차근 따라하시면 Hello World! 는 뭐, 그냥 찍어요. 시작이 반이지만 항상 문제는 그 이후…아니, 그냥 시작해 볼게요. 프로젝트 생성하기 안드로이드 스튜디오를 처음 실행하면 이런 창이 뜬다. 첫번째 버튼인 Start a new Android Studio project 를 클릭한다. 단, 기존에 실행한 프로젝트가 띄워진 상태라면 위의 창이 뜨지 않는다. 이럴 경우, File - Close Project 로 프로젝트를 종료하거나 File - New - New Project 로 프로젝트를 생성하면 된다. 가장 심플한 Empty Activity 선택 후 Next를 누른다. Name에는 프로젝트 이름을 적으면 된다. 코틀린 입문이기 때문에 임의로 KotlinTest 로 지정해 보았다.Name의 첫 글자는 대문자여야 하며, Minimum API level은 21로 지정했다. 프로젝트가 생성되고 에디터 창이 열린 상태이다. 이 상태로는 Hello World! 를 확인할 수 없다. 에뮬레이터[1]를 돌려 보자. 에뮬레이터가 이미 설정되어 있으면 중앙 상단 쯤에 있는 초록색 ▶︎ 버튼으로 빠른 실행 가능하지만, 설정되지 않은 상태라면 다음의 과정을 거쳐야 한다. 에뮬레이터 설정하기 에뮬레이터를 설정해 보자. 위와 같이, No devices - Open ADB Manager 를 클릭하면 다음의 창이 뜬다. Create Virtual Device 를 클릭한다. 원하는 Device를 선택하면 된다. 임의로 Nexus 5를 택했다. 컴퓨터 사양에 따라 Play Store 표시가 있는 디바이스의 경우 실행이 더딜 수 있으니 유의해야 한다. Next 를 클릭하면 아래처럼 안드로이드 버전을 선택하는 창이 뜬다. 이 또한 원하는 버전[2]을 선택면 된다. 다운로드를 누르면 설치가 진행된다. 설치 완료 후 상세 설정을 해 보자. 사실 이 부분에서 크게 손댈 것은 없다. 그나마 자주 바꾸는 부분이 AVD Name 정도이다. 에뮬레이터 이름을 뜻하며, 기본 설정 값으로 두어도 문제되지 않는다. Hello World! 출력하기 아래 사진을 참고하여 중앙 상단 쯤에 있는 초록색 ▶︎ 버튼을 누르거나, ctrl + R을 누른다. 에뮬레이터가 동작하며 Hello World!가 출력된다. 결론: 초록색 플레이 버튼만 누르면 Hello World!가 출력된다. 안드로이드 디바이스에 apk 설치 후 확인할 수도 있다. 절대 연결 과정이나 adb 붙는 게 귀찮아서 에뮬레이터 돌린 거 맞음. ↩︎ 글쓴이는 Oreo(8.1)를 선택함. ↩︎","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://d2fault.github.io/categories/Programming/Android/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://d2fault.github.io/tags/kotlin/"},{"name":"코틀린","slug":"코틀린","permalink":"https://d2fault.github.io/tags/%EC%BD%94%ED%8B%80%EB%A6%B0/"},{"name":"android","slug":"android","permalink":"https://d2fault.github.io/tags/android/"}]},{"title":"[Diary] 2019년 회고하기","slug":"20191231-diary","date":"2019-12-31T12:36:45.000Z","updated":"2021-03-04T05:31:57.613Z","comments":true,"path":"2019/12/31/20191231-diary/","link":"","permalink":"https://d2fault.github.io/2019/12/31/20191231-diary/","excerpt":"회고를 시작하며 회고를 보다 2018의 갈무리와 2019의 다짐이 혼재하는 작년의 회고를 펼쳤다. 내년의 곡은 이홍기의 Cookies(Feat.정일훈)이다. 더 자유롭게 날아가길 바라는 마음을 담아. 올해도 역시나 음악과 같은 삶을 살았구나, 싶다.","text":"회고를 시작하며 회고를 보다 2018의 갈무리와 2019의 다짐이 혼재하는 작년의 회고를 펼쳤다. 내년의 곡은 이홍기의 Cookies(Feat.정일훈)이다. 더 자유롭게 날아가길 바라는 마음을 담아. 올해도 역시나 음악과 같은 삶을 살았구나, 싶다. 작년보다 더 행복하길 바라며 이 곡을 들었다. 어떻게 보면 개썅마이웨이[1]가 목표였을 수도. (ㅋㅋㅋ) 결과적으로 행복했으면 됐지, 뭐. 우당탕탕 2019 작년 말, 큰 인사이동이 있었다. 감당하기 힘든 일들이 많았지만 굴복하진 않았다. 하긴, 힘든 일이 언제는 없었겠냐만 어째 강도가 매년 거세지는 듯하다. ‘이 이상은 없겠지?’ 하면 “힝 속았지!” 하고 이벤트가 빵빵 터진다. 그럼에도 불구하고, 감당하기 힘든 일들을 잘 견뎌낸 내가 너무너무 자랑스럽다. 본론으로 돌아와서, 작년의 인사이동으로 업무가 크게 바뀌었다. 이전으로의 회귀? 정도로 보는 게 적당할 것 같다. 나는 여전히 Java를 모르면서 (코틀린은 또 입으로만 공부했지???) 안드로이드 개발을 한다. 구관이 명관이라고(?) 손이 많이 가는 귀찮은 일과, 내가 처리하기 어려운 일들이 마구 터져도 작년보다 행복한 건 확실하다. 토이 프로젝트에 엮여 Vue.js에 입문했다. 자의 반 타의 반 (실은 타의가 80%) 으로 시작한 프로젝트였다. 강제성이 있을 때 효율이 극대화되는 타입임을 알기에, 힘들었던 당시에도 차라리 잘됐다고 생각했던 것 같다. 그런 마음으로도 힘든 건 피할 수 없었다. 마지막에 후회하지 않을 거라는 집념으로 간신히 버텼다. 조금 긴 기간의 해커톤 느낌? 그래도 그 과정(개발만)과 결과가 좋아 참 다행이다. 그 외에도 처음 해 본 것들이 많았다. Docker와 Kubernetes, 그리고 Spring을 아주 조금(?) 이해하게 되었고, Redis와 사투를 펼쳤다. 그 사투 덕분에 설계의 중요성을 뼈저리게 깨달았으며, 써도 되는 곳과 써선 안 되는 곳을 구분하는 사람이 되어야겠다고 다짐했다. 취미 레슨 짱짱 비밀스러운 취미 덕에 3주 차 일요일마다 청주에 간다. 목적은 강의! 꽤 오래 유지 중인 취미인데, 뭔지는 안 알랴쥼~ 이전보다 많이 발전했고, 앞으로도 발전할 예정이다. 2월부터 6월까지 피아노 레슨도 받았다. 계속하고 싶었는데 어쩌다 보니 흐지부지 끝났다. 그래도 집에 디지털 피아노를 들여서 언제든 칠 수 있다. 레슨 중간에 그만둔 거라 완곡하지 못한 곡들이 많은데 그래도 끝낸 게 더 많으니 그걸로 됐다. 무엇보다 Flower Dance를 완곡하다니! 이건 아주 아주 대단한 일이다. 내 피아노 전성기(?)에도 시도하지 못했던 곡이니까! 그리고 11월부터 지금까지(앞으로도) 보컬 레슨받는 중이다. 공강 시간마다 코인 노래방 다니던 사랑 어디 안 간다. 잠깐의 권태기(?)를 극복하고 레슨에 입문했다. 가장 힘든 월, 화요일을 버티기 위해 레슨은 주로 수, 목요일에 잡는다. 이거 하나 보고 버티는 거지, 뭐. 어차피 목, 금은 주말 보고 버티는 거 아닙니까. 아, 엄마한테 받은 운전 연수도 넣어야지. 집 사기 전까지 절대 사지 않겠다던 차를 샀다. 장롱만 8년차, 면허 딴 이후로 시동도 안 걸어 봤는데 정신 차리니 계약하고 있더라. 잘 몰지 걱정했는데 걱정할 필요가 없었다. 삶의 질이 달라졌다. 8월에 받아서 이제 4개월 됐는데 5,000km 조금 모자라게 탐. 경주도 다녀옴! (운전도 취미가 됐다.) 문화생활은? 뮤지컬 1회(레베카), 연극 1회, 콘서트 4회(이창섭, 이민혁, 임현식), 페스티벌 1회(썸데이 페스티벌), 여러 영화(4dx도 두 편이나 봄), 음악, 그리고 책까지! 2019는 문화의 해라고 해도 손색없다. 올해의 명반&amp;가장 좋았던 콘서트는 임현식의 RENDEZ-VOUS, 질리지 않는 띵곡은 넬&amp;그루비룸의 오늘은. 하이라이트가 제일 많았던 책은 김민철 작가의 하루의 취향. 기분 좋았던 영화는 알라딘, 로맨틱 코미디를 다큐로 본 영화는 가장 보통의 연애. 12월 17일에 맞춰 리디 셀렉트 구독도 시작했다. '한 달에 한 권만 읽어도 이득!'이라는 생각으로 아주 가볍게 구독했는데 생각보다 자주, 생각보다 많은 책을 읽었다. 햐, 다독왕 짬바 어디 안 간다구요. 활자 중독 어디 안 간다구요! 속독과 발췌독은 내 장점이자 단점이라 단점을 보완하기 위해 필사도 시작했다. 어차피 e-book으로 읽으니 마음에 드는 구절 하이라이트 쭉 치고, 책을 다 읽을 때쯤 따로 옮겨 적는다. 요즈음의 생각 오랜만에 반가운 오지랖[2]을 들었다. 그 오지랖으로 근 몇 년을 돌아봤다. 그리고 문득, 지금까지 내가 겪은 모든 일이 유기적으로 연결된 느낌을 받았다. 처음엔 우주의 짓궂은 장난[3]이라고 생각했다. 간절한 것을 뺏길 때도 있었고, 엄청난 걸 받을 때도 있었다. 그래도 그냥 된다고 믿었다. 후년이 되어 봐야 확실해질 것 같다. 장난인지, 인도인지. 그냥, 지금의 마음으로는, 내 한계를 계속 시험당하는 것 같다. 똥인지 된장인지 먹어 보고 결정하라고 강요하는 시험. (분명 누군가는 또라이라고 생각할 거다. 그런데 또라이가 틀린 말은 아니…) 회고를 마무리하며 작년 목표를 12월 31일에 보다니? (작년의 나: “또 나만 진심이었지?”) 올해의 나 역시 거창한 목표 따위는 없다. 그냥, 내년에 난 조금 더 밖으로 나돌아다니는 사람이었으면 좋겠다. 마음의 여유가 조금 더 생겼으면 좋겠다. 복싱이어도 좋고, 그게 아니어도 좋으니 다시 운동을 시작하면 좋겠다. 피아노를 꼭 샀으면 좋겠다. 꾸준히 블로그를 가꿔나가면 좋겠다. 기록에 미쳤으면(일이 많을 것 같아서) 좋겠다. 다양한 토이 프로젝트를 했으면 좋겠다. 밖으로 나돌아다니긴 했다. 커리어 관련은 아니었지만, 취미가 본업이 될지 어떻게 알아! 그러니 세모! (일단 던지고 보자.) 마음의 여유는 성공, 운동은 실패, 피아노 구매 성공, 블로그 실패, 기록에 미친 건 세모(업무 수첩은 열심히 씀), 토이 프로젝트 세모(하긴 했는데 다양하진 않음). 잠깐, 그래서 몇 퍼센트지? 50%? (양호한데?) 2020을 대비하는 나의 자세! 작년보다 구체적인 목표 세우기! 빠밤! 정확히 고하는데, 내년에 무조건 개발 동호회든 동아리든 스터디든 어디라도 들어갈 것이다. 강제성을 부여해서 올해보다 더 이룬 게 많은 해로 만들 것임. 그렇게 얻은 거 기록으로 남기는 건 덤. 몇 년째 적성 못 찾고 헤매는데, 코틀린 이용한 안드로이드 개발 먼저 시작할 것[4]이다. 언제까지 이대로 있을 순 없다. 꾸준한 보컬 레슨과 한 달에 한 권 이상 책 읽고 필사하기도 잊을 수 없지. 아무튼, 이 모든 목표와 염원을 담은 내년의 곡은 (본론), 오마이걸의 게릴라(Guerilla)! 폭풍전야 숨죽여 Do it do it now 날 따라와 움직여 Do it do it 시간이 된 것 같아 부드러운 껍질을 벗겨내면 (강인한 마음과) 날카로운 눈빛엔 굳은 결심이 어려 이 심장이 뛰는게 넌 느껴지니 오래 기다려온 순간이야 Do it 정말로 원하는 건 잊어본 적이 없지 지난 모든 아침 잠들던 순간까지 소중하게 지켜온 너와 나의 모든 것을 여기 지금이야 너와 난 때를 기다리고 덮쳐 뜨겁게 뒤집고 흔들어놔 성난 파도처럼 삼켜 깃발을 꽂아봐 승리를 Sing forever 눈부신 하늘 너와 난 Shine forever 그러니 모두 Attention do it do it 하얀 빛을 위해 어둠은 찾아와 일찍 마주했을 뿐이라고 그것은 심연의 빛도 어둠의 결실 맺고 그 어느것도 될 수 없는 것이라고 Oh do it do it 이 안개는 언젠가는 걷힐 테니 불안 속에 갇혀있지 말고 Do it 낯설고 새로운걸 겁내본적은 없지 모든 위험들이 날 크게 만들 테니 소중하게 지켜온 너와 나의 모든 것을 여기 지금이야 너와 난 때를 기다리고 덮쳐 뜨겁게 뒤집고 흔들어놔 성난 파도처럼 삼켜 깃발을 꽂아봐 승리를 Sing forever 눈부신 하늘 너와 난 Shine forever 그러니 모두 Attention do it do it 잘 봐 널 둘러싸던 벽들이 도미노처럼 무너지는 모습을 귀를 기울여보면 들리니 반짝이는 너의 이름 그러니 Do it do it Salute 모두 다 Salute 승부를 던져 Yeah 날 따라와 너와 난 때를 기다리고 덮쳐 뜨겁게 뒤집고 흔들어놔 성난 파도처럼 삼켜 깃발을 꽂아봐 승리를 Sing forever 눈부신 하늘 너와 난 Shine forever 그러니 모두 Attention do it do it Salute 모두 다 Salute 승부를 던져 Attention do it do it 때를 기다리고 덮칠 거야!!! PO야망WER!!! 저 곡의 가사가 그렇다. 너희가 무슨 짓을 해도 날 거다! 행복할 거다! 라는 야심찬 가사. ↩︎ “언제까지 거기…” ↩︎ 종교 없어요. 웃긴다고 생각할 수 있지만 진심이라고! ↩︎ 막막해도 길이 있겠지. ↩︎","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Diary","slug":"Anything/Diary","permalink":"https://d2fault.github.io/categories/Anything/Diary/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://d2fault.github.io/tags/%ED%9A%8C%EA%B3%A0/"}]},{"title":"[Review] NAVER DEVIEW 2019에 다녀와서","slug":"20191101-review-deview-2019","date":"2019-11-01T10:33:29.000Z","updated":"2021-03-04T05:31:56.265Z","comments":true,"path":"2019/11/01/20191101-review-deview-2019/","link":"","permalink":"https://d2fault.github.io/2019/11/01/20191101-review-deview-2019/","excerpt":"개요 피켓팅으로 단련한 내 손가락으로 당당히 DEVIEW 양일권을 얻어냈다. 😄 이 영광을 비투비와 지킬 앤 하이드, 레베카에게 돌립니다! 거의 반쯤 목숨까지(?) 걸었던 나였지만, 세션에 큰 기대를 가지고 간 건 아니었다.","text":"개요 피켓팅으로 단련한 내 손가락으로 당당히 DEVIEW 양일권을 얻어냈다. 😄 이 영광을 비투비와 지킬 앤 하이드, 레베카에게 돌립니다! 거의 반쯤 목숨까지(?) 걸었던 나였지만, 세션에 큰 기대를 가지고 간 건 아니었다. 내가 주로 건드리는 건 AI도, Data도, Web도 아닌 Native Android라, 글쎄. (예상이 맞았다는 게 슬프다. 거의 이해하지 못했다.) 뭘 봤는데? 낯설면서도 익숙한 광경을 보았다. 백팩과 사과가 널려있는 그런 광경. 꾸밈없는 프리젠테이션과, 실패를 실패로 생각하지 않는 사람들? 무슨 세션 들었는데? DAY 1보단 2가 더 이해하기 좋았다. 아무래도 Android쪽 개발을 하다 보니 Front-end가 익숙해서 그런가? Toy Project 덕분에 맛본 Vue.js가 세션 이해에 도움을 줄 준 몰랐다. 역시 일단 하면 뭐라도 되나 봐. (?) DAY 1 제목 엄~청 큰 언어 모델 공장 가동기(이동준,김성동/NAVER/Clova AI) 다운로드 감정연기와 외국어가 가능한 인공지능 성우(이영근/네오사피엔스) 다운로드 챗봇 1만 개의 모델 서빙하기: AI 서비스 어디까지 해봤니?(고석현/NAVER/Clova AI Business) 다운로드 레이블링 조금 잘못돼도 괜찮아요: Clova가 레이블 노이즈 잡는 법(강재욱/NAVER/Clova Business) 다운로드 이미지와 Text정보들을 이용한 쇼핑 카테고리 분류 AI: 대규모 분류 문제를 AI로 해결하기(손경성/NAVER/쇼핑검색개발) 다운로드 예약 전화도 쉽게 받는 인공지능 비서를 만드는 P;ㅠ(도경태/NAVER/Clova AI) 다운로드 DAY 2 제목 모바일 시대, 웹브라우저는 더 새로운 웹 경험을 만들 수 있을까?: Whale 2.0+Live coding(김효,김지한/NAVER/Whale) 다운로드 안드로이드 앱의 다중 웹뷰 환경에서 성능 병목 진단 및 최적화 사례(이성원/NAVER/Whale) 다운로드 앱 패러다임 변화 어떻게 적응할 것인가?: 모듈 중심의 안드로이드 앱 설계(신동길/NAVER/네이버앱개발) 다운로드 React,Angular,Vue를 한 번에 지원하기 위한 설계: Cross Framework Component(최연규/NAVER/FE-Platform) 다운로드 2019년 FE 프레임워크를 배우는 기분: FE 인싸들이라면 알고 있어야 하는 프레임워크 기술들(박재성/NAVER/PaaS) 다운로드 전체 자료는 DEVIEW 2019 홈페이지에서 다운로드 가능하다. 뭘 느꼈는데? 실무진들이 발표하는 것을 보는 것만으로도, 오며가며 아는 사람의 얼굴을 마주하는 것만으로도, 부스에 잠깐 들러 설명을 듣는 것만으로도 충분했다. DEVIEW의 분위기에 취하러 간 사람이 바로 나요. 사실, 몇 달 전부터 이렇게 살면 안 된다고 생각했다. 코딩을 완전히 놓은 건 아니었지만(일을 했으니까) 도태되는 기분이었고, 새로운 자극[1]이 필요하다고 판단했다. 예를 들면, 나와 비슷한 나이대의 개발자들을 만나는 거? 마침 개발 동아리를 찾는 중에 DEVIEW가 눈에 들어왔을 뿐이랄까. DEVIEW를 즐기며 개발자를 꿈꾸던(사실 지금도 개발자가 맞는지 의문) 시절의 내 모습을 보았다. 용기가 생겼다. 그때도, 지금도 나는 재미를 좇아 ‘그냥 하는’ 사람이다. 일단 GO를 외치고 열심히 수습하는 사람. 그래서 그냥 해 보려고 한다. 그게 블로그든, 개발이든 하고자 하는 곳에 길이 있을 거니까. 😄 Thanks, DEVIEW. Vue.js를 이용한 Toy Project도 한몫했음. ↩︎","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Diary","slug":"Anything/Diary","permalink":"https://d2fault.github.io/categories/Anything/Diary/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"deview","slug":"deview","permalink":"https://d2fault.github.io/tags/deview/"}]},{"title":"[Methodology] Clean Code와 Refactoring","slug":"20190905-clean-code","date":"2019-09-05T07:07:42.000Z","updated":"2021-03-04T05:31:56.265Z","comments":true,"path":"2019/09/05/20190905-clean-code/","link":"","permalink":"https://d2fault.github.io/2019/09/05/20190905-clean-code/","excerpt":"개요 사내 세미나에 참석했다. 올해 처음 생긴 문화로, 시니어 분들께서 주기적으로 세미나를 진행해 주신다. 내가 속해 있는 곳은 상대적으로 시니어가 적은 곳이기도 하고, 여러 경험들을 공유받고도 싶어 되도록이면 참석할 수 있도록 노력한다.","text":"개요 사내 세미나에 참석했다. 올해 처음 생긴 문화로, 시니어 분들께서 주기적으로 세미나를 진행해 주신다. 내가 속해 있는 곳은 상대적으로 시니어가 적은 곳이기도 하고, 여러 경험들을 공유받고도 싶어 되도록이면 참석할 수 있도록 노력한다. 이번 주제는 Clean Code이며, 그간 들은 세미나 중 가장 깊이 와닿은 내용이었다. 발표자 분께선 'Clean Code 책에서 발췌한 내용이니 더 자세히 알고 싶으면 책을 읽으세요.'라고 하셨지만… 맞다, 나는 게으르다. 언제 읽을 지 모르니, 들을 수 있을 때 최선을 다해 들었다. 누군가 나에게 '깨끗한 코드를 작성하세요?'라고 묻는다면 '네!'라고 대답하긴 어렵겠지만, 그래도 난 꽤 많은 시간을 작명과 설계에 사용하는 편이다. 무엇보다 구조가 잡히지 못하면 코드를 한 줄도 작성하지 못하는 병(?)에 걸려 있기도 하고. 뭐, 그래서 더 인상깊었던 것 같다. Clean Code의 개념 Test Code를 작성하면 생산성이 안 나오는 것이 당연하다. 다만, 이후 어마어마한 이득을 얻을 수 있다. 코드의 클린함은 발견한 사람의 책임이다. 머문 자리가 깨끗하도록 노력하자. “깨끗한 코드는 단순하고 직접적이다. 깨끗한 코드는 잘 쓴 문장처럼 읽힌다.” - 그래디 부치 Code Golf - Simple TCP Server 각 언어로 누가 더 짧게 짜는지 대결. 간혹 Excel이 1등한다. (function 덕분) 어셈블리나 python이 1등할 때도 있음. 다른 사람이 이해하는 시간이 최소한이 되는 것이 Clean Code 이다. Clean Naming, 어떻게 작성해야 하는가? 프로그래머가 가장 힘들어하는 일은 ‘작명’ 보편적인 단어, 자주 사용되는 접미사는 단독으로 사용하지 않는다. 클래스 명, 객체 명은 명사로 사용한다. 동사 + 목적어(영문 소문자로 시작하는 동사 + 목적어)로 명명한다. 클래스, 메소드, 변수 등을 명명할 경우 주석으로 설명하기 보다는 코드 자체로 이해되게 작성한다. 보편적으로 사용하는 약어 외에, 모호한 의미의 약어를 사용하는 것은 좋지 않다. 접미사로 컨테이너가 포함된 단어는 복수형 단어로 대체하는 것이 좋다. List를 쓰지 말고 복수/단수로 구분하자. (ㅠㅠ 반성) 복수면 devices, 단수면 device! tmp, sum, num 같은 보편적 이름 대신, 변수의 의미를 사용한다. 변수가 측정치를 담고 있다면, 변수명이 단위를 표시해 주는 것이 좋다. limit, start, end 대신 의미있는 변수명을 사용하자. 동일한 기능의 메소드가 서로 다른 동사를 사용하는 경우 혼란을 야기하므로, 일관성 있는 단어를 사용하자. 비슷한 단어라도 구체적인 상황에 맞는 구체적인 단어를 선택하도록 한다. send → deliver, dispatch, announce, distribute, route find → search, extract, locate, recover start → launcher, create, begin, open make → create, setup, build, generate, compose, add, new 연속된 숫자, 불필요한 단어(noise word)를 추가하는 것은 지양한다. 중첩 반복문에서 반복자로 사용되는 인덱스 i, j, k 보다는 prefix 등으로 명확한 의미를 드러낸다. (요샌 generic을 사용한다.) 검색하기 어려운 한 글자로 된 상수나 텍스트 코드는 지양한다. 변수의 의미를 전달할 수 있는 충분한 긴 이름을 사용. 의미없는 접두사, 접미어 사용하지 않는다. (m = 멤버변수) Boolean 타입의 변수명은 부정하는 의미의 용어를 피하는 것이 좋다. if - else문은 긍정적이고, 쉽고, 흥미로운 경우를 앞에 작성하는 것이 좋다. 소문자 L, 숫자 1, 대문자 O, 숫자 0은 혼동될 가능성이 있다. 소스코드 작성 시 개발 전용 폰트를 사용하는 것이 좋다. Method 메소드명은 하는 일을 잘 표현하기 위해 충분히 긴 길이의 서술적인 이름으로 짓는다. 메소드는 작을수록 의미가 더 명확해지고, 하나의 주제만 다룰 수 있게 된다. 가급적이면 if - else, while에 들어가는 condition은 짧게 작성한다. 메소드는 한 가지 대표 기능만 수행해야 한다. 가능하면 메소드를 최대한 빨리 리턴한다. (fast return) 조건의 중첩이 있을 경우, 메소드 중간에서 반환하는 구문이 더 효율적이다. (validation) 조건은 눈에 뜨이는 곳에 미리 나타나도록 작성하는 것이 좋다. 삼항 연산자는 읽기 혼란스럽고 디버깅이 어렵다. (매우 간단한 경우라면 삼항 연산자를 써도 좋다.) 조건문에서 값이 더 유동적인 것을 왼쪽에, 고정적인 값을 오른쪽에 작성한다. null pointer exception 방지를 위해 &quot;KIM&quot;.equals(studentName); 과 같이 작성하는데, 차라리 exception을 처리해라. 조건문에 대입문을 사용하는 경우는 지양하며, 별도 작성한다. short-circuit은 디버깅과 프로그램 이해를 어렵게 한다. break, continue 키워드로 흐름을 제어하고, 흐름 제어 boolean 변수 사용을 지양한다. 결론 람다 쓰세요. 가독성이 올라가고, 명확한 코드를 작성할 수 있습니다. logger의 레벨을 올리면 성능이 좋아집니다. 주석 주석의 목적은 코드를 읽는 사람이 코드를 잘 이해하도록 돕는 수단이다. 코드에서 빠르게 유추할 수 있는 애용은 주석으로 달지 않는다. 이해하기 쉽고 깔끔한 코드가 복잡하고 주석이 많이 달린 코드보다 좋다. 정규 표현식이나 인수 반환 값(compareTo)은 그 의미를 빠르게 파악할 수 있도록 주석으로 표현하면 좋다. 중첩이 심하고 길이가 긴 블록은 닫는 불록에 // end of line 적어주는 것이 좋다. 코드의 특정 위치를 나타내는 주석은 지양하고, FIXME, TODO, XXX를 사용한다. 소스 변경 이력은 형상 관리 도구에서 관리하고 소스 코드 상단에 남기던 이력 관리 주석은 제거한다. 날짜 쓰지 마세요. 날짜 추가하지 마세요. 결론 프로젝트 표준이 없으면 만드세요. 그것도 아니라면 일반적인 룰을 사용하세요. AOSP(Android OpenSource Project) 참고 개인적인 취향을 따라가는 건 지양합시다. Refactoring 프로그램 코드의 실행 결과의 변화 없이 소프트웨어 내부 구조를 변경하는 것. Bad small → Clean &amp; Simple로 변경하는 것. 언제 해야 하는가? 같은 문제점이 세 번째 반복되면, 리팩토링을 진지하게 고민. 이해하기 쉬운 코드로 바꾸면, 기능 추가도 쉬워짐. 안 보이던 버그가 보이기도 함. 코드 리뷰와 함께 리팩토링하면 효과가 두 배! 어떻게 해야 하는가? 나쁜 냄새가 나는 코드를 찾는다. 코드를 어떻게 변경하는 것이 좋을지 고민해 본다. 리팩토리 수행 전, 테스트 케이스를 이용하여 테스트를 수행한다. 리팩토링은 내부 구조만 변경하는 것이기에, 외부로 보이는 실행 결과가 바뀌면 안 된다. 리팩토링 전/후 Testing 결과[1]가 같아야 함. 소나큐브라도 먼저 돌리세요. ^^; Testing을 하기 위해선 Test Code가 필요하다. 맨 처음의 내용과 일맥상통. ↩︎","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Others","slug":"IT/Others","permalink":"https://d2fault.github.io/categories/IT/Others/"}],"tags":[{"name":"clean code","slug":"clean-code","permalink":"https://d2fault.github.io/tags/clean-code/"},{"name":"refactoring","slug":"refactoring","permalink":"https://d2fault.github.io/tags/refactoring/"}]},{"title":"[Movie] 알라딘","slug":"20190618-movie-review-aladdin","date":"2019-06-18T14:33:36.000Z","updated":"2021-03-04T05:31:56.264Z","comments":true,"path":"2019/06/18/20190618-movie-review-aladdin/","link":"","permalink":"https://d2fault.github.io/2019/06/18/20190618-movie-review-aladdin/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 4D가 진짜라고 해서 굳이 판교까지 가서 봤다. 안 갔으면 후회했을 뻔. 양탄자 탈 때 날아가는 줄 알았고, 카메라 워킹이 예술이었으며, 배우들 연기, 영상미 뭐 하나 빠질 것 없이 완벽했다. 음악도 짜릿했음. 특히 자스민(나오미 스콧)의 Speechless가 나올 땐 울컥하고 말았다. 한순간도 빼놓지 않고 웃었다. 내내 웃었다. 나올 때 광대와 턱이 아플 정도로 웃었다. 웃음이 가득하다는 것만으로도 볼 이유는 충분하다고 생각. 간만에 기분 좋아지는 영화였다. 평점 아무도 듣지 않는대도 우린 계속 말해야 한다. 조금 더 서로를 이해하고, 조금 더 배려하는 사회가 되길 바라며. (9.7/10.0)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Movie] 어벤져스: 엔드게임","slug":"20190510-movie-review-avengers-endgame","date":"2019-05-10T06:43:45.000Z","updated":"2021-03-04T05:31:56.258Z","comments":true,"path":"2019/05/10/20190510-movie-review-avengers-endgame/","link":"","permalink":"https://d2fault.github.io/2019/05/10/20190510-movie-review-avengers-endgame/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 나는 결코 어벤져스의 팬이 아니라고 생각했다. 11년의 종지부를 찍은 이 영화를 보기 전까지. 히어로물을 보다가 눈물을 흘릴 줄이야? 마블 영화를 챙겨본 것도 아니고, 못 본 영화도 많은데도 불구하고 잊을 수 없는 마지막편이 되었다. 새삼스럽게 영원한 건 없다 싶다. 항상 그곳에 있을 것 같던 것들이 하나둘 사라져간다. 이 순간을 후회하지 않기 위해 더 나은 삶을 살기 위한 고민을 놓지 말아야겠다. 다음 계획: 스파이더맨 보기 (성공할 수 있을까?) 평점 나는 아직 그들을 보내고 싶지 않다. (9.5/10.0)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Movie] 극한직업","slug":"20190427-movie-review-extreme-job","date":"2019-04-27T11:43:45.000Z","updated":"2021-03-04T05:31:56.225Z","comments":true,"path":"2019/04/27/20190427-movie-review-extreme-job/","link":"","permalink":"https://d2fault.github.io/2019/04/27/20190427-movie-review-extreme-job/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 다들 재미있다고는 했었지만, 이렇게 재미있을 줄이야! 내 감성은 딱 B급인 것인가 보다. 내내 웃으면서 봐서(말이 웃으면서지 빵빵 터졌음) 영화관에서 보지 않은 걸 다행이라고 여겼달까. ^^; 가장 인상깊었던 건 역시 이하늬였다. 이전에 이런 역할을 한 적이 있었던가? 살짝은 엽기적인 성격에, 찰진 욕, 그리고 액션까지? 다방면으로 소화하기 어려운 역할이었을 것 같은데 정말 정말 매력적으로 연기해 줘서 몰입도 최강이었음! 왠지 기분 좋아지는(?) 역할이었다. 평점 비현실적이면서도 현실적이고, B급 감성이면서도 너무 잘 만들어진 영화였다. 인생이 참 웃기다니까. 간절하게 하나만 할 땐 안 되다가도 이상한 포인트에서 될 때가 있단 말이지. 존버는 승리합니다. (9.2/10.0)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Movie] 기묘한 가족","slug":"20190420-movie-review-the-odd-family-zombie-on-sale","date":"2019-04-20T06:54:45.000Z","updated":"2021-03-04T05:31:56.223Z","comments":true,"path":"2019/04/20/20190420-movie-review-the-odd-family-zombie-on-sale/","link":"","permalink":"https://d2fault.github.io/2019/04/20/20190420-movie-review-the-odd-family-zombie-on-sale/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 진짜 기묘하다. 킬링 타임용 영화. 재미있는 건 잘 모르겠고, 허탈하게 웃었음. 이야기의 주는 감정을 느끼게 된 좀비와의 로맨스 아닌 로맨스인데(마냥 로맨스는 아님. 도무지 장르를 알 수 없는 영화임.) 웜바디스와 비슷하다는 생각을 했다. 분명 감독은 웜바디스를 봤을 거야. 그러나 웜바디스가 열 배는 더 재미있고 탄탄함. 웜바디스 한 스푼에 한국 코미디 갬성 열 스푼 섞은 영화 같음. 평점 그냥 웜바디스 보세요. (7.3/10.0)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Movie] 미성년","slug":"20190414-movie-review-another-child","date":"2019-04-14T07:32:14.000Z","updated":"2021-03-04T05:31:56.221Z","comments":true,"path":"2019/04/14/20190414-movie-review-another-child/","link":"","permalink":"https://d2fault.github.io/2019/04/14/20190414-movie-review-another-child/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 보통의 불륜을 그린 영화. 어떤 사람은 이 영화를 보고 자신의 이야기라고 생각할지도 모르겠다. 사람은 실수와 경험으로 성장한단다. 그러나 나는, 굳이 몰라도 되는 것이 있다고 생각한다. 불륜도 좋은 예시가 될 수 있겠지. 하나의 이기심으로부터 시작된 놀이가 어떤 결과를 만드는지 눈으로 보아야 비로소 아는 멍청이들. 이 영화에서는 아이를, 가정을 사랑하지 않아서 외도하는 게 아님을 명확히 보여준다. 그래서 더 웃겼다. 대체 왜? 심심해서? 쾌락 때문에? 그게 무슨 이유든, 오답임을 알고도 가는 걸 인간이라고 할 수 있나. 평점 애들은 정말 무슨 죄야. (8.0 / 10.0)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Movie] 사바하","slug":"20190223-movie-review-svaha-the-sixth-finger","date":"2019-02-23T13:47:36.000Z","updated":"2021-03-04T05:31:56.213Z","comments":true,"path":"2019/02/23/20190223-movie-review-svaha-the-sixth-finger/","link":"","permalink":"https://d2fault.github.io/2019/02/23/20190223-movie-review-svaha-the-sixth-finger/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 오랜만에 혼영! 곡성도 조조로 혼자 봤는데 얘도 혼자 볼 줄이야. 이 영화의 끝맛은 찝찝했다. 떡밥이 덜 회수된 기분? 어중간하게 알아서 그렇단다. 하긴, 나는 기독교도, 도교도, 불교도, 밀교도 제대로 알지 못하는 일개 중생인걸. 영화 끝난 직후보다 해석을 읽은 후가 더 재미있었다. 불교에는 선과 악이 구분되지 않는단 대사가 자꾸 맴돈다. 그 말인 즉, 절대선과 절대악이 없다는 뜻 아닐까. 약간의 숫자놀음을 추가해야징! 그가 태어난 건 1899년이고, 그것이 태어난 건 1999년이다. 그의 숫자를 다 더하여 한자리수로 만들면 9, 그것은 10이 된다. 9는 인간이 올라갈 수 있는 가장 높은 수이나 10은 신의 숫자임으로 9를 파괴한 것이 10이 되는? 뭐 그런 생각을 했다. 헤헤. 평점 검은 사제들이 더 재미있었어! 하지만 웰메이드. 알고 나니 굉장히 탄탄한 스토리였다. (7.8 / 10.0)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Movie] 증인","slug":"20190216-movie-review-innocent-witness","date":"2019-02-23T13:47:30.000Z","updated":"2021-03-04T05:31:56.208Z","comments":true,"path":"2019/02/23/20190216-movie-review-innocent-witness/","link":"","permalink":"https://d2fault.github.io/2019/02/23/20190216-movie-review-innocent-witness/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 아무 생각 없이 보러 갔다가 눈물 쏙 빼고 나온 작품. 한국 감성 듬뿍 들어간 전형적인 한국 영화임에도 불구하고 울 수밖에 없었던 건 배우들의 연기력과 영화의 소재 때문일 것이다. 스토리 위주의 영화가 아니라 더 좋았다. 스토리를 탄탄하게 하기 위해 넣은 설명일 수도 있겠지만, 자폐에 관해 알 수 있는 시간이었다고 해야 할까? 아무튼, 정우성은 입체적인 인물이었을 뿐이고 변화 과정 속에서 자폐를 자세히 다룬 게 좋았다. 평점 정상인 것처럼 노력하지 않아도 되어 좋다는 대사가 콕 박혔다. (8.5 / 10.0)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Movie] 뺑반","slug":"20190205-movie-review-hit-and-run-squad","date":"2019-02-05T13:47:22.000Z","updated":"2021-03-04T05:31:56.207Z","comments":true,"path":"2019/02/05/20190205-movie-review-hit-and-run-squad/","link":"","permalink":"https://d2fault.github.io/2019/02/05/20190205-movie-review-hit-and-run-squad/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 오랜만에 공효진의 강한(?) 모습을 볼 수 있어 좋았다. 조정석의 연기력은 두말할 것 도 없었고. 류준열은 참, 자기 얼굴을 자유자재로 사용하는 것 같음. 얼굴보다 못생기게도, 잘생기게도 연기한다. (ㅋㅋㅋㅋ) 여담이지만, 샤이니 기범이 나오는 줄은 몰랐는데 역할까지 약간 양아치스러워서 놀랐다. 무엇보다 여성 배우들이 중요한 역할을 많이 맡은 게 제일 최고로 좋았다. 이 영화 역시 ‘돈 많은 사람’ 옆에 ‘예쁘고 몸매 좋은’ 언니들을 함께 연출했지만, 좋은 건 좋은 거지. 평점 기대하지 않고 보았더니 생각보다 재미있던걸? 2편도 나오면 봐야지. (7.8 / 10.0)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Redis] Sentinel 설정 및 동작 확인","slug":"20190125-set-and-check-sentinel","date":"2019-01-25T07:14:23.000Z","updated":"2021-03-04T05:31:56.207Z","comments":true,"path":"2019/01/25/20190125-set-and-check-sentinel/","link":"","permalink":"https://d2fault.github.io/2019/01/25/20190125-set-and-check-sentinel/","excerpt":"","text":"Sentinel 설정 code를 이용하여 redis를 설치했다면, sentinel은 자동으로 설치되어 있다. /lib/redis/redis-stable 경로의 sentinel.conf file을 커스터마이징 해 보자. 먼저, 해당 file을 복사한 후 vim으로 연다. 123cd /lib/redis/redis-stablesudo cp sentinel.conf 11001.confsudo vim 11001.conf 다음의 몇 가지를 수정하여 저장한다. 12345protected-mode noport 11001pidfile &quot;/var/run/redis-sentinel_11001.pid&quot;logfile &quot;/var/log/sentinel_11001.log&quot;sentinel monitor mymaster 127.0.0.1 6379 2 다른 네트워크에서 정상적으로 sentinel을 사용하기 위해서는, 127.0.0.1 을 master의 ip로 설정하면 된다. 센티넬을 총 세 개 돌릴 것이기 때문에 이렇게 총 세 번을 반복해야 한다. 11002, 11003 file을 생성하여 수정해 보자. 123456# copy filesudo cp 11001.conf 11002.confsudo cp 11001.conf 11003.conf# edit filesudo vim 11002.confsudo vim 11003.conf 아래를 참고하여 수정한다. 12345678910111213# 11002.confprotected-mode noport 11002pidfile &quot;/var/run/redis-sentinel_11002.pid&quot;logfile &quot;/var/log/sentinel_11002.log&quot;sentinel monitor mymaster 127.0.0.1 6379 2# 11003.confprotected-mode noport 11003pidfile &quot;/var/run/redis-sentinel_11003.pid&quot;logfile &quot;/var/log/sentinel_11003.log&quot;sentinel monitor mymaster 127.0.0.1 6379 2 Sentinel 실행 &amp; 종료 sentinel은 다음의 명령으로 실행 가능하다. 1sudo redis-sentinel ./11001.conf &amp; sudo redis-sentinel ./11002.conf &amp; sudo redis-sentinel ./11003.conf &amp; redis와 마찬가지로, 각각의 client shell에 정상적으로 접속하면 실행된 것이다. shell에서 info 를 입력하면 sentinel의 정보를 볼 수 있다. 123redis-cli -p 11001redis-cli -p 11002redis-cli -p 11003 다음의 명령어로 종료할 수 있다. 123redis-cli -p 11001 shutdownredis-cli -p 11002 shutdownredis-cli -p 11003 shutdown Redis, Sentinel 동작 확인 sentinel의 정상 동작을 확인하기 위해서는 master redis의 동작을 중지시켜야 한다. 6379 포트를 master로 설정하였기에, 이 포트를 사용하는 redis를 내려 보자. 1redis-cli -p 6379 shutdown master node가 중지될 경우, 다음과 같은 일이 일어날 것이다. 6382, 6383 redis가 master(6379)를 찾지 못한다. 특정 시간(conf file에서 정의함)이 지난 후, sentinel끼리 투표를 진행한다. 과반수 이상(conf file에서 정의함) 득표한 node가 새로운 master로 등록된다. 6379 redis가 재가동되면, 새로운 master와 동기화를 시도한다. 실제로 그러한지 로그로 확인 가능하다. 123456789# redis logcat /var/log/redis_6379.logcat /var/log/redis_6382.logcat /var/log/redis_6383.log# sentinel logcat /var/log/sentinel_11001.logcat /var/log/sentinel_11002.logcat /var/log/sentinel_11003.log 참고 Sentinel 구성하기 Once in a lifetime Sentinel 설명: 2013.04.28 기준","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Others","slug":"IT/Others","permalink":"https://d2fault.github.io/categories/IT/Others/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://d2fault.github.io/tags/redis/"},{"name":"sentinel","slug":"sentinel","permalink":"https://d2fault.github.io/tags/sentinel/"}]},{"title":"[Redis] Redis 설치 및 Master-Slave(Replica) 관계 설정하기","slug":"20190124-install-redis-and-set-master-slave-relationship","date":"2019-01-24T01:24:16.000Z","updated":"2021-03-04T05:31:56.206Z","comments":true,"path":"2019/01/24/20190124-install-redis-and-set-master-slave-relationship/","link":"","permalink":"https://d2fault.github.io/2019/01/24/20190124-install-redis-and-set-master-slave-relationship/","excerpt":"","text":"설치하기 전에 Ubuntu 18.04.2 LTS 기준으로 진행하나, 16 버전이어도 무방할 듯하다. 먼저, 의존 라이브러리를 설치한다. 12sudo apt-get updatesudo apt-get install build-essential tcl 설치 먼저, /tmp/src 폴더를 생성하고 그 안에서 작업하자. 123456789101112# 폴더 생성sudo mkdir /tmp/srccd /tmp/src# 압축파일 다운로드sudo curl -O http://download.redis.io/redis-stable.tar.gz# 압축 해제sudo tar xzvf redis-stable.tar.gz# 코드 옮기기sudo mkdir /lib/redissudo mv redis-stable /lib/redis# 이동cd /lib/redis/redis-stable 소스코드를 컴파일한 후 테스트한 다음 설치한다. 123makemake testsudo make install 설치 확인 12# 시작redis-server 아래와 비슷한 로그가 찍힐 것이다. 12345678910111213141516171819202122232410608:C 28 Jan 2019 16:48:14.211 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo10608:C 28 Jan 2019 16:48:14.211 # Redis version&#x3D;5.0.3, bits&#x3D;64, commit&#x3D;00000000, modified&#x3D;0, pid&#x3D;10608, just started10608:C 28 Jan 2019 16:48:14.211 # Configuration loaded10609:M 28 Jan 2019 16:48:14.213 * Increased maximum number of open files to 10032 (it was originally set to 1024). _._ _.-&#96;&#96;__ &#39;&#39;-._ _.-&#96;&#96; &#96;. &#96;_. &#39;&#39;-._ Redis 5.0.3 (00000000&#x2F;0) 64 bit .-&#96;&#96; .-&#96;&#96;&#96;. &#96;&#96;&#96;\\&#x2F; _.,_ &#39;&#39;-._ ( &#39; , .-&#96; | &#96;, ) Running in standalone mode |&#96;-._&#96;-...-&#96; __...-.&#96;&#96;-._|&#39;&#96; _.-&#39;| Port: 6379 | &#96;-._ &#96;._ &#x2F; _.-&#39; | PID: 10609 &#96;-._ &#96;-._ &#96;-.&#x2F; _.-&#39; _.-&#39; |&#96;-._&#96;-._ &#96;-.__.-&#39; _.-&#39;_.-&#39;| | &#96;-._&#96;-._ _.-&#39;_.-&#39; | http:&#x2F;&#x2F;redis.io &#96;-._ &#96;-._&#96;-.__.-&#39;_.-&#39; _.-&#39; |&#96;-._&#96;-._ &#96;-.__.-&#39; _.-&#39;_.-&#39;| | &#96;-._&#96;-._ _.-&#39;_.-&#39; | &#96;-._ &#96;-._&#96;-.__.-&#39;_.-&#39; _.-&#39; &#96;-._ &#96;-.__.-&#39; _.-&#39; &#96;-._ _.-&#39; &#96;-.__.-&#39; 10609:M 28 Jan 2019 16:48:14.214 # WARNING: The TCP backlog setting of 511 cannot be enforced because &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn is set to the lower value of 128.10609:M 28 Jan 2019 16:48:14.214 # Server initialized ctrl + c 로 종료하자. 여러 Redis 생성 Redis는 기본적으로 초기 셋팅을 편리하게 도와주는 스크립트(install_server.sh)를 제공한다. install_server.sh 는 /redis-stable/utils 에서 확인할 수 있다. 우리는 6379, 6382, 6383 총 세 가지의 conf file을 생성할 것이다. 12# shell script 실행sudo ./install_server.sh 아래와 같은 installer가 실행된다. 12345678910111213141516171819Welcome to the redis service installerThis script will help you easily set up a running redis serverPlease select the redis port for this instance: [6379] Selecting default: 6379Please select the redis config file name [/etc/redis/6379.conf] /lib/redis/6379.confPlease select the redis log file name [/var/log/redis_6379.log] Selected default - /var/log/redis_6379.logPlease select the data directory for this instance [/var/lib/redis/6379] Selected default - /var/lib/redis/6379Please select the redis executable path [/usr/local/bin/redis-server] Selected config:Port : 6379Config file : lib/redis/6379.confLog file : /var/log/redis_6379.logData dir : /var/lib/redis/6379Executable : /usr/local/bin/redis-serverCli Executable : /usr/local/bin/redis-cliIs this ok? Then press ENTER to go on or Ctrl-C to abort. 모두 기본 설정을 따르나, config file의 경로를 기존 /etc/redis/6379.conf 에서 /lib/redis/6379.conf 로 수정하였다. 이 과정을 총 세 번(6379, 6382, 6383) 반복한다. Redis 동시에 실행 &amp; 종료 conf file이 있는 경로에서 다음의 명령어를 실행한다. 1sudo redis-server ./6379.conf &amp; sudo redis-server ./6382.conf &amp; sudo redis-server ./6383.conf &amp; 각각 redis-cli 명령어를 입력했을 때, shell에 정상적으로 진입하면 된다. 123redis-cli -p 6379redis-cli -p 6382redis-cli -p 6383 shell 안에서 정보를 확인해 보자. info 를 입력하면 해당 redis의 정보가 출력된다. 현재 상태에서는 6379, 6382, 6383 모두 master로 출력되어야 정상이다. 이제 redis를 내리고 6379를 master로, 6382, 6383을 slave로 설정해 보자. 1234# redis shutdownredis-cli -p 6379 shutdownredis-cli -p 6382 shutdownredis-cli -p 6383 shutdown Master-Slave 관계 설정 Redis에서 Master-Slave 관계 설정은 conf file 수정하면 된다. Master로 설정할 6379를 제외하고, 6382, 6383 두 file에 다음의 코드를 추가한다. 1234# slaveof [마스터ip] [마스터port]# 로컬에서 진행하기 때문에 127.0.0.1을 사용했다.slaveof 127.0.0.1 6379slave-read-only yes 현재 모든 redis는 localhost에서 동작하고 있기에 ip를 127.0.0.1 로 설정하였고, master가 될 port(6379)를 입력하였다. 다시 redis를 실행시키고 설정된 구조를 확인해 보자. 123456# redis 시작sudo redis-server ./6379.conf &amp; sudo redis-server ./6382.conf &amp; sudo redis-server ./6383.conf &amp;# 각각의 client shell 진입redis-cli -p 6379redis-cli -p 6382redis-cli -p 6383 shell에 진입하여 info 명령을 입력해 보면, 6379는 master, 6382와 6383은 slave로 출력되는 것을 확인할 수 있다. 2018년 10월 redis 버전 5.0이 나오며 slave의 공식 명칭이 replica로 변경되었다. 단, 과거 버전임을 표시하기 위해서는 slave를 사용한다. 외부 접속 허용 외부 ip로 redis에 접속할 수 있도록 해 보자. 각각의 conf file에 bind 설정을 해 주면 된다. 6379, 6382, 6383의 conf file을 열고 다음의 코드를 추가하고 redis를 재시작한다. 12bind 0.0.0.0protected-mode yes 위의 코드는 외부에서 들어오는 모든 ip를 허용하겠다는 뜻이다. 만약 이 과정을 거치고도 외부 접속이 되지 않는다면 공유기의 포트 포워딩 설정에서 6379~6383 port를 열어 주면 된다. 참고 한 서버에 redis 여러 개 띄우기 Perpetual beta Lucky you! redis-cli 기본 명령","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Others","slug":"IT/Others","permalink":"https://d2fault.github.io/categories/IT/Others/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://d2fault.github.io/tags/redis/"},{"name":"sentinel","slug":"sentinel","permalink":"https://d2fault.github.io/tags/sentinel/"}]},{"title":"[Diary] 2018년 회고하기","slug":"20181231-diary","date":"2018-12-31T12:34:00.000Z","updated":"2021-03-04T05:31:56.206Z","comments":true,"path":"2018/12/31/20181231-diary/","link":"","permalink":"https://d2fault.github.io/2018/12/31/20181231-diary/","excerpt":"","text":"회고를 시작하며 매년, 한해를 잘 보내길 기도하며 새해 첫곡을 정한다. 일종의 테마곡 정하기? 우연의 일치인진 모르겠지만, 이렇게 정해진 테마곡은 이맘때쯤 대표곡이 되어 있었다. 올해는, 비투비의 신바람 으로 시작했다. '할 일은 내일로 모여 다 여기로’라는 가사를 보며 저렇게 되면 곤란한데? 라고 생각했는데 그렇게까지 미루진 않았던 것 같아서 다행이다. 처음이 많았던 2018년 첫 직장, 첫 배치, 첫 업무 등 유독 처음이 많았던 해였다. 가장 큰 이벤트는 역시 블록체인이겠지? 주로 안드로이드를 했던 내가 블록체인을 하게 됐었다. Ubuntu라곤 4학년 때 라즈베리파이에 설치한 게 전부였고, CentOS는 설치해 본 적도 없는 OS였다. 무엇보다 백엔드 지식이 부족한 나로서는 머리로는 이해되는데 코드로 작성할 수 없는(…) 지옥에 빠져 버렸다. 그래도 난 후회하지 않는다. 할만큼 했거든! 뭐, 덕분에 백엔드 머리가 좀 발달하게 되었으니까. 내가 맡을 예정이었던 프로젝트들이 많이 엎어지기도 했었네. 그래서 더더욱 블로그에 집중할 수 있었다. 사실 집착이었다. 코딩에 흥미를 잃을까 걱정됐고, 다들 발전하는데 나 혼자 그대로인 것 같아 우울했다. 작은 글들이라도 남기지 않으면 연말에 괴로울 것 같았다. 정말 한 게 없다고 생각될까 봐. 최소한 이거 하나는 남겼다! 라고 당당히 말하고 싶었고, 그 목표까지는 이뤄냈다 그 외에도, 출원하진 않았지만 특허 문서 작성, 안드로이드 애플리케이션 개발(단기 프로젝트성이었지만 한 달 반에 두 개나 만들었다구! 시연도 했다구!), 블록체인 스터디 등 꽤 많은 일을 했다. 스터디는 두 번이 전부였음에도 불구하고 스터디에 초대해 준 언니에게 너무 고맙다. 좋은 사람들을 알게 되었고, 내 열정이 다시 불타오른 계기였기 때문이다. 상황이 사람을 만든다는 것을 믿는다. 그러지 않던 내가, 꽤나 소극적인 삶을 살고 있었다. 아, 신입사원 연수에서 상도 받았네. ㅋㅋ Goodbye Blockchain! 11월 말, 블록체인을 버렸다. 누군가는 좋은 기회를 버렸다고 했다. 맞다, 좋은 기회일 수도 있었을 거다. 그런데 행복하지 않았다. 매일이 괴로웠고, 울상이었고, 점점 더 예민해졌고, 몸이 상했고, 체력이 떨어졌으며 결정적으로 살고 싶지 않았다. 죽고 싶은 게 아니고, 살고 싶지 않았다. 2018년 내 목표는 '진짜 개발자 되기’였다. 회사원이 아닌, 개발자. 내 발전이 곧 회사의 발전이라고 믿었고, 그렇게 내 일의 의미를 찾고 싶었으나 적성에 맞지 않았다. 그래서 도망쳤다. 살기 위해서! 대리로 명예퇴직 할 수는 없잖아요. 갑자기 한 결정은 아니다. 섣부른 판단이라거나, 끈기가 없다고 생각할 수도 있겠지만 나를 믿었다. 버티는 게 능사는 아님을 경험으로 알고 있었다. 그래서 부문을 옮겼다. 아주 큰 이동이었다. 많은 분들이 도와주셔서 가능했다. 그래서 난 다시 행복해졌다. 역설적인 말이긴 한데, 불행한 순간에도 행복하긴 했다. 그런데 지금은 그냥 행복하다. 일이 더 많은 것도 맞고, 퇴근 시간이 늦어진 것도 맞지만 그래도 행복하다. 앞으로 더 바쁘다던데 괜찮겠지? 아, 바뀐 업무는 API Gateway 쯤? Javascript 기반의 API를 제공하는데, 이 API로 안드로이드 기반의 단말을 제어할 수 있도록 통로를 만들어 주는 그런 역할이다. 흔히 사용하는 의미(네트워크 쪽)와는 살짝 다른 의미의 Gateway? return SoMa; 2015년 소프트웨어 마에스트로 6기로 활동했었다. 좋은 기억이 많아 유독 애착이 가는 그룹이다. 우연한 계기(?)로 연말 송년회 준비 멤버로 초대받게 되었고, (열심히 튕겨 보려고는 했으나 소마의 일이라 거절하기 힘들었다. 좋아하니까. ㅠㅠ) 성공적으로 마무리할 수 있었다. 기여를 많이 하진 못했다. 그래서 할 수 있는 순간에 최선을 하려고 노력했다. 준비하신 모든 분들이 그런 마음으로 참여해 주셔서 잘 끝낼 수 있었던 것이라 생각된다. 내년엔 더 많은 분들이 이 행사를 준비해 주셨으면 좋겠다! 문화/취미 생활 뮤지컬 2회(삼총사, 지킬 앤 하이드), 콘서트 3회(비투비의 THIS IS US), 여러 편의 영화, 세 권의 책(제노사이드, 라이프리스트, 나무)을 클리어했다. 모두 블로그에 리뷰로 남기고 싶었는데, 자꾸 미루게 되는 매직? 콘서트 리뷰 남기려고 draft도 생성해 놓았는데 한 글자도 못 썼다. 왜죠? 왜 미루게 되죠? 헐, 맞다! 아무도 모르는 취미 활동 강의도 듣고 있었네? 주말을 할애해서 다른 분야의 나를 성장시키는 중! 아, music is my life이고(ㅋㅋㅋ 음악 많이 들었다는 뜻), 노래방과 PC방도 당연히 다니는 중이다. 너무 자주 가서 이벤트라고 하기엔 약해. 혼자 짜는 코드들 업무와는 별개? 라고 보기는 애매하지만, 언제라도 쓸 수 있게 github에 repository를 생성하고 있다. default setting이라는 이름의 레포인데, node.js와 mongodb를 연동한다거나 node.js를 이용하여 routing하는 뭐 그런 잡다한 것들을 작성하는 중이다. 당연히 이것도 미래의 나를 위해서. 요새 안드로이드를 다시 잡아서 작은 기능들을 만들고 있다. 최근에 시작한 Toy Project는 Mybrary이다. 소규모 그룹에서 이용할 수 있는 도서 대여 시스템을 만들고자 시작한 프로젝트이다. 책 바코드를 인식시키면 Kakao book api를 이용하여 검색하는 것까지 만들었다. Kakao API 담당자 누구야! 도큐먼트 업데이트 안 되어 있어요. v2아니고 v3 사용해야 하잖아요. ㅠ 가이드랑 테스트 코드에서 사용하는 url이 달라 헷갈림. 자세한 내용은 따로 정리해야지. 회고를 마무리하며 올해의 나 역시 거창한 목표 따위는 없다. 그냥, 내년에 난 조금 더 밖으로 나돌아다니는 사람이었으면 좋겠다. 마음의 여유가 조금 더 생겼으면 좋겠다. 복싱이어도 좋고, 그게 아니어도 좋으니 다시 운동을 시작하면 좋겠다. 피아노를 꼭 샀으면 좋겠다. 꾸준히 블로그를 가꿔나가면 좋겠다. 기록에 미쳤으면(일이 많을 것 같아서) 좋겠다. 다양한 토이 프로젝트를 했으면 좋겠다. 그리고, 평소보다 조금 일찍(11월?) 정한 내년의 곡은 이홍기의 Cookies(Feat.정일훈)이다. 더 자유롭게 날아가길 바라는 마음을 담아. 영화 같은 내 삶을 지켜봐 눈부시게 비친 Spotlight So many love 멈출 수 없게 누구도 손댈 수 없게 난 이 순간을 느끼는 데 집중하고 있어 With my friend and ma fam and ma lovely fans Nobody can control us 그래 떨어질 수 있다면 언제든 날아갈 수 있어 We made it our own 그게 진짜 Fact 말고 다른 진실은 존재할 수도 없네 내 친구들만 아는 내가 하고 있는 말 이해하지 못한다면 이해하는 척을 마 나를 믿고 와준 모두 Hello 이제 날아가는 나를 봐 날 잡아당기려는 모든 것들로부터 더 자유로워 If you catch me up when I’m falling down Baby if you take me high If you catch me up when I’m falling down Baby if you take me high If you catch me up when I’m falling down 변치 않을 날 좀 더 믿어봐 흔치 않은 그런 나인걸 눈치 없게 변하지 않아 시간은 짧지 않은걸 나를 믿고 와준 모두 Hello 이제 날아가는 나를 봐 날 잡아당기려는 모든 것들로부터 더 자유로워 If you catch me up when I’m falling down Baby if you take me high If you catch me up when I’m falling down Baby if you take me high If you catch me up when I’m falling down Don’t care 어떤 시선도 Don’t care 더 높이 날아가 알 수 없는 곳에 너와 함께라면 We just be happy If you catch me up when I’m falling down Baby if you take me high If you catch me up when I’m falling down Baby if you take me high If you catch me up when I’m falling down 영화 같은 노래가 끝나도 끝이 아냐 아직은 아냐 너와 내가 만들어갈 날들이 우릴 기다려 You should wait for cookies 2019년은 더 행복하게 보내자. 올해도 정말 고생했다!","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Diary","slug":"Anything/Diary","permalink":"https://d2fault.github.io/categories/Anything/Diary/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://d2fault.github.io/tags/%ED%9A%8C%EA%B3%A0/"}]},{"title":"[Node.js] express engine으로 html load하기","slug":"20181226-nodejs-html-load-with-express","date":"2018-12-26T01:31:06.000Z","updated":"2021-03-04T05:31:56.205Z","comments":true,"path":"2018/12/26/20181226-nodejs-html-load-with-express/","link":"","permalink":"https://d2fault.github.io/2018/12/26/20181226-nodejs-html-load-with-express/","excerpt":"","text":"개요 node.js에서 routing되는 view를 html로 뿌려주고 싶었다. 보통의 view는 ejs를 사용하는 것 같은데, 만드는 것이 고작 나만 볼 test page이기에 ejs까진 필요가 없었다. 그런데 웬일? 이렇게 단순한 작업에도 에러 등장. Error: No default engine was specified and no extension was provided 그렇다. node.js express engine으로 html file을 load할 때 위의 에러가 발생했다. 구글링 결과, 두 가지의 해결 방법을 찾아냈다. 사실 두 가지 방법 외에 sendFile로 해당 html file을 그대로 뿌려 주는 방법도 있다. 1. html을 ejs로 rendering(추천) ejs 를 설치한다. 1npm install ejs 화면 엔진을 ejs 로 설정한다. 123// 화면 engine을 ejs로 설정app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;);app.engine(&#x27;html&#x27;, require(&#x27;ejs&#x27;).renderFile); 이대로 사용하면 된다. ^^;; full code는 아래와 같다. app.js123456789101112131415161718192021222324var express = require(&#x27;express&#x27;);var app = express();var logger = require(&#x27;morgan&#x27;);// router 설정var indexRouter = require(&#x27;./routes/index&#x27;);app.use(logger(&#x27;dev&#x27;));app.use(express.json());app.use(express.urlencoded(&#123; extended: false &#125;));// view 경로 설정app.set(&#x27;views&#x27;, __dirname + &#x27;/views&#x27;);// 화면 engine을 ejs로 설정app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;);app.engine(&#x27;html&#x27;, require(&#x27;ejs&#x27;).renderFile);// 기본 path를 /public으로 설정(css, javascript 등의 파일 사용을 위해)app.use(express.static(__dirname + &#x27;/public&#x27;));app.use(&#x27;/&#x27;, indexRouter);module.exports = app; index.js123456789var express = require(&#x27;express&#x27;);var router = express.Router();/* GET home page. */router.get(&#x27;/&#x27;, function(req, res, next) &#123; res.render(&#x27;index.html&#x27;);&#125;);module.exports = router; 2. consolidate, mustache 모듈 설치 잘은 모르겠지만, mustache 가 html file을 ejs로 렌더링하는 것 같다. 프로젝트 루트 폴더에 consolidate 와 mustache 를 설치한다. 12npm install consolidatenpm install mustache server 파일에 consolidate 을 추가한다. 12// 변수 이름은 마음대로 정해도 됨.var engines = require(&#x27;consolidate&#x27;); 화면 engine을 html로 설정한다 123// 화면 engine을 html로 설정app.engine(&#x27;html&#x27;, engines.mustache);app.set(&#x27;view engine&#x27;, &#x27;html&#x27;); 이것도 이렇게 끝! 나는 다음과 같이 사용해 보았다. app.js123456789101112131415161718192021222324252627var express = require(&#x27;express&#x27;);var app = express();var engines = require(&#x27;consolidate&#x27;);var path = require(&#x27;path&#x27;);var cookieParser = require(&#x27;cookie-parser&#x27;);var logger = require(&#x27;morgan&#x27;);// router 설정var indexRouter = require(&#x27;./routes/index&#x27;);app.use(logger(&#x27;dev&#x27;));app.use(express.json());app.use(express.urlencoded(&#123; extended: false &#125;));// view 경로 설정app.set(&#x27;views&#x27;, __dirname + &#x27;/views&#x27;);// 화면 engine을 html로 설정app.engine(&#x27;html&#x27;, engines.mustache);app.set(&#x27;view engine&#x27;, &#x27;html&#x27;);// 기본 path를 /public으로 설정(css, javascript 등의 파일 사용을 위해)app.use(express.static(__dirname + &#x27;/public&#x27;));app.use(&#x27;/&#x27;, indexRouter);module.exports = app; index.js123456789var express = require(&#x27;express&#x27;);var router = express.Router();/* GET home page. */router.get(&#x27;/&#x27;, function(req, res, next) &#123; res.render(&#x27;index&#x27;, &#123; title: &#x27;Main&#x27; &#125;);&#125;);module.exports = router; 기회가 되면 default setting을 정리해서 남기고 싶은데, 연말이라 그런지 너무 귀찮다. ^^; 참고 consolidate.js mustache.js ejs.js Node.JS 강좌 09편: Express 프레임워크 사용해보기 stackoverflow - NodeJS, how to render static HTML with Express 4?: html file을 sendFile로 뿌리는 방법 stackoverflow - Mustache(-like) template engine for Express?","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"JavaScript","slug":"Programming/JavaScript","permalink":"https://d2fault.github.io/categories/Programming/JavaScript/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://d2fault.github.io/tags/node-js/"},{"name":"express","slug":"express","permalink":"https://d2fault.github.io/tags/express/"},{"name":"ejs","slug":"ejs","permalink":"https://d2fault.github.io/tags/ejs/"},{"name":"consolidate","slug":"consolidate","permalink":"https://d2fault.github.io/tags/consolidate/"},{"name":"mustache","slug":"mustache","permalink":"https://d2fault.github.io/tags/mustache/"}]},{"title":"[Diary] 작은 사건들이 많은 근황?","slug":"20181218-diary","date":"2018-12-18T00:25:45.000Z","updated":"2021-03-04T05:31:56.205Z","comments":true,"path":"2018/12/18/20181218-diary/","link":"","permalink":"https://d2fault.github.io/2018/12/18/20181218-diary/","excerpt":"","text":"무엇을 위해 글을 쓰는가? 세미 갈무리라고 치자. 아직 31일은 아니고, 신상 변화 그리고 작은 이벤트들이 많으니까 정리하는 차원에서. 그래서 그런지 몰라도 글이 중구난방이 될 것 같은 예감이 든다. 요새 내 관심사와 일들이 아주 다이나믹하니까! 기가지니 넌센스 퀴즈 개발 기가지니 서비스 sdk를 이용해서 넌센스 퀴즈(?)를 개발했다. 이미 지니에 있는 게임인 걸 알고서 살짝 김이 빠졌지만, 그래도 한 사이클 돌렸다는 게 너무 뿌듯하다. 나름 2.1 버전이라고! 코드는 github 대신 bitbucket에서 관리하고 있다. 헤헹. (^^) 가장 자주 사용하는 툴: VSCode Hyperledger Fabric을 하면서부터 자주 쓰고는 있었지만, 블록체인을 떠나서까지 자주 쓰게 될 줄은 몰랐다. (어쩌다 보니) Android로 돌아오게 되었는데, 아직까지는 Android Studio보다 더 자주 사용하고 있다. 요즘의 주 언어는 javascript(node.js도), 최근에 이해하려고 노력했던 건 async/await와 promise 그리고 node.js에서의 routing이다. 관련 내용도 정리해야 하는데 callback 이해를 제대로 못 했다는 슬픈 사실. (ㅠㅠ) 나도 천재이고 싶다! 고작 이런 것도 제대로 이해를 못 하다니!!! 새로 들인 물건: 노트북 거치대, usb 멀티 포트 충전기 4월인가? 사야 한다고 다이어리에 적었던 것 같은데 드디어 샀다. (^^);; 노트북 거치대를 왜 이제야 샀을까. 삶의 질 상승! 몇 개를 더 살 걸 그랬어. 손목도 편하고, 목도 편하다. 고개를 덜 숙여서 봐도 되니까 진짜 좋다! 이전에 쓰던 노트북 OPEN 도저히 집 컴퓨터로는 게임을 할 수가 없(…)어서 아빠한테 빌려드린 노트북을 달라고 했다. 어차피 안 쓰시기도 해서 바로 받았고, 상태는 양호했다! 아르바이트 열심히 해서 2013년에 처음으로 산 MSI 노트북인데 작년에 샀다고 해도 믿을 수 있을 정도로 말짱해서 뿌듯. 그래도 연식은 무시 못 해. (ㅠㅠ) 쿨러 쪽에 문제가 있는 것 같아서, (열을 많이 받으면 갑자기 파워 off) 수리하러 함 다녀오긴 해야 할 것 같음. 이 노트북은 2015년 7월까지 아주 열심히 썼었다. (이후에는 맥북으로 넘어왔지!) Visual Studio랑 Bracket, Android Studio가 깔려 있었다. 안드로이드를 처음 시작했던 노트북이기도 하고, 키넥트와 연결해서 써 보기도 했고, 뭐. 대학생 때 했던 프로젝트 자료가 남아 있는 게 신기했다. 내 책상이 드디어 내 책상이 되었다! 노트북을 들이며 책상이 없다는 게 너무 슬펐는데, 남동생 (수능 끝난 고3) 이 다음 날 바로 자기 책상으로 내 책상을 점령하던 (고물) 데스크탑을 옮겼다. (ㅠㅠ) 그게 어제의 일이다. 집에 가자마자 그 소식을 듣고 바로 책상 정리하러 달려갔지. 여전히 좁은 책상이지만 있다는 게 어디야! 음, 그래서 기념으로 롤을 했다. ^^ 막상 책상이 생기니까 뭔가 만들고 싶어졌다. 주제 하나 잡아서 개발하면 좋을 것 같은데 뭘 만들면 좋을지 고민해 보아야지! (아니면 작곡이라거나, 작곡이라거나, 작곡? 혹은 블로그라거나, 블로그라거나, 블로그?) 피아노 사고 싶다 잊혀진 취미 중 하나. 잘 치는 피아노는 아니지만, 피아노가 있을 땐 종종 피아노를 쳤다. 사고 싶다고 생각한 건 좀 되었는데, 아직까지 못 산 이유는 집에 자리가 없어서(…)라는 슬픈 전설. 그래서 엄마한테 자리 마련해 달라고 했다. 아, 올해 이사했으면 딱인데 그게 안 돼서 너무 아쉽다. 그럼 모두가 행복했을 텐데. 회사도 가까워지고. 영창 디지털 피아노로 보고 있다. 진짜 사고 싶은 피아노는 CUP320 (200만원) 인데, 내 분수를 생각하면 MD1 (75만원) 으로 만족해야 할 것 같다. (ㅋㅋㅋㅋ) 코드를 먼저 연습하고, 나중엔 가요 편곡하는 것까지 해 보고 싶다. 사야 할 것: 3테라 외장하드 집에 있는 2테라 외장하드는 내가 맥을 살 줄 모르고 산 외장하드라 맥과 연결해서는 파일을 저장할 수 없다. 3테라를 사서, 맥에서도 저장할 수 있도록 바꾸고 2테라의 내용을 옮긴 다음 2테라의 저장 방식을 바꾸는 노가다를 시도해 볼 예정. WD 3테라 99000원 딜 언제 또 떠? 그것만 기다립니다. 뜨면 바로 지른다.","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Diary","slug":"Anything/Diary","permalink":"https://d2fault.github.io/categories/Anything/Diary/"}],"tags":[{"name":"일상","slug":"일상","permalink":"https://d2fault.github.io/tags/%EC%9D%BC%EC%83%81/"}]},{"title":"[Movie] 국가부도의 날","slug":"20181208-movie-review-default","date":"2018-12-08T12:52:50.000Z","updated":"2021-03-04T05:31:56.204Z","comments":true,"path":"2018/12/08/20181208-movie-review-default/","link":"","permalink":"https://d2fault.github.io/2018/12/08/20181208-movie-review-default/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 유쾌할 수 없는 주제이나, 불쾌할 줄은 몰랐다. 충분히 있을 법한 상황과 대사들이 날 분노케 했다. 이렇게 교훈적인 영화는 정말 오랜만이야. 난파선에서 먼저 나오는 사람이 생존 확률이 제일 높다. 문득 든 생각. 이 영화의 주인공은 어쩌면 대한민국이 아닐까? 그들의 결정한 건 결국 '대한민국’의 미래니까. 뭐, 몇 인물들은 본인의 미래와 대한민국의 미래를 동일시했지만. (리버스 펀드인 게 함정. ㅋ 나라 죽이고 나만 살겠다는 멍청이들.)ㄱ 이 영화는 나에게 ‘어떻게 살 것인지’ 물었고, 나는 '바르게’라는 답을 던졌다. 우리의 행복을 꿈꾼다. 승복할 수 있는 결과뿐인 세상과, 권선징악의 미덕을 바란다. 고로 나는, 바르게 살고자 한다. 당연한 것을 당연한 것이라고 여기지 말 것. 항상 깨어있는 눈으로 세상을 바라볼 것. 평점 오로지 김혜수만 보고 선택한 영화이나, 후회는 없다. (유아인은 꼭 나왔어야 했나. 감독의 의도는 짐작되나, 굳이 유아인을? 베테랑 보는 줄 알았음. ㅠ) (8.8 / 10.0)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Android] Android Studio에서 TAG에 빨간 밑줄이 생길 때","slug":"20181205-android-studio-too-long-log-tags","date":"2018-12-05T06:37:08.000Z","updated":"2021-03-04T05:31:56.199Z","comments":true,"path":"2018/12/05/20181205-android-studio-too-long-log-tags/","link":"","permalink":"https://d2fault.github.io/2018/12/05/20181205-android-studio-too-long-log-tags/","excerpt":"","text":"TAG에 빨간 줄이? 부제: too long log tags 소스 코드 확인 중에 다음과 같이 TAG에 밑줄이 생기는 것을 보았다. 이번엔 정말 아무것도 하지 않았는데 왜 생긴 걸까요? 문제는 아니고, default setting 때문에 밑줄이 생기는 것! 해결 방법 Android Studio - Preferences - Editor - Inspections 에 들어가서 Too Long Log Tag에 체크를 해제하면 된다. 이 상태에서, 이렇게 바꾸면 됨!","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://d2fault.github.io/categories/Programming/Android/"}],"tags":[{"name":"Tip","slug":"Tip","permalink":"https://d2fault.github.io/tags/Tip/"}]},{"title":"[Android] Android Studio 3.2.1 Update 이후 gradle을 못 찾을 때","slug":"20181204-android-studio-could-not-find-gradle","date":"2018-12-04T10:09:28.000Z","updated":"2021-03-04T05:31:56.198Z","comments":true,"path":"2018/12/04/20181204-android-studio-could-not-find-gradle/","link":"","permalink":"https://d2fault.github.io/2018/12/04/20181204-android-studio-could-not-find-gradle/","excerpt":"","text":"멀쩡하던 gradle을 왜 못 찾아요? 부제: Could not find lint-gradle-api.jar (com.android.tools.lint:lint-gradle-api:26.1.2) Android Studio 3.1.x 버전에서 3.2.x 버전으로 올리며 gradle을 못 찾는다는 에러가 뜬다. 구글링 후 build.gradle 파일을 확인해 보니, gradle 버전이 맞지 않아 생긴 문제였다. Android Studio 3.2.1 버전 기준 gradle의 최신 버전은 3.2.1이다. 문제를 찾았으니 해결해 보자. 어떻게 고치지? 파일 보기를 프로젝트로 바꾸고, build.gradle 파일을 다음과 같이 수정한다. (gradle의 버전만 바꿔 주었다.) 12345678910111213141516171819&#x2F;&#x2F; Top-level build file where you can add configuration options common to all sub-projects&#x2F;modules.buildscript &#123; repositories &#123; jcenter() google() &#125; dependencies &#123; &#x2F;&#x2F; android studio 최신 버전(3.2.1)의 경우 버전이 낮을 때 에러를 뿜음. &#x2F;&#x2F; 이 코드의 경우, 3.1.2 버전으로 되어 있었다. classpath &#39;com.android.tools.build:gradle:3.2.1&#39; &#125;&#125;allprojects &#123; repositories &#123; jcenter() google() &#125;&#125; 이렇게 해도 안 된다면? build.gradle 에 maven url을 추가한다. 123456789101112131415161718192021&#x2F;&#x2F; Top-level build file where you can add configuration options common to all sub-projects&#x2F;modules.buildscript &#123; repositories &#123; &#x2F;&#x2F; jcenter() 위에 maven url을 추가한다. maven &#123; url &#39;https:&#x2F;&#x2F;dl.google.com&#x2F;dl&#x2F;android&#x2F;maven2&#39; &#125; jcenter() google() &#125; dependencies &#123; classpath &#39;com.android.tools.build:gradle:3.2.1&#39; &#125;&#125;allprojects &#123; repositories &#123; jcenter() google() &#125;&#125; 이렇게 gradle의 버전을 올리면, app.gradle 에서 또 warning를 뿜는다. 이 코드의 경우 buildToolsVersion '27.0.3' 이 기본으로 설정되어 있었다. 이때, Update Build Tools version and sync project를 누르면 자동으로 최신 버전(28.0.3)으로 sync해 준다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://d2fault.github.io/categories/Programming/Android/"}],"tags":[{"name":"Tip","slug":"Tip","permalink":"https://d2fault.github.io/tags/Tip/"}]},{"title":"[Diary] 발버둥","slug":"20181119-diary","date":"2018-11-19T02:49:21.000Z","updated":"2021-03-04T05:31:56.198Z","comments":true,"path":"2018/11/19/20181119-diary/","link":"","permalink":"https://d2fault.github.io/2018/11/19/20181119-diary/","excerpt":"","text":"‘널리 사람을 이롭게 하는 기술 개발.’ 내 자기소개서에서 한 번도 빠진 적 없는 말임에도, 아직까지 지키지 못했다. 이젠 부끄럽기까지 하다. 내 노력이 충분하지 않았던 건가? 음, 그것도 맞는 것 같네. 내 선택에 말을 잇지 못하는 사람들이 많았다. 그건 아니라고, 뻔하다고 그랬다. 그럼에도 불구하고 선택했다. 최선을 찾을 수 있을 거라고 믿었다. 자만이었을까. 내 선택은 진짜 개발자가 될 수 없는, 누구도 바꿀 수 없는 그런 것이었을까. 의미를 찾을 수 없다. 나는 왜, 무엇을 위해 사는가. 최소한 이렇게 살면 안 되는 건 알겠다. 어떻게 극복하지. 매일을 극복하기 위해 노력하고, 시도했는데 이젠 많이 버겁다. 나, 진짜 괜찮을 수 있을까?","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Diary","slug":"Anything/Diary","permalink":"https://d2fault.github.io/categories/Anything/Diary/"}],"tags":[{"name":"일상","slug":"일상","permalink":"https://d2fault.github.io/tags/%EC%9D%BC%EC%83%81/"}]},{"title":"[Review] 블루투스 이어폰 리뷰(엠지텍 MB-W2000)","slug":"20181110-review-bluetooth-earphone-mb-w2000-mgtec","date":"2018-11-10T03:17:15.000Z","updated":"2021-03-04T05:31:56.193Z","comments":true,"path":"2018/11/10/20181110-review-bluetooth-earphone-mb-w2000-mgtec/","link":"","permalink":"https://d2fault.github.io/2018/11/10/20181110-review-bluetooth-earphone-mb-w2000-mgtec/","excerpt":"","text":"사건의 발단 아주 잘 쓰던 블루투스 이어폰은 엠지텍의 MB-E80이었다. 요새 나오는 이어폰에 비하면 끊김도 잦고, 배터리도 빨리 닳지만 아주 잘 썼다. 코드리스가 아닌데도 불구하고 기기를 험하게 쓰는 내가, 일 년에 하나씩밖에 안 쓴 거면 말 다했다고 본다. 내구성 굿. ^^ 아무튼, 엠지텍 이어폰의 만족도가 높았지만 그래도 이번에는 기어아이콘X2018을 사려고(노트8과의 조화가 좋대서) 준비 중이었다. 쓰고 있는 친구들 이어폰 뺏어서 듣기도 하고, 가격 추이를 보고 있었는데… 세상에, 왜 새 제품을 낸 거야? 세상에, 옥션이랑 지마켓에서 할인을 하네? 세상에, 어떡하지? (이유 없이 샀는데 아침에 일어났더니 멀쩡하던 이어폰 한쪽이 나간 건 유우머. W80 안녕…ㅠㅠ) 뭘 어떡해, 질러야지. 기어아이콘X 2019가 나오면 정말 억울할 것 같아서 그냥 질렀다. 8일에서 9일로 넘어가는 새벽에 질렀는데 토요일인 10일, 오늘 배송 완료됨. 배송 엄청나게 빠르다. 배터리는 90%정도 충전되어 있었던 듯? 디자인은 나쁘지 않았는데 마감 만족도는 별로. 케이스 버튼을 눌렀을 때 반자동으로 뚜껑이 열리는 게 아니고, 다른 손으로 잡고 열어야 한다. 플라스틱이라 쓰다가 깨지면 어떡하나 걱정도 됨. 추가적으로 준 케이스는 더 심하다. ㅋㅋㅋ 들고 다녀도 되는 거 맞아? W2000, 선택의 이유는? 간단하게 정리 가능하다. 배터리 시간이 길다. (하루 5~6시간 사용 기준, 기본 케이스로 30일 사용 가능. 사은품인 미니 케이스는 두 번 완충 가능.) 마이크가 양쪽에 있다. (기존에 쓰던 W80은 한쪽에만 있어서 불편했음.) 빅스비 사용 가능. 블루투스 5.0 음질이야 뭐, 듀얼DAC 적용이라고 해도 블루투스 이어폰이라 크게 기대하지 않고 구매했다. (막상 써 보니 음질도 굉장히 좋음.) 그 외에, 케이스가 블루투스 스피커가 된다는 것도 특이했음! 단점은 뭐야? 외부 소음 듣기 기능이 없다. 페어링이 불편하다. 케이스에서 뺐을 때, 자동 ON 기능이 없다. 케이스 마감이… 좀 그래. 양쪽 출력 중 페어링을 끊고 한쪽만 끄는 기능이 없다. 언제적 5핀 케이블입니까. ㅠㅠ 특히 페어링이 너무 불편했다. 설명서도 불친절(-_-)… 다음의 방법을 참고하세요. 이어폰 등록하기 1. 양쪽 이어폰 등록하기 이어폰 양쪽을 귀에 넣고, 동시에 가운데 버튼을 꾸욱 누른다. 띠링 소리와 함께 두 이어폰이 연결된다. 핸드폰에서 블루투스로 W2000을 선택하여 연결한다. 2. 한쪽 이어폰만 사용하기 왼쪽이나 오른쪽 이어폰을 켠다. '페어링 준비가 완료되었습니다.'라는 메시지를 무시한다. 연결을 원하는 기기에 블루투스로 연결한다. 이때, 다른 쪽 이어폰을 켜면 띠링 소리와 함께 두 이어폰이 연결되며 동시 출력이 시작된다. 나의 경우, 등록한 기기의 이어폰 이름에 왼쪽은 L, 오른쪽은 R을 붙여 주었다. 음질을 비교해 볼까? 일단, 나는 EQ를 적극적으로 사용하는 편이다. 노트8에서 지원하는 '서라운드 모드’와, 멜론 EQ의 '곡마다 적합하게 조정’을 선택한 상태에서 비교해 보았다. MB-E80 저음 위주의 베이스 쩌는 이어폰이라고 했는데, 동의할 수 없음. 어떤 음역대가 튀거나 하진 않지만, 전체적으로 음원을 깎아내는 듯한 소리. 나쁘진 않지만 굳이 이 모델을 지금 살 이유는 없을 듯. (비슷한 가격에 더 좋은 것 살 수 있다.) 노트8 번들 이어폰 처음에 듣고 놀람. 번들 이어폰인데 음질이 좋아서. 베이스의 둥둥거림 없음. 오히려 고음역대가 잘 들림. 전반적으로 음표에 샤픈 효과(…)를 준 것 같은 소리. MR과 voice가 분리되는 기분이라고 해야 하나. 쨍쨍한 느낌이 강하다. MB-W2000 음질 자체는 나쁘지 않음. E80과 비슷하게, 전반적인 음을 플랫하게 출력한다. 노트8 이어폰과 다르게, 베이스 쪽에 더 중점을 둔 것 같은 느낌. 그래서 음표에 샤픈 효과(?)를 준 것 같은 느낌 대신, 고음도 부드럽게 처리되는 특징이 있음. 블루투스 스피커(이어폰 충전 케이스) 샤오미 블루투스 스피커(직사각형의 국민 스피커)와 비교했을 때, 더 선명하게 들린다. 기대 안 하고 들으면 오? 싶은데, 기대하면 실망할 수 있을 듯. 호불호가 갈리는 사운드. 이상하게 W2000과 특징이 완전 반대다. 얘는 노트8 번들 이어폰에 근접한 사운드를 보인다. 블루투스 연결 범위가 짧다. 10m 내외? 결론 약 13만 원? 을 주고 산 기기. 마감이 드라마틱하게 좋거나, 음질에 눈이 휘둥그레지진 않지만 '오? 생각보다 정말 괜찮은데?'의 반응을 하게 하는 이어폰이다. 아, 이번에는 사치 좀 부리려고 했더니 또 가성비 좋은 기기를 사고 말았어! 이렇게 된 이상, 내년에 핸드폰을 노트10으로 바꾸고 기어아이콘X 2019를 사은품으로 노린다.(?) 16까지 주고 사고 싶진 않고, 10만 원 초반대 가격이라면 충분히 노릴 만한 기기라고 생각한다. 앞으로 몇 년은 잘 부탁한다, 이어폰아! ^^;; 제발 오래 함께하자! P.S. 1) 여행갈 때마다 블루투스 이어폰 충전하랴, 보조배터리 충전하랴, 휴대 전화 충전하랴 정말 바빴는데 블루투스 이어폰은 충전할 필요가 없어짐. 핵이득! P.S. 2) 회사에서는 꼭 유선 이어폰을 사용했는데(배터리 문제) 이제 그럴 이유도 없어짐. ^^ 핵이득! P.S. 3) 음악을 사랑하고 많이 듣는 헤비리스너입니다. 음악인은 아닙니다. 막귀라고 믿었으나, 음질을 구분할 줄 아는 걸 보니 막귀는 아닌 듯합니다.","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"블루투스이어폰","slug":"블루투스이어폰","permalink":"https://d2fault.github.io/tags/%EB%B8%94%EB%A3%A8%ED%88%AC%EC%8A%A4%EC%9D%B4%EC%96%B4%ED%8F%B0/"},{"name":"후기","slug":"후기","permalink":"https://d2fault.github.io/tags/%ED%9B%84%EA%B8%B0/"},{"name":"엠지텍","slug":"엠지텍","permalink":"https://d2fault.github.io/tags/%EC%97%A0%EC%A7%80%ED%85%8D/"}]},{"title":"[Blockchain] Token Economy Pattern(2): Means of Staking ","slug":"20181107-token-economy-pattern-2-means-of-staking","date":"2018-11-09T06:07:28.000Z","updated":"2021-03-04T05:31:56.192Z","comments":true,"path":"2018/11/09/20181107-token-economy-pattern-2-means-of-staking/","link":"","permalink":"https://d2fault.github.io/2018/11/09/20181107-token-economy-pattern-2-means-of-staking/","excerpt":"","text":"Token Economy Pattern(2): Means of Staking 토큰을 보유해야 하는 이유를 만들기 위해 고안된 패턴이라고 생각된다. 서비스의 수요자보다는 공급자를 기준으로 작동된다는 것이 특징. 이전 패턴(1편)에서는 서비스를 제공받기 위해 토큰을 사용했지만, 이 패턴에서는 토큰이 staking(예치)되어있을 때에만 토큰의 가치를 제공받을 수 있다. Work Token Pattern 토큰을 보유함으로써 서비스 참여자들이 네트워크를 위해 일할 권리를 가짐. Staking한 토큰의 양에 비례하여 서비스 제공자로 선정될 가능성이 높아짐. 서비스에서 발생한 경제적인 수익은 Staking한 토큰의 비율에 비례하여 가져간다. 일을 제대로 하지 못했을 경우, 서비스 제공자는 자신이 Staking한 토큰의 일부를 몰수당한다. ex) AUGUR[1] 특징 블록체인만으로 해결하기 힘든 문제를 해결할 수 있음(경제적인 논리 기반). 블록체인 플랫폼 수준에서도 PoS(Proof of Stake)라는 이름으로 비슷한 매커니즘을 사용하고 있음. 보상/처벌 매커니즘이 쉽게 작동해야 함.(그렇지 않을 경우 도덕적 해이에 의해 서비스 건전성 위헙 우려) 토큰 가치의 변동을 일으키는 변수들을 어느정도 조절할 수 있다. 경제적 인센티브가 직접적으로 제공되어 토큰 보유 유인을 제공하고, 실제 서비스 기여자에게 인센티브를 집중시키는 구조를 만들 수 있다. 한계 서비스 생태계의 부(rich)가 특정 소수에게 집중될 가능성(원인: Staking 양에 따른 경제적 보상 분배)이 있음. 서비스 참여를 위해서는 일정량 이상의 Work Token을 보유(새로운 참여자가 굳이 참여할 이유가 없음)해야 함. 서비스 제공자 행동의 옳고 그름 판단을 100% 확신할 수 없음.(Qtum의 경우, 몰수 매커니즘을 삭제.) Discount Token Pattern 멤버십이나 쿠폰과 비슷하게 동작. 특정 재화나 서비스에 할인을 제공하는 토큰. 할인을 받기 위해 Discount Token 필요. 크게 소모성/비소모성으로 나뉨 소모성: 토큰을 사용(소비)하여 할인받음. 비소모성: 일정 기간 이후 사용한 토큰을 되돌려준다. (영구 할인) ex) Decipher card[2], Sweetbridge[3] 특징 실제 서비스 사용자들이 토큰을 소유하여 네트워크 성장에 기여한다. 실제 사용자들이 토큰을 홀딩하여 토큰 소유 집중화가 방지된다. 토큰의 가치 변동이 상대적으로 안정적이다. (일정 기간 토큰을 예치해야 할인을 받을 수 있기 때문) 초기 서비스 이용자 확보가 용이하다. (초기 토큰 확보가 곧 잠재적 이익) 한계 서비스 제공자의 부담(네트워크 성장 이윤을 할인 개념으로 재분배하는 것이기에 끊임없이 이윤을 분배해야 한다.)이 크다. 라이트 유저가 주인 서비스에 적용할 경우, 효과가 제한적이다. (1000원을 할인받기 위해 토큰을 구매하진 않을 것.) Access Token Pattern 보증금을 예치하고 서비스를 이용한다고 생각하면 됨. (ex - 사물함 대여) 일정량의 토큰을 Stake 해야지만 서비스 접근 권한이 생긴다. 공급자가 일정 금액을 예치하는 Work Token과 반대의 개념. ex) AirSwap[4] 특징 많은 사용자가 생길수록 많은 양의 토큰이 예치된다. (토큰의 시장 공급량을 조절하여 가치 안정/상승에 기여.) 블록체인 생태계에 서비스 사용자들을 더 관여시킬 수 있다. (생태계의 발전으로 연결될 수 있음.) 네트워크 관여도가 높은 참여자들에게 추가적인 권리나 혜택을 제공할 경우 시너지를 발생시킬 수 있다. (다른 토큰 패턴과의 결합 필요.) 한계 서비스를 이용하기 위해 일정량의 토큰을 stake해야 하기 때문에 UX가 좋다고 할 수 없다. 혜택이 크지 않다면 굳이 쓸 이유가 없다. (혜택 &gt;= 금액 예치에 따른 기회 비용) Curation Token Pattern 집단 지성을 통한 큐레이션을 제공하고, 바른 큐레이션일 경우 보상을 얻음. 참여자의 자발적 참여를 유도한다. 다수의 참여로 큐레이션하기 때문에 부정이 개입할 가능성이 낮아진다. 가장 보편적으로 쓰이는 큐레이션 서비스 모델은 TCR(Token Curation Registry[5]) 모델이다. ex) Adchain[6] 특징 네트워크 결과물이 실체로 존재하여 결과물을 이용한 부가적 비즈니스가 가능하다. (큐레이션 결과물을 중심으로 새로운 비즈니스 창출.) 투명성을 높이고 많은 사람의 의견을 반영할 수 있다. 홍보를 위한 큐레이션과 지속적인 생산 인센티브를 주는 비즈니스가 결합된다면, 큐레이션 토큰 가치가 상승할 것. 한계 거버넌스와 인센티브가 stake 양의 영향을 받는다. (토큰 홀더가 토큰을 많이 보유하게 하는 유인으로 작용하기도 하지만, 권력이 집중되어 큐레이션이 소수에 의해 결정될 위험이 있음.) 집단지성만을 이용한다면, 전문적인 큐레이션 결과를 얻기 힘들다. TCR을 이용할 경우 0과 1, 둘 중 하나로밖에 투표하지 못한다. Voting Token Pattern 네트워크 의사 결정에 참여할 수 있는 토큰. 투표권과 토큰을 결합하여 의견 수합에 적합한 패턴으로 작용. 서비스마다 중요도를 자유롭게 설정할 수 있음. (작게는 커뮤니티 찬반부터, 크게는 네트워크 업데이트 찬반까지.) 악의적인 행동에 제약을 두고, voting에 많은 이용자를 참여시키는 것이 중요하다. ex) Steemit[7], Dash[8] 특징 실제 네트워크 참여자들이 토큰을 보유한다. 네트워크 발전 의사 결정이 간편하다. 한계 네트워크가 성장한다고 해서 토큰의 가치가 상승하지는 않는다. 자금의 집중화가 일어날 가능성이 높다 투표 참여 유인이 약하다. ✯ 이 포스트의 모든 내용은 해당 블로그를 참고하여 작성되었습니다. 예측 시장 서비스. 구성원은 시장 개설자, 베팅 참가자, 결과 판정자로 참여. 베팅 과정에서 발생한 수수료를 기반으로 수익을 내기 때문에, 예측 시장을 사용하는 사람들이 많을수록 서비스의 수익이 커짐. AUGUR 예측 시장의 신뢰성과 투명성이 확보되면, 베팅 참가자는 안심하고 예측 시장에 베팅할 수 있을 것. ↩︎ 암호화폐를 기반으로 하는 신용카드 서비스. 수수료의 일부를 Discount pool에 넣고, 이 pool에 들어간 비율에 따라 할인 혜택을 준다. 카드를 많이 사용할수록(수수료를 많이 낼수록), 암호화폐의 가치가 높아질수록 할인받을 수 있는 폭이 커진다. ↩︎ 블록체인 기반 담보 대출 플랫폼. 암호화폐 등의 담보물을 맡기면, 담보대출 비율에 따라 스테이블 코인인 Bridgecoin을 발급해 준다. 일정 금액의 이자를 더해 Bridgecoin을 갚으면 담보물을 되찾을 수 있음. 담보물의 가치 변동과 수치 변동에 따라 이자율이 0%까지 줄어들 수 있다. ↩︎ P2P 교환 플랫폼. 거래자와 판매자들의 희망 판매 정보를 탈중화된 방식으로 관리한다. 판매자와 구매자의 거래 정보를 각각의 off-chain에 기록하고, 체결된 거래만을 블록체인에 저장한다. 일정 금액의 토큰을 예치(7일)해야지만 거래 정보를 order book에 기록할 수 있다. ↩︎ 특정 목적에 맞는 리스트를 만들고, 이 리스트에 진입하고 싶은 대상들에게 신청을 받아 여러 참여자들이 검수한 후 리스트에 포함시키는 방식. ↩︎ 봇에 의해 조작되지 않고, 광고 효과가 높은 양질의 웹사이트 목록 제공. 광고주가 효과적으로 광고를 게시할 수 있게 돕는다. 양질의 웹사이트 리스트에 자신의 웹사이트를 추가하기 위해 금액을 예치하고, 나머지 유저들이 그 사이트의 유효성을 심사한다. challenge가 성공하면 진입 반대에 투표한 참여자의 stake는 분배된다. (찬성 투표자와 진입 신청자에게 반씩 분배.) ↩︎ 블록체인 기반 커뮤니티 서비스. 좋은 글을 쓴 저지에게 voting할 수 있음. voting받은 저자는 해당하는 보상을 네트워크 내의 토큰으로 받고, voting한 독자는 큐레이션 보상을 받는다. ↩︎ 익명의 즉각적인 결제를 위한 암호화폐. PoW 합의 방식을 가지고 있으며, 전체 채굴량의 10%를 자체 발전 기금으로 사용한다. 이 기금으로 누구나 네트워크 생태계를 위한 프로젝트를 개발할 수 있는데, 실제 네트워크에 반영하려면 Dash 마스터 노드들의 승인이 필요하다. ↩︎","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"코인","slug":"코인","permalink":"https://d2fault.github.io/tags/%EC%BD%94%EC%9D%B8/"},{"name":"토큰이코노미","slug":"토큰이코노미","permalink":"https://d2fault.github.io/tags/%ED%86%A0%ED%81%B0%EC%9D%B4%EC%BD%94%EB%85%B8%EB%AF%B8/"},{"name":"token economy","slug":"token-economy","permalink":"https://d2fault.github.io/tags/token-economy/"}]},{"title":"[Blockchain] Token Economy Pattern(1): Means of Exchange","slug":"20181106-token-economy-pattern-1-means-of-exchange","date":"2018-11-06T05:20:17.000Z","updated":"2021-03-04T05:31:56.192Z","comments":true,"path":"2018/11/06/20181106-token-economy-pattern-1-means-of-exchange/","link":"","permalink":"https://d2fault.github.io/2018/11/06/20181106-token-economy-pattern-1-means-of-exchange/","excerpt":"","text":"Token Economy Pattern(1): Means of Exchange 오늘날 우리가 사용하는 화폐는 매매 기능을 갖는 교환 수단이다. 우리는 특정 상품을 구매하거나 서비스를 이용하기 위해 화폐를 지불하기 때문이다. 이와 같이, 블록체인 네트워크에서도 서비스 이용 등을 위한 수단이 필요하다. 이런 목적을 가진 토큰 디자인 패턴에 대해 알아 보자. Payment Pattern 서비스 사용에 대한 지불 수단. 각 서비스마다 개별 토큰을 발행, 사용자들은 이 토큰을 수수료 또는 사용료 지불을 위해 사용함. 화폐의 역할 중 지불 수단의 역할을 수행한다. 대부분 고정적인 토큰 발행량을 갖고 있음. 토큰의 가격은 수요와 공급에 의해 결정된다. (서비스 수요 증가 -&gt; 토큰 수요 증가) ex ) Golem[1], Civic 특징 간단한 설계를 기반으로 한 토큰 이코노미 더 많은 사용자의 참여를 유도할 수 있음 서비스 진입 장벽이 낮음 한계 전체 발행량과 사람들이 팔고자 하는 토큰의 양(시장에 풀리는 토큰 유톨양)이 다름. 소비자나 공급자가 토큰을 보유하고 있을 이유가 적다. 현금으로 토큰을 구입하여 지불하고, 받은 토큰을 바로 현금화할 확률이 높음. 고로, 시장의 토큰 공급은 계속해서 늘어날 수 있음. Burn &amp; Mint Pattern 재화나 서비스의 소비를 위해 사용되면, 토큰이 소각된다. (서비스 제공자에게 토큰 전달 X) 수요가 감소하지 않는 상황에서 토큰이 소각됨에 따라 공급량이 줄어들기에, 토큰의 가치 상승을 꾀할 수 있음. Burn &amp; Mint 모델에서는 서비스가 많이 사용될수록 소각되는 토큰의 양이 증가하여 토큰의 가치가 상승됨. 매달 일정 토큰이 발행되고(Mint), 서비스 제공 비율대로 생성된 토큰을 서비스 제공자에게 분배한다. ex) Factom[2] 특징 토큰 유통량 조절을 통해 직접적으로 토큰 가치에 영향을 미침. 토큰의 가치 등락과 상관없이 서비스를 이용할 수 있음. (서비스 가격은 법정 화폐 가격으로 고정되어 있음. 서비스에 필요한 가치만큼의 토큰을 구매하여 사용하면 됨.) 한계 서비스 이용자가 토큰을 보유할 이유가 없음. 투자 목적이 아닐 경우, 필요할 때 필요한 만큼의 토큰을 구매하여 이용하면 됨. 토큰 가치가 상승하려면 토큰의 수요가 일정하거나 증가해야만 한다. ✯ 이 포스트의 모든 내용은 해당 블로그를 참고하여 작성되었습니다. 분산 컴퓨팅 자원을 P2P로 공유하는 서비스를 제공. 누구나 컴퓨팅 자원의 공급자가 될 수 있으며(완전경쟁시장을 구축하여 효율적인 가격 형성을 목표로 함), 서비스 제공 보상을 토큰으로 받음. ↩︎ 비트코인 블록체인의 보안성을 이용한 탈중앙화 데이터 저장 솔루션 제공. ↩︎","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"코인","slug":"코인","permalink":"https://d2fault.github.io/tags/%EC%BD%94%EC%9D%B8/"},{"name":"토큰이코노미","slug":"토큰이코노미","permalink":"https://d2fault.github.io/tags/%ED%86%A0%ED%81%B0%EC%9D%B4%EC%BD%94%EB%85%B8%EB%AF%B8/"},{"name":"token economy","slug":"token-economy","permalink":"https://d2fault.github.io/tags/token-economy/"}]},{"title":"[Research] 빅스비 VS 시리","slug":"20181017-bixby-vs-siri","date":"2018-10-17T01:37:15.000Z","updated":"2021-03-04T05:31:56.191Z","comments":true,"path":"2018/10/17/20181017-bixby-vs-siri/","link":"","permalink":"https://d2fault.github.io/2018/10/17/20181017-bixby-vs-siri/","excerpt":"","text":"빅스비 VS 시리 빅스비를 굉장히 유용하게 쓰기도 했고, 어떻게 발전하고 있는지 궁금하여 조사해 보았다. 혼자 산다면(예민러들이 많아 말을 할 수가 없음^^;) 더 유용하게 쓸 수 있을 것 같은데. AI 스피커에 자꾸 눈길이 간다. ㅠㅠ 개인적으로 커스텀 명령은 빅스비의 압승. 연결해서 지시해야 하는 것들을 하나의 명령으로 실행할 수 있다는 게 정말 큰 장점이다. VS라고 쓰여져 있지만 사실 빅스비 기능 정리에 가까움. ㅋㅋ 공통점 날씨, 일정, 메모, 전화, 메시지, 알람, 시간, 음악 재생, 타이머 등 기본 기능 지원. ex) 오늘 날씨 어때? 내일 날씨 어때? 메모에 ~라고 저장해 줘, ~한테 전화해 줘, 최근 메시지 읽어 줘, ~에게 ~라고 메시지 보내 줘, 지금 몇 시야? 중국은 몇 시야? 내일 아침 6시에 알람 맞춰 줘, 비투비 그리워하다 재생해 줘, 5분 타이머 맞춰 줘. 차이점 커스텀 명령 시리는 iOS 12부터 커스텀 명령을 지원하나, 하나의 명령만을 수행. 빅스비는 여러 명령을 하나의 명령어로 실행시킬 수 있다. ex) ‘굿모닝’: 블루라이트 필터 끄기 + 알람 끄기 + 오늘 날씨 + 시간 + 운세 등을 한 번에 실행. 검색 연결 시리: 못 알아듣는 명령을 구글에 검색하여 보여줌. 빅스비: 못 알아듣는 명령의 바른 명령을 유저가 입력하게 함. 일회성 UX는 시리가 좋으나, 다회성 UX는 빅스비가 우월. (학습을 통한 성장) 빅스비 비전 카메라를 이용하여 정보를 추출. 사진과 GPS를 이용한 장소 검색, 와인 검색, 최저가 쇼핑 검색 등을 제공 빅스비의 Deep Learning 빅스비의 가장 큰 장점이자 빠르게 성장할 수 있는 원동력. 잘못 알아들은 부분을 수정하여 교육할 수 있다. (인내심이 필요하나 교정되긴 함.) 빅스비의 Smart Thing 삼성 가전과의 연동을 통한 Home IoT 지원. 결론 빅스비: 우리 함께 고도화해 볼까? 시리: 고도화는 우리가 한다, 너희는 사용만 해. 네, 제가 빅스비 유저입니다.","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Others","slug":"IT/Others","permalink":"https://d2fault.github.io/categories/IT/Others/"}],"tags":[{"name":"research","slug":"research","permalink":"https://d2fault.github.io/tags/research/"},{"name":"빅스비","slug":"빅스비","permalink":"https://d2fault.github.io/tags/%EB%B9%85%EC%8A%A4%EB%B9%84/"},{"name":"시리","slug":"시리","permalink":"https://d2fault.github.io/tags/%EC%8B%9C%EB%A6%AC/"}]},{"title":"[Movie] 협상","slug":"20181002-movie-review-the-negotiation","date":"2018-10-02T13:34:12.000Z","updated":"2021-03-04T05:31:56.144Z","comments":true,"path":"2018/10/02/20181002-movie-review-the-negotiation/","link":"","permalink":"https://d2fault.github.io/2018/10/02/20181002-movie-review-the-negotiation/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 손예진이 큰일 좀 하겠다는데 왜 윗놈들이 훼방을 놓냐 이거야! 이상하게 손예진 나오는 영화는 다 재미있게 보는 것 같다. 현빈도 의외로 능청맞은 연기를 잘하고. 대부분의 스토리가 영상 통화로 진행되어 그런지 몰라도 최근에 본 서치가 떠올랐음. 머리와 말로 싸우는 영화라서 좋았다. 잔인한 장면이 나오기야 하지만 온 신경이 그쪽에 쏠리도록 나오진 않았다. 필요한 장면이라 넣은 것에 가까운 느낌? 둘의 대화가 멋있었다. 그리고 감독의 의도가 궁금했다. 처음에 보인 악과 마지막의 악이 다르니까. 진정한 악이 무엇이냐며 나를 다그치는 것 같았다. 보이는 것이 전부가 아님을 보인 영화라고 생각한다. 관객의 생각 축 변화를 의도한 거라면 감독의 능력에 박수를 보내야 한다. 음, 내가 깊이 생각하는 것일 수도. 여담이지만, 협상하는 방법을 재미로 한번 배워 보고 싶다. 평점 왜 혹평이 많은지 잘 모르겠다. 연기도 좋았고, 스토리도 괜찮았다. 주체적이고 능력있는 여성이 나오는 영화라 더 좋았다. (8.7 / 10.0)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Movie] 원더풀 고스트","slug":"20180926-movie-review-the-soul-mate","date":"2018-09-26T13:13:51.000Z","updated":"2021-03-04T05:31:56.136Z","comments":true,"path":"2018/09/26/20180926-movie-review-the-soul-mate/","link":"","permalink":"https://d2fault.github.io/2018/09/26/20180926-movie-review-the-soul-mate/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 대체 이게 무슨 영화람. 재미도, 감동도 없었다. 페이스북에서 ‘작가와 내 뇌가 연결된 줄 알았다.’ 라는 평을 보았는데 핵 공감. 생각한 게 그대로 영화에 나와요. 와, 이게 뭐지? 하나하나 조목조목 까고 싶은데 스포일러 남기기 싫어서 참는다. 기억에 남는 건 김영광 입꼬리, 그리고 애기의 사랑스러움? 아, 마동석과 애기의 말싸움은 좀 괜찮았다. 귀여워! 엄마는 엄청 재미있게 봤다던데 왜 난 아니지요? 코미디라며! 그래서 본 건데! 웃길 걸 기대하고 갔는데! 하나도 안 웃겨! 너무 속상해! 오랜만에 실컷 웃고 나오는 영화인가 싶었더니만! 전형적인 한국 영화야! 문화의 날에 봐서 다행이다. ^^ 평점 보지 마세요. 아니, 공짜로 보세요. (7.4 / 10.0)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Movie] 더넌","slug":"20180922-movie-review-the-nun","date":"2018-09-22T13:35:20.000Z","updated":"2021-03-04T05:31:56.127Z","comments":true,"path":"2018/09/22/20180922-movie-review-the-nun/","link":"","permalink":"https://d2fault.github.io/2018/09/22/20180922-movie-review-the-nun/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 머리에 지식 좀 생겼다고 분석하면서 봄. 무서움을 제대로 느끼고 싶다면 영 아니지만, 컨저링 시리즈의 연장선으로 보면 나쁘지 않다. 수녀 모습을 하고 신성을 모독하는 악마를 퇴마한다! 가 이 영화의 주제. 짜임은 이전 편보다 덜하다. 후반부로 갈수록 코미디의 느낌이 나. 아니, 신부님. 대체 왜 따라오신 거예요? 무능력의 끝판왕 아녀? 되도록 리뷰는 스포일러 없이 남기려고 노력하는데 이건 꼭 적어야겠다. 아이린 수녀는 처음에 견습 수녀? 견습생? 으로 나오는데, 중후반에 신부에게 수녀가 되겠다고 선포함. 그래서 신부가 수녀로 만들어 줌. 여기에서 재미있는 포인트가 있는데, 수녀가 되기 전엔 '성모님이 길을 가리키고 계신다.'라는 말을 잊지 않고 있다가, 수녀가 되고 나서 그걸 잊는다. 그래서 신부가 이 중요한 문장을 읊어줌. 그게 바로 키포인트! 궁금해서 물어봤다. 견습 수녀와 정식 수녀의 상징적 차이를! 견습 수녀 자신의 목표를 이루려하다, 궁금한 것을 신에게 묻다. 정식 수녀 법에 매여 있다, 입을 닫고 있다. 법에 매여서 성모님이 가리키는 길을 잊은 걸까? 어렵다, 어려워! 평점 ScreenX로 봤는데 처음에 완전 신기했음. 재미는 있었으니 후하게 드려요. (8.0 / 10.0)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Movie] 명당","slug":"20180920-movie-review-fengshui","date":"2018-09-20T14:16:38.000Z","updated":"2021-03-04T05:31:56.127Z","comments":true,"path":"2018/09/20/20180920-movie-review-fengshui/","link":"","permalink":"https://d2fault.github.io/2018/09/20/20180920-movie-review-fengshui/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 조승우의 오열 장면과 지성의 열연이 인상깊었다. 이 영화에서 흥선대원군은 누구보다 입체적인 인물로 표현되는데, 그 부분을 지성이 아주 잘 살렸다고 생각한다. 후반부로 갈수록 말라가는 건 다이어트를 한 건가? 기분 탓? 어쨌거나 지성이 대단한 연기자라는 건 명백한 사실이다. 영화 보고 나오면서 ‘와, 지성 연기…’ 말고 할 말이 없었으니까. 전체적으로 잘 만들어진 영화였다. 개연성도 있었고, 적절한 순간에 깔리는 BGM이 감초 역할을 제대로 했다. 묘도 스틸을 시도하는 장면에서는 영상으로 긴장감을 잡았다. 좁은 공간에 있는 인물의 얼굴을 강하게 클로즈업했는데, 숨막히는 상황을 잘 드러냈다고 생각한다. 문채원 너무 예쁘다. 진짜 예쁘다. 딕션이 귀에 콕콕 박혀서 똑부러지는 인상을 제대로 준다. 걸크러쉬 터지는 능력 짱짱 언니 역할로 돌아오면 좋겠다.(물론, 이 영화에서도 없어선 안 될 존재로 나온다.) 평점 풍수지리 넘나 흥미로운 것~! 배우들의 열연에 박수를! (8.6 / 10.0)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Hyperledger] Fabric 실습 - Basic Network 예제와 IBM Marbles 연동하기","slug":"20180904-hyperledger-fabric-basic-network-and-ibm-marbles","date":"2018-09-04T08:15:39.000Z","updated":"2021-03-04T05:31:56.126Z","comments":true,"path":"2018/09/04/20180904-hyperledger-fabric-basic-network-and-ibm-marbles/","link":"","permalink":"https://d2fault.github.io/2018/09/04/20180904-hyperledger-fabric-basic-network-and-ibm-marbles/","excerpt":"","text":"basic-network와 Marbles 연동 IBM-Blockchain에서 Marbles 예제를 제공한다. 이 예제에서는 owner의 자산(marble) 추가, 이동 그리고 블록의 생성을 시각화하여 보여준다. 실습은 다음의 순서로 진행할 것이다. fabric-sample의 basic-network를 띄우고, Marbles를 연결하여 Event(Block Listener, Event Client)를 확인한다. 이번 실습에서는 basic-network와 marbles를 연동하고, 클라이언트 조작으로 Event를 확인해 볼 것이다. fabric-sample fabric-sample 다운로드 1git clone https:&#x2F;&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples.git bootstrap.sh 파일 수정 및 실행 먼저, vim에 줄 넘버를 표시하자. 1:set number 160번대 라인을 보면, DOCKER, SAMPLES, BINARIES에 관한 flag가 설정되어 있다. DOCKER=TRUE는 docker image를, SAMPLES=TRUE는 fabric-sample을, BINARIES=TRUE는 바이너리 파일을 다운로드하겠다는 의미이다. 이미 우리는 위의 과정을 통해 SAMPLES와 BINARIES을 다운로드했기에 flag를 FALSE로 설정하고 진행할 것이다. 수정 후 docker image를 다운로드해 보자. 1.&#x2F;bootstrap.sh 네트워크 시작 fabric-samples/fabcar 경로에 있는 startFabric.sh 파일로 네트워크를 시작한다. 1.&#x2F;startFabric.sh node module 설치 fabric-samples/fabcar 경로에서 다음의 명령으로 node module을 설치한다. 1npm install Admin 등록 1node enrollAdmin.js user 등록 1node registerUser.js 여기까지 하면 hfc-key-store 디렉토리가 생긴다. 여기에는 등록된 user의 key file이 저장된다. IBM-Blockchain의 marbles 다운로드 상세 내용은 이 링크에서 확인할 수 있다. 홈 디렉토리에서 clone하자. (홈 디렉토리가 아닐 경우 경로를 직접 잡아 주어야 한다.) 1git clone https:&#x2F;&#x2F;github.com&#x2F;IBM-Blockchain&#x2F;marbles.git node module 설치 12cd marblesnpm install 체인코드 설치 12cd scriptnode install_chaincode.js 체인코드 instantiate 1node instantiate_chaincode.js 동작 확인 1234&#x2F;&#x2F; script의 상위 directory로 이동cd ..gulp marble_local&#x2F;&#x2F; 상세 내역은 gulpfile.js에 있음 localhost:3001에서 확인할 수 있다. 간단한 클라이언트 조작으로 Event(Block Listener, Event Client)를 날려 보자. 기타 keystore를 찾을 수 없다고 할 때? 해결할 수 있는 두 가지 방법이 있다. keystore directory를 통으로 날린 후, admin과 user를 재등록한다. 혹은 marbles/config/connection_profile_local.json의 &quot;path&quot;를 재설정한다.(상대 경로 재설정) 12&#x2F;&#x2F; 기본 설정&quot;path&quot;: &quot;&#x2F;$HOME&#x2F;github&#x2F;hlf-1.2.0&#x2F;network&#x2F;ca&#x2F;hfc-key-store&quot;","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"Hyperledger","slug":"Hyperledger","permalink":"https://d2fault.github.io/tags/Hyperledger/"},{"name":"Fabric","slug":"Fabric","permalink":"https://d2fault.github.io/tags/Fabric/"}]},{"title":"[Movie] 서치","slug":"20180831-movie-review-searching","date":"2018-08-31T02:30:25.000Z","updated":"2021-03-04T05:31:56.114Z","comments":true,"path":"2018/08/31/20180831-movie-review-searching/","link":"","permalink":"https://d2fault.github.io/2018/08/31/20180831-movie-review-searching/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 포맷이 굉장히 신선했다. 스토리 진행의 8할을 노트북 화면으로 대체하다니. 한편으로는 무섭기도 했다. 되도록 개인 정보를 SNS에 안 올리려고 하는데, 무심코 흘린 내 정보가 얼마나 많겠어. ㅠㅠ 무섭거나 놀래키는 장면이 없는데도 불구하고, 영화 처음부터 끝까지 눈을 떼지 못하게 만들었다. 트랩 안에 트랩이 있어서, 감독이 작정하고 흘린 증거만 쫓아간다면 범인 추리는 실패로 끝날 거야! 나처럼! ㅠ 됐고, 이 영화 최대 수혜자는 Google과 Apple이야. ㅋㅋㅋㅋ 여담이지만, Mac은 그렇다 쳐도, XP를 저렇게 알차게 쓸 수 있다는 건 이번 영화를 보고 알았다. ㅋㅋㅋ 그러나 XP는 아주 잠깐 나오니까 MS는 수혜자에서 제외하는 거로~! 평점 평점 좋은 건 다 이유가 있군! (8.5 / 10.0)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Movie] 너의 결혼식","slug":"20180828-movie-review-on-your-wedding-day","date":"2018-08-28T13:50:38.000Z","updated":"2021-03-04T05:31:56.113Z","comments":true,"path":"2018/08/28/20180828-movie-review-on-your-wedding-day/","link":"","permalink":"https://d2fault.github.io/2018/08/28/20180828-movie-review-on-your-wedding-day/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 이게 어떻게 12세지? 19드립이 난무하는 영화. 특히 초중반에 아주 아주 아주 많이 나온다. 가장 웃겼던 소재를 꼽자면 오렌지주스와 롤케익! (ㅋㅋㅋㅋㅋ) 그래서 엄마야 아빠아 사촌누나야 숙모야? 아, 불편한 부분이 없었냐고 묻는다면 없었다고는 못 합니다. 연애하고 싶게 만드는 마성의 영화였다. 꿈과 현실을 넘나드는 느낌. 김영광이 학생들에게 첫사랑 이야기를 할 때 과한 오버를 섞는 것도, 박보영의 편지를 받았을 때의 미묘한 표정 변화도 다 이유가 있는 거였어. 로맨스코미디 보고서 사색에 잠긴 건 또 처음이었다. 특히, 적당한 순간에 적당한 사람이 나타나면 그게 인연이라는 멘트에 공감 챠르르~ 자연스럽게 내 미래 생각도 해 보고, 타이밍이 언제 올까도 고민해 보고… 신나게 웃다가 복잡미묘한 마음으로 나왔다. 아, 그냥 웃고 끝내고 싶었는데! 아! 왜!!! 됐고, 더는 깊이 생각하고 싶지 않다. 김영광 너무 잘생겨서 미치는 줄 알았음. 평점 결국 사랑은, 타이밍이다. (8.0 / 10.0)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[PowerPoint] 파워포인트 전략적으로 작성하기","slug":"20180821-writing-powerpoint-strategically","date":"2018-08-21T02:01:21.000Z","updated":"2021-03-04T05:31:56.113Z","comments":true,"path":"2018/08/21/20180821-writing-powerpoint-strategically/","link":"","permalink":"https://d2fault.github.io/2018/08/21/20180821-writing-powerpoint-strategically/","excerpt":"","text":"탁월한 발표자의 7가지 능력 통찰력-문제 의식-정보력-창의력-구상력-설득력-실행력 PPT 보고서 작성을 위한 세 가지 요소 창의성(새로운 사고), 설득력(타인의 공감), 유효성(문제 해결 능력) 5-Why 접근법 과제 원인 원인 원인 원인: 본질에 가까운 원인 보고서를 작성하는 목표 AS-IS TO-BE 현재 상태 1, 2, 3, 4 미래 상태 1, 2, 3, 4 주체(Subject) + 대상(Object) + 상태(Status) 어떻게 하면 (주체)가 (대상 건)을 (바람직한 상태) 할 수 있을까? ex) 유통점 손실 예방을 위한 제안 - 근로 기준법 개정 적용의 건 고객에게 제안서를 쓸 때 고객이 우리가 원하는대로 생각하게 통제해야 한다. 알아서 판단해라 NO! 고객이 너무 많이 생각하게 하면 안 된다. 설득을 위한 W.H.W.E W what(우리의 문제 = 우리의 과제) H how(해결을 위한 우리의 방안) W why(그렇게 해야만 하는 이유) E Evidence(효과를 입증할 증거) Best 스토리라인 결정 무슨 이야기로 시작할 것인가? 어떤 순서로 이야기할 것인가? 어떤 것을 강조할 것인가? 어떤 이야기로 마무리할 것인가? PPT 보고서 작성의 3가지 핵심 직관적, 시각적, 간결함 PPT 작성에서 중요한 것 Grouping과 Leveling Grouping(같은 요소, 원인/결과, 전략/효과) Leveling(같은 수준, 상위/하위) 최대 4개 이하의 항목 구성 항목 간 콘텐츠 양을 맞춘다. 항목 간의 표현 구조를 통일시킨다. 도형 안에 텍스트를 넣는다. 기호/부호로 글자 수를 줄인다. 가급적 표준 글꼴을 사용한다. 편안하게 읽을 수 있는 크기로 만든다. 내용의 밀도 고려 난이도 고려 그림, 도표 사용 빈도 고려 읽는 이의 연령, 시력 고려 추후 사용할 용도 고려 KEY POINT! 같은 요소끼리 묶고(Grouping), 수준에 따라 배치(Leveling) 텍스트 양을 맞추고, 표현 구조를 통일 그래픽 요소 활용, 기본 폰트 미리 설정 파워포인트로 디테일 살리기 0.3의 효과 줄간격은 1.3이 적절하다. 내용이 많을 땐 1.0이 너무 빽빽하고, 1.5는 휑해 보인다. 색 사용 3색 이하의 색을 사용한다. 관련, 연결, 순서 관련된 것은 채도 변화를 이용한다. 아이콘 사용 Flaticon 사이트 참고.","categories":[{"name":"Blog","slug":"Blog","permalink":"https://d2fault.github.io/categories/Blog/"},{"name":"Information","slug":"Blog/Information","permalink":"https://d2fault.github.io/categories/Blog/Information/"}],"tags":[{"name":"powerpoint","slug":"powerpoint","permalink":"https://d2fault.github.io/tags/powerpoint/"},{"name":"ppt","slug":"ppt","permalink":"https://d2fault.github.io/tags/ppt/"}]},{"title":"[Exel] 엑셀 유용하게 사용하기(단축키, 함수 등)","slug":"20180820-exel-function-summary","date":"2018-08-20T05:01:14.000Z","updated":"2021-03-04T05:31:56.112Z","comments":true,"path":"2018/08/20/20180820-exel-function-summary/","link":"","permalink":"https://d2fault.github.io/2018/08/20/20180820-exel-function-summary/","excerpt":"","text":"Post Session: 엑셀 고급 단축키 사용자 정의 서식: ctrl+1 셀을 열 단위로 선택: ctrl+shift+오른쪽 방향키 셀을 행 단위로 선택: ctrl+shift+아래쪽 방향키 참조 범위 고정: F4 강제 개행: alt+enter 선택 영역 전체 채우기: ctrl+enter 사용자 정의 서식 셀을 특정 문자로 채우기 @*특정 문자 로 지정. @는 문자를 의미한다. 셀 서식 - 맞춤 - 균등 분할(들여쓰기) 들여쓰기 크기를 줘서 보기 좋게 정렬도 가능(균등 분할 정렬) 이름 지정 블록의 이름을 정의할 수 있다. 이름 정의: 왼쪽 상단의 이름 상자를 이용하거나, 수식 - 이름 관리자에서 직접 정의한다. 셀의 인덱스로 자동 이름 정의: 수식 - 선택 영역에서 만들기 이름 정의 수정: 수식 - 이름 정의 이름 지정 규칙 문자, 밑줄, \\ 중 하나로 시작 A3과 같은 셀 주소 형식으로 지정할 수 없다. 공백은 포함되지 않는다. 255자까지 대소문자 구분하지 않고 지정한다. 다양한 COUNT 함수 COUNT: 숫자만 카운트 COUNTA: 공백을 제외한 나머지[1]를 카운트 COUNTIF: 조건에 맞는 셀을 카운트 COUNTIFS: 여러 조건에 맞는 셀을 카운트 채우기 핸들 숫자+문자 복사: ctrl + 채우기 핸들 드래그 증가: 채우기 핸들 드래그 숫자 복사: 채우기 핸들 드래그 증가: ctrl + 채우기 핸들 드래그 날짜, 요일 복사: ctrl + 채우기 핸들 드래그 증가: 채우기 핸들 드래그 평일 단위 채우기 체크하면 주말 자동 제외 자동 채우기 형식 추가, 수정, 삭제 파일 - 옵션 - 고급 - 사용자 지정 목록 편집 에서 자동으로 채워지는 연속 데이터 단계 값 수정(단위 증가) 오른쪽 버튼 드래그 - 연속 데이터 - 단계 값 사용자 셀 서식 날짜 서식 년: YY, YYYY 월: M, MM, MMM[2], MMMM[3] 일: D, DD, DDD[4], DDDD[5], AAA[6], AAAA[7] 시: h, hh 분: m, mm 12시간제: 마지막에 am/pm 추가 문자 서식 아름다운@: 아름다운홍길동 @아름다운: 홍길동아름다운 숫자(계산) &amp;로 두 셀을 하나로 묶을 수 있다. ex) =B1&amp;B2 &amp;로 묶인 셀 숫자 형식으로 바꾸기 1을 곱해 준다. ex) =B1&amp;B2*1 유효성 검사 셀의 유효성[8] 설정: 데이터 - 데이터 유효성 검사 이미 입력된 셀의 유효성 검사: 데이터 - 데이터 유효성 검사 디테일 - 잘못된 데이터 자동 필터 서로 다른 필드에 대해 OR 연산을 할 수 없다. (AND만 가능) 적용: 데이터 - 필터 고급 필터 서로 다른 필드에 대해 OR 연산을 할 수 있다. 문자열 함수 LEFT =LEFT(문자열, 자리수) RIGHT =RIGHT(문자열, 자리수) MID =MID(문자열, 시작위치, 자리수) 빠른 채우기 찾아내는 문자열 길이가 전부 다를 때 유용하다. 첫 셀에서 원하는 문자열만 셀에 입력하고 입력할 셀 전체 선택 후 데이터 - 자동 채우기 VLOOKUP(수직) 찾는 데이터가 찾을 셀 범위의 처음에 존재해야 함. =VLOOKUP(분류할 셀 주소, 분류 기준 셀 범위, 출력할 셀의 위치를 정수로, TRUE/FALSE) 분류 기준 셀 범위는 이름을 정의해서 하면 된다. HLOOKUP(수평) MATCH 범위 내에서 상대적 위치를 반환함 =MATCH(찾는 값, 찾을 범위, 옵션) 옵션은 -1, 0, 1로 구분 INDEX =INDEX(차트 전체 범위, 행, 열) =INDEX(차트의 행이나 열, MATCH(값, 찾을 INDEX 범위, 0)) 문자 유무로만 카운트 가능하다면, COUNTIF 대신 COUNTA를 사용하는 것이 편하다. ↩︎ 영여 월 이름 세 자리 ↩︎ 영어 월 Full name ↩︎ 영어 요일 세 자리 ↩︎ 영어 요일 Full name ↩︎ 한글 요일 한 자리 ↩︎ 한글 요일 세 자리 ↩︎ 셀 참조를 이용, 이미 작성된 셀의 내용을 유효성 목록으로 추가할 수 있음 ↩︎","categories":[{"name":"Blog","slug":"Blog","permalink":"https://d2fault.github.io/categories/Blog/"},{"name":"Information","slug":"Blog/Information","permalink":"https://d2fault.github.io/categories/Blog/Information/"}],"tags":[{"name":"exel","slug":"exel","permalink":"https://d2fault.github.io/tags/exel/"}]},{"title":"[Movie] 신과 함께-인과 연","slug":"20180809-movie-review-along-with-the-gods-the-last-49-days","date":"2018-08-09T13:00:02.000Z","updated":"2021-03-04T05:31:56.098Z","comments":true,"path":"2018/08/09/20180809-movie-review-along-with-the-gods-the-last-49-days/","link":"","permalink":"https://d2fault.github.io/2018/08/09/20180809-movie-review-along-with-the-gods-the-last-49-days/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 의도하지 않게 이틀 내내(공작과 신과 함께) 주지훈을 본 게 함정~ 주지훈이 엄청 깔롱하게 나온다. 그런데 이 영화의 일등공신은 마동석 아닐까 싶다. 성주신 역으로 나오는데, 펀드니 비트코인이니 등의 이야기를 신이 직접 하는 게 너무 웃겼다. 웃긴 건 둘째고, 성주단지를 소재로 했다는 게 아주 신선했으며 성주신이 한 집안을 위해 현신했다는 콘셉트가 마음에 들었다. 무엇보다, 영화에서 우리나라의 토속 신앙(?)을 엿볼 수 있어 반가웠다. 회자정리, 거자필반. 나는 이 장면이 그렇게 슬펐다. 남들과 다른(?) 감성을 소유한 걸까? ㅋㅋ 삼차사의 전생을 다룬 편인데 뜬금없는 장면에서 울컥하는 것은 무엇? 이런들 저런들 어떠하리, 재미있게 보면 됐지~ 슬프지 않은 이별이란 없다. 만날 인연이면 다 만나겠지. 평점 이번에는 울지 않았어요. ^^ 3편도(나올 수밖에 없는 결말이라) 꼭 봐야지! (8.0 / 10.0)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Movie] 공작","slug":"20180808-movie-review-the-spy-gone-north","date":"2018-08-08T14:39:56.000Z","updated":"2021-03-04T05:31:56.098Z","comments":true,"path":"2018/08/08/20180808-movie-review-the-spy-gone-north/","link":"","permalink":"https://d2fault.github.io/2018/08/08/20180808-movie-review-the-spy-gone-north/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 액션 없는 액션 영화이나, 배우들의 열연이 영화를 가득 채웠다. 그들의 연기력은 인정할 수밖에 없지만, 항상 비슷한 역할과 비슷한 연기에 아쉬움이 남는다. 조진웅의 연기를 보고 분노의 윤리학이 떠올랐고, 황정민의 연기를 보고 국제시장이 떠올랐기 때문. 어디까지 진짜일까? 실화가 모티브인 영화임은 알고 있었지만, 흑금성 사건을 모르기에 의문이 들었다. 영화관을 나서며 바로 검색했으나 자세한 내용이 나오지 않아 아쉽다. 역사를 잘 아는 블로거가 이 사건을 잘 다뤄 주면 좋겠다. 관련 서적이나 논문을 추천받는 것도 오케이! 이 영화에서 좋은 점수를 주고 싶은 건 사운드와 CG이다. 긴장감 넘치는 사운드를 적절히 삽입하여 사람들을 졸지 않게 했다. 액션 연기 대신, 전략적인 모습을 부각시키는 영화이기에 사운드에 더 신경을 많이 쓴 듯했다. 어렴풋하게 현악기 소리가 많이 들어갔던 기억이 난다. 공작 관람객이라면 누구나 긍정적으로 평가하는 CG! 우리나라의 기술을 엿볼 수 있었다. 진짜 북한에서 촬영한 줄 알 정도로 자연스러웠다. 특히, 시점이 굉장히 특이했다. 황정민이 자동차에서 밖을 바라보는 시점이라거나, 다큐멘터리에서나 나올 법한 항공샷? 4D에 적합한 영화는 아니지만, 이 장면 만큼은 4D나 3D로 보고 싶었다. 빠른 종전, 빠른 평양 여행 소취! 평점 영화 시작 시간을 잘못 알고 들어가서 극초반을 놓친 게 아쉬움. 재미있게 보고 온 내 평점은, (8.5 / 10.0)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Diary] 전부 독서 때문이야","slug":"20180808-diary","date":"2018-08-08T03:35:28.000Z","updated":"2021-03-04T05:31:56.093Z","comments":true,"path":"2018/08/08/20180808-diary/","link":"","permalink":"https://d2fault.github.io/2018/08/08/20180808-diary/","excerpt":"","text":"고민의 발단 내 다른 취미가 시발점이 된 게 확실하다. 십 년도 전에 읽던 책을 다시 읽기도 하고, 새로운 책을 들이기도 하면서 독서의 늪에 다시 빠져 버렸다. 그러다 보니 (잊고 있던) 책 욕심과 소비량이 후욱 늘어 버린 건 함정. 그러던 중, 열정에 부채질한 사건이 있었으니. SWMaestro 지원의 일환으로 전자 도서관[1]을 사용할 수 있게 해 준다는 거 아니겠어요? 밀리의 서재 VS 리디 셀렉트 오, e-book! 개이득! …이라고 생각했으나, 책이 몇 권 없었다. ㅠㅠ 흑흑… 그래서 시작된 고민이 바로 밀리의 서재[2] VS 리디 셀렉트[3]! 최근 리디북스에서 밀리의 서재와 비슷한, 도서 구독 서비스를 출시했다는 사실을 알고 있었다. 책 한 권도 안 되는 가격에 무한정 읽을 수 있다는 게 매력 포인트. 그러나 나는 나를 못 믿는 병이 있고요… 이 열정이 얼마나 갈지 의문이고요… 선뜻 결제하기 쉽지 않고요… 둘 중 하나 고르는 것도 문제다. 애플리케이션 자체는 리디가 훠얼씬 좋다고 하는데, 세세한 기능(독서 SNS 같은 느낌?)은 밀리가 더 마음에 든다. 아, 어쩌란 말이냐. ㅠㅠ 그러나 사고 싶어, 이북 리더기 구독도 고민하는 주제에 이북 리더기는 사고 싶어요. 사람 마음이 이렇게 간사해. 2년 째 입으로만 사는 기계 중 하나다. 결제 직전까지 갔다가 매번 포기하는 이유는, '리디 페이퍼’를 사고 싶은데 '열린 서재’도 이용하고 싶기 때문. 리디북스가 열린 서재 지원하면 당장이라도 살 의향 있습니다. 셀렉트도 구독할게. 제발 내 주라! 내 돈 좀 쓰게 해 주라! 현실적인 타협점 당장[4] 리더기를 산다는 건 무리라고 생각한다. 여전히 나는 나를 못 믿겠습니다. 도무지 믿을 수가 있어야죠? 제일 싫어하는 게 비싼 기기 사서 방치하는 거라고! 방치하던 중에 새로운 기기 나오면 그 기분 어떻게 해? 일단, 행사[5] 중인 밀리를 먼저 구독해 볼까 싶다. 해 보고, 출퇴근 길에 생각보다 잘 본다 싶으면 리더기도 사고, 보고 싶은 책이 영 없다 싶으면 리디로 넘어가 봐야지. *^^* 역시 생각 정리는 글로 해야 해. 깔-끔. 삼성과 SKT에서 제공하는 앱을 사용해서 읽는 방법도 있다. 무료로 풀리는 책들이 꽤나 쏠쏠함. ↩︎ 9,900원/month ↩︎ 6,500원/month ↩︎ 당장이라고 하기엔 이미 2년이 지나긴 했다. ↩︎ 스마일페이로 결제하면 두 달에 백 원! 구독 해지도 가능! ↩︎","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Diary","slug":"Anything/Diary","permalink":"https://d2fault.github.io/categories/Anything/Diary/"}],"tags":[{"name":"일상","slug":"일상","permalink":"https://d2fault.github.io/tags/%EC%9D%BC%EC%83%81/"}]},{"title":"[Hyperledger] CentOS에서 Fabric 환경 구축하기","slug":"20180806-setting-fabric-developement-environment-centos","date":"2018-08-05T23:44:36.000Z","updated":"2021-03-04T05:31:56.092Z","comments":true,"path":"2018/08/06/20180806-setting-fabric-developement-environment-centos/","link":"","permalink":"https://d2fault.github.io/2018/08/06/20180806-setting-fabric-developement-environment-centos/","excerpt":"","text":"Hyperledger Fabric 개발 환경 구축(CentOS ver.) 이제 간신히 우분투랑 좀 친해지나 했더니 이번엔 CentOS다. 어색해서 쓰기 힘들 줄 알았는데 생각보다 쓰기 쉬움! 오히려 vncserver 해상도가 더 예쁘게 맞춰져서 마음에 든다. 아무튼, 우분투랑 설치 과정이 아주 살짝(이라고 하지만 시행착오는 똑같았음) 다르기 때문에 이 포스트를 적게 되었다. 이걸 보는 사람들은 나와 같은 시간적 손해가 없기를! 이 포스트 하나로 fabric 설치를 완벽하게 할 수 있다면 그걸로 목표 달성이다. 삽질의 완성판. ㅠㅠ wget 설치 1sudo yum install wget git 설치 1sudo yum install git 필수 개발 툴 설치 1sudo yum group install &quot;Development Tools&quot; 기타 개발 도구 설치 1sudo yum install libtool-ltdl-devel GO 언어 설치 패키지를 다운로드한다. 2018.08.01 기준 최신 버전은 1.10.3이다. 최신 버전 확인은 공식 홈페이지에서 할 수 있다. 1wget https://dl.google.com/go/go1.10.3.linux-amd64.tar.gz 압축을 푼다. 1tar xvzf go1.10.3.linux-amd64.tar.gz .bashrc 파일의 마지막에 다음을 추가한 후 저장한다. sudo vi .bashrc 명령으로 파일을 수정할 수 있다. .bashrc123export GOROOT=$HOME/goexport GOPATH=$HOME/gitexport PATH=$PATH:$GOROOT/bin:$GOPATH/bin 수정된 .bashrc 파일을 반영한다. 1source .bashrc go 버전을 확인해 본다. 1go version nvm 설치 nvm 공식 사이트 를 참고했다. 1wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash .bash_profile에 반영하자. 1source .bash_profile node 설치(npm 자동으로 설치됨) fabric 실습하기 위해선 적당한 버전(!)을 선택해야 한다. 절대로 v10은 사용하지 마세요. 에러 장난 X! 1234# nodejs v9.4.0 설치nvm install v9.4.0# v9.4.0을 사용한다는 의미. 다른 버전으로 바꾸는 것도 가능.nvm use v9.4.0 .bash_profile에 반영! 1source .bash_profile docker 설치 docker 설치 스크립트를 다운로드하자. 1curl -fsSL get.docker.com -o get-docker.sh 다운로드한 스크립트를 실행하자. 1sudo sh get-docker.sh sudo 명령 없이 docker 명령이 가능하도록 권한 설정을 해야 한다. (안 하면 매번 sudo 붙여야 함.) 단, 이 명령어는 재로그인 후에야 적용된다. terminal을 껐다 켜 주거나 logout -&gt; login 과정을 거치자! 1sudo usermod -aG docker [계정명] docker service(demon)을 실행해 본다. 1sudo systemctl start docker.service 설치가 제대로 되었는지 확인하기 위해 image를 출력해 본다. 1docker images Docker Compose 설치 주의: 버전에 따라 링크 url이 바뀝니다. 최신 버전 설치는 이 링크를 참고해 주세요. 12sudo curl -L https://github.com/docker/compose/releases/download/1.22.0-rc2/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-compose 다음 명령어로 버전 확인이 가능하다. 1docker-compose --version 업그레이드와 삭제 과정은 소제목 링크를 확인하면 된다. Hyperledger Fabric Sample 다운로드 샘플 코드는 원하는 디렉토리에 받으면 되는데, 나는 홈 디렉토리에서 다음의 명령어를 실행했다. 12# fabric-samples 다운로드git clone -b master https://github.com/hyperledger/fabric-samples.git jq 설치(balance-transfer 실습에 필요) 메뉴얼 보고 따라했다가 실패한 거 이렇게 간단히 끝남. Oniguruma was not found., checking for oniguruma.h... not found, checking for oniguruma.h... no, syntax error near unexpected token, disable-shared' LT_INIT 문제로 jq 설치 실패한 사람들 다 여기 여기 모여라!!! 이 링크 를 참고하여 작성했고, 이렇게나마 감사의 인사 올립니다. 영어로 검색하다 이틀 버렸어요. 한국어 짱이내… ^^… 12345678cd /usr/local/bin/sudo wget http://stedolan.github.io/jq/download/linux64/jq# 퍼미션 조정sudo chmod a+x jq# 퍼미션 확인ll jq# 테스트jq 추가 기능 설치 VSCode, Chrome 설치 VNCServer 설치 Postman 설치 끝으로 OS를 몇 번을 깔고 지웠는지 모르겠다. ^^ 덕분에 윈도우도 날리고 아주 신나~? 이제부터는 내가 만든 내 도큐먼트 보고 설치할 일 생길 때마다 챡챡 깔아야지!!! 설치만 오조 오억 년이야… 너무 힘든 시간이었다… 시작이 반인 게 확실하다…","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"Hyperledger","slug":"Hyperledger","permalink":"https://d2fault.github.io/tags/Hyperledger/"},{"name":"개발환경","slug":"개발환경","permalink":"https://d2fault.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD/"},{"name":"설치","slug":"설치","permalink":"https://d2fault.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"Fabric","slug":"Fabric","permalink":"https://d2fault.github.io/tags/Fabric/"},{"name":"CentOS","slug":"CentOS","permalink":"https://d2fault.github.io/tags/CentOS/"}]},{"title":"[Linux] CentOS에 Postman 설치하기","slug":"20180803-install-postman-centos","date":"2018-08-03T03:36:18.000Z","updated":"2021-03-04T05:31:56.091Z","comments":true,"path":"2018/08/03/20180803-install-postman-centos/","link":"","permalink":"https://d2fault.github.io/2018/08/03/20180803-install-postman-centos/","excerpt":"","text":"개요 CentOS 7 기준으로 쓰여진 포스트입니다. API 테스트를 돕는 Postman을 설치해 보자. 그나마 이 친구는 비교적 바로(?) 설치되어 뿌듯하다. 이번 포스트는 이 링크 를 참고하여 작성! 다만, 링크대로 진행하다 보면 Desktop Menu에 icon이 안 보여서 경로를 일부 수정했다. 설치하기 압축 파일을 다운로드하고, 압축을 해제한 후 ln 명령어로 링크 디렉토리를 만든다. 123456# 다운로드wget https://dl.pstmn.io/download/latest/linux64 -O postman.tar.gz# 압축 해제sudo tar -xzf postman.tar.gz -C /opt# 링크 디렉토리 생성sudo ln -s /opt/Postman/Postman /usr/bin/postman 놀랍게도 설치가 이게 전부이다. 실행하기 터미널에서 아래의 명령어(…)를 실행한다. 1postman 스무스한 실행 좋아요. b 매번 이렇게 터미널을 켜야 하냐고? No! 프로그램에 바로가기를 만들어 봅시다. 바로가기 생성 우선, /usr/share/applications 경로에 접근하자. 1cd /usr/share/applications 위의 경로에서 postman.desktop 파일을 생성할 것이다. 1sudo vi postman.desktop 아래의 내용을 postman.desktop에 추가 및 저장 후 에디터를 종료한다. postman.desktop12345678[Desktop Entry]Encoding=UTF-8Name=PostmanExec=postmanIcon=/opt/Postman/app/resources/app/assets/icon.pngTerminal=falseType=ApplicationCategories=Development 프로그램-개발에 들어가서 바로가기가 생긴 것을 확인해 보자. 😃","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Linux","slug":"IT/Linux","permalink":"https://d2fault.github.io/categories/IT/Linux/"}],"tags":[{"name":"설치","slug":"설치","permalink":"https://d2fault.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"Tip","slug":"Tip","permalink":"https://d2fault.github.io/tags/Tip/"},{"name":"CentOS","slug":"CentOS","permalink":"https://d2fault.github.io/tags/CentOS/"}]},{"title":"[Linux] CentOS에 Chrome과 VSCode 설치하기","slug":"20180803-install-chrome-and-vscode-centos","date":"2018-08-03T00:02:07.000Z","updated":"2021-03-04T05:31:56.084Z","comments":true,"path":"2018/08/03/20180803-install-chrome-and-vscode-centos/","link":"","permalink":"https://d2fault.github.io/2018/08/03/20180803-install-chrome-and-vscode-centos/","excerpt":"","text":"개요 CentOS는 프로그램 하나 까는 것도 쉽지 않다. 모두 명령어로 진행해야 한다. OS를 반복해서 까는 만큼, Application도 계-속 설치할 예정이기 때문에 이 포스트를 작성한다. -_- 내 포스트의 8할은 내가 멍청해서 쓰는 것 같다. ㅋㅋㅋㅋㅋㅋ Fact! CentOS 7 기준으로 쓰여진 포스트입니다. Chrome 설치 Chrome 설치는 이 블로그 의 내용을 참고하였다. 먼저, 다음의 명령어로 yum 저장소를 만든다. 1sudo vi /etc/yum.repos.d/google-chrome.repo vi로 아래의 내용을 추가한다.(저장: esc - :wq) google-chrome.repo123456[google-chrome]name=google-chromebaseurl=http://dl.google.com/linux/chrome/rpm/stable/$basearchenabled=1gpgcheck=1gpgkey=https://dl-ssl.google.com/linux/linux_signing_key.pub yum 명령어로 chrome을 설치한다. 1sudo yum install google-chrome-stable 프로그램 - 인터넷에 들어가 보면 Google Chrome를 확인할 수 있을 것. ^^ VSCode 설치 key와 repository를 설치한다. 12sudo rpm --import https://packages.microsoft.com/keys/microsoft.ascsudo sh -c &#x27;echo -e &quot;[code]\\nname=Visual Studio Code\\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\\nenabled=1\\ngpgcheck=1\\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc&quot; &gt; /etc/yum.repos.d/vscode.repo&#x27; 1. yum으로 설치(추천) 12yum check-updatesudo yum install code 2. dnf로 설치 먼저, dnf를 인스톨한다. 1234wget http://springdale.math.ias.edu/data/puias/unsupported/7/x86_64/dnf-conf-0.6.4-2.sdl7.noarch.rpmwget http://springdale.math.ias.edu/data/puias/unsupported/7/x86_64//dnf-0.6.4-2.sdl7.noarch.rpmwget http://springdale.math.ias.edu/data/puias/unsupported/7/x86_64/python-dnf-0.6.4-2.sdl7.noarch.rpmyum install python-dnf-0.6.4-2.sdl7.noarch.rpm dnf-0.6.4-2.sdl7.noarch.rpm dnf-conf-0.6.4-2.sdl7.noarch.rpm 다음의 명령어로 VSCode를 설치한다. 12dnf check-updatesudo dnf install code","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Linux","slug":"IT/Linux","permalink":"https://d2fault.github.io/categories/IT/Linux/"}],"tags":[{"name":"설치","slug":"설치","permalink":"https://d2fault.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"Tip","slug":"Tip","permalink":"https://d2fault.github.io/tags/Tip/"},{"name":"CentOS","slug":"CentOS","permalink":"https://d2fault.github.io/tags/CentOS/"}]},{"title":"[Linux] CentOS에 VNCServer 설치 및 사용하기","slug":"20180802-install-vncserver-centos","date":"2018-08-02T04:09:37.000Z","updated":"2021-03-04T05:31:56.011Z","comments":true,"path":"2018/08/02/20180802-install-vncserver-centos/","link":"","permalink":"https://d2fault.github.io/2018/08/02/20180802-install-vncserver-centos/","excerpt":"","text":"개요 CentOS 7 기준으로 쓰여진 포스트입니다. VSCode를 쓰려면 노트북을 건드려야 하는 게 싫었다. 터미널과는 영 친하지 않아서, 에디터는 GUI를 꼭! 사용하고 싶었다. 이 열망으로 검색하다 얻어걸린 게 바로 VNC! 요 친구를 사용하면 원격으로 해당 컴퓨터의 GUI를 사용할 수 있다. 설치 - vncserver 설정 - 방화벽 설정의 순서로 진행해 보자. 설치하기 yum으로 간단하게 설치가 끝난다. 1sudo yum install tigervnc-server 세션을 실행해 보자. 1vncserver 패스워드를 입력하라고 나온다. root 계정의 패스워드를 입력하면 된다. 방화벽 설정하기 프로그램 - 잡다 - 방화벽 으로 들어간다. 계정 암호를 입력한다. 설정을 영구적으로 바꾸고, 포트 탭을 선택한다. 5901-5910를 입력하고 확인을 누른다. 옵션 - firewalld 다시 불러오기 를 클릭한다. 생각보다 간단하게 방화벽 설정이 완료되었다. vncserver 실행 및 종료 12345678# 서버 실행vncserver# 해상도 지정 후 서버 실행vncserver -geometry 1920x1080# 서버 종료, 콜론도 꼭 붙여 줘야 한다.vncserver -kill :[포트number] 어떻게 접속하나요? VNC Viewer로 접속할 수 있습니다. OS에 맞는 설치 파일을 다운로드하여 사용하면 된다. 다음은 mac용 viewer의 예시이다. Viewer에 색이 이상하게 보여요 중앙 상단 옵션 메뉴(숨겨져 있습니다. 마우스 갖다대면 보임.)에서 setting을 선택하고, Option 탭에서 Picture quality를 Medium으로 선택하시면 정상적으로 보입니다. High로 선택하면 렉이 심해져요.","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Linux","slug":"IT/Linux","permalink":"https://d2fault.github.io/categories/IT/Linux/"}],"tags":[{"name":"설치","slug":"설치","permalink":"https://d2fault.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"Tip","slug":"Tip","permalink":"https://d2fault.github.io/tags/Tip/"},{"name":"CentOS","slug":"CentOS","permalink":"https://d2fault.github.io/tags/CentOS/"}]},{"title":"[Linux] CentOS에 GNU Automake 설치하기","slug":"20180802-install-gnu-automake-centos","date":"2018-08-02T00:42:49.000Z","updated":"2021-03-04T05:31:56.009Z","comments":true,"path":"2018/08/02/20180802-install-gnu-automake-centos/","link":"","permalink":"https://d2fault.github.io/2018/08/02/20180802-install-gnu-automake-centos/","excerpt":"","text":"GNU Automake 설치 CentOS 7 기준으로 쓰여진 포스트입니다. M4, autoconf, automake 순서로 설치해야 오류를 피할 수 있다. 먼저, M4, autoconf, automake 압축 파일을 다운해 보자. 최신 버전은 이 링크들(m4, autoconf, automake)에서 각각 확인 가능하다. (해당 내용은 이 블로그 를 참고로 작성되었다.) 123456# m4wget http://ftp.gnu.org/gnu/m4/m4-1.4.18.tar.gz# autoconfwget http://ftp.gnu.org/gnu/autoconf/autoconf-2.69.tar.gz# automakewget http://ftp.gnu.org/gnu/automake/automake-1.16.1.tar.gz 압축은 이렇게 풀면 된다. 123456# m4tar xvfz m4-1.4.18.tar.gz# autoconftar xvfz autoconf-2.69.tar.gz# automaketar xvfz automake-1.16.1.tar.gz m4 설치 123cd m4-1.4.18./configure --prefix=/usrmake &amp;&amp; sudo make install autoconf 설치 123cd autoconf-2.69./configure --prefix=/usrmake &amp;&amp; sudo make install automake 설치 123cd automake-1.16.1./configure --prefix=/usrmake &amp;&amp; sudo make install","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Linux","slug":"IT/Linux","permalink":"https://d2fault.github.io/categories/IT/Linux/"}],"tags":[{"name":"개발환경","slug":"개발환경","permalink":"https://d2fault.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD/"},{"name":"설치","slug":"설치","permalink":"https://d2fault.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"CentOS","slug":"CentOS","permalink":"https://d2fault.github.io/tags/CentOS/"},{"name":"m4","slug":"m4","permalink":"https://d2fault.github.io/tags/m4/"},{"name":"autoconf","slug":"autoconf","permalink":"https://d2fault.github.io/tags/autoconf/"},{"name":"automake","slug":"automake","permalink":"https://d2fault.github.io/tags/automake/"}]},{"title":"[Linux] SSH 사용하기","slug":"20180801-using-ssh","date":"2018-08-01T06:52:01.000Z","updated":"2021-03-04T05:31:56.006Z","comments":true,"path":"2018/08/01/20180801-using-ssh/","link":"","permalink":"https://d2fault.github.io/2018/08/01/20180801-using-ssh/","excerpt":"","text":"개요 Front-end 개발만 했던 난, ssh를 윈도우에서 제공한다고 했을 때 ‘그런가보다’ 하고 말았다. 그 의미를 이제서야 깨닫다니… 마법과도 같은 존재다. 개발 PC 건드리지 않고 개인 PC(mac)로 개발할 수 있게 해 주는 마법의 ssh!!! 사용법도 쉽다. (리눅스 사용과 동시에 사용하고 있었다. 포스팅이 늦어서 그렇지… 바보의 마지막 자존심!) ssh 사용하기 1ssh 계정ID@[접속하고자 하는 ip주소] 패스워드는 계정의 패스워드를 입력하면 된다. 이제 당신은 모든 것을 얻었다. ㅋㅋㅋㅋ 평소 터미널 사용하듯 사용하시면 됩니다. (부록) ssh 접속 불가 해결하기(It is also possible that a host key has just been changed.) 평소와 같이(는 사실 아님!) ssh로 접근했는데 다음과 같은 에러가 뜰 때가 있다. 12345678910111213@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the ECDSA key sent by the remote host isSHA256:[key ID].Please contact your system administrator.Add correct host key in [key store 경로] to get rid of this message.Offending ECDSA key in [key store 경로]ECDSA host key for [접근하고자 하는 IP주소] has changed and you have requested strict checking.Host key verification failed. 이 에러는 ssh client에 저장된 key가 만료되었을 때 나온다. 즉, 접속하고자 하는 server의 IP가 동일한데 해당 server의 OS가 재설치되었을 경우 위의 에러를 만날 수 있다. 해결 방법은 굉장히 간단하다. 1ssh-keygen -R [접속하고자 하는 IP 주소] 위의 명령어 실행 후 재접속(ssh 명령어)하면 아주 잘됨. *^^*","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Linux","slug":"IT/Linux","permalink":"https://d2fault.github.io/categories/IT/Linux/"}],"tags":[{"name":"Tip","slug":"Tip","permalink":"https://d2fault.github.io/tags/Tip/"},{"name":"ssh","slug":"ssh","permalink":"https://d2fault.github.io/tags/ssh/"}]},{"title":"[Movie] 분노의 윤리학","slug":"20180730-movie-review-an-ethics-lesson","date":"2018-07-30T11:27:19.000Z","updated":"2021-03-04T05:31:55.993Z","comments":true,"path":"2018/07/30/20180730-movie-review-an-ethics-lesson/","link":"","permalink":"https://d2fault.github.io/2018/07/30/20180730-movie-review-an-ethics-lesson/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 이 영화에서 다루는 모든 사건에는 여자가 있다. 여자에게 돈을 빌려주거나, 여자의 스폰서이거나, 여자를 스토킹하거나, 죽이거나. 잔인하고 야한 것보단 오히려 엽기에 가까운 느낌? 제3자인 관객의 입장에서 그들은 모두 범죄자이다. 그러나 그런 범죄자들이 영화 내내 '내 죄’는 '무죄’이나 '네 죄’는 '죄’라고 말한다. 아이러니~ 이런 장면들이 실소를 금할 수 없게 한다. 이 영화에 나오는 캐릭터는 모두 조금 모자라게 판단하고, 과하게 연기한다. 그 모습이 유치하고 촌스럽게 느껴지는데 나는 감독이 이 느낌을 의도했다고 생각한다. 비현실에 가까운 줄거리는 영화로만 남기고 그 이면을 보라는 의도 아니었을까. 우리의 도덕, 윤리는 누구의 도덕이자 윤리인지 생각해 보라는 물음표로 보였다. 내가 의미 부여를 과하게 한 것일 수도. ^^ 에잉, 그래도 영화가 불편하지 않았다면 거짓이다. 여기에서도 여자는 가장 약한 존재. 돈 때문에 몸을 팔고, 결국 살해당하는 뻔한 캐릭터. 이런 틀에서 벗어난 캐릭터가 ‘많이’ 나왔으면 좋겠다. ‘많이’!!! 평점 한 번 꼬아 드러낸 현실, 애교스러운 막장. 이만하면 괜찮은데? (9.0 / 10.0) 네이버 평점은 무슨 일이야…","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Movie] 안녕, 나의 소녀","slug":"20180728-movie-review-take-me-to-the-moon","date":"2018-07-28T03:51:10.000Z","updated":"2021-03-04T05:31:55.991Z","comments":true,"path":"2018/07/28/20180728-movie-review-take-me-to-the-moon/","link":"","permalink":"https://d2fault.github.io/2018/07/28/20180728-movie-review-take-me-to-the-moon/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 워낙 대만 특유의 감성(주로 로맨스, 청춘물)을 좋아한다. 그 시절 우리가 좋아했던 소녀나, 나의 소녀시대를 재미있게 봤던 터라 이 영화도 꼭 봐야겠다 싶었지. 영화관에서 봤으면 좋았겠지만 마침 옥수수에서 토요 무료 영화로 풀어 주길래~ 냉큼 봤다. 나의 소녀시대 에서와는 다르게, 여기에서 송운화는 슈퍼스타였다. 노래할 때(송운화가 노래를 그렇게 잘하는 줄 몰랐다.) 제일 반짝이는 별! 뭐, 당연히 류이호는 송운화를 짝사랑했고. 신묘한 도구를 판매하는 할머니가 나온다. 내내 나온다. 어떻게 주인공 주변에 계속 머무를 수 있나요? 당신은 역시 인간이 아닌 것이지요? 유치한 건 둘째이고, 시사점이 많은 영화. 음악을 좋아하는 나로서는 소소하게 즐거울 수 있던 영화. 지금의 나는 과거의 내 선택들이 만들었고, 미래의 나는 앞으로의 내 선택이 만들 예정이라는 것? 항상 생각했던 걸 눈으로 직접 본 느낌이라 묘했다. (할머니, 사실을 말해 봐요… 당신은 마법사일 거야…) 평점 류이호! 사랑해! 나를 가져! (7.5 / 10.0)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Hyperledger] Composer Transaction Processor 함수(2)","slug":"20180725-hyperledger-composer-transaction-processor-function-2","date":"2018-07-25T06:51:28.000Z","updated":"2021-03-04T05:31:55.990Z","comments":true,"path":"2018/07/25/20180725-hyperledger-composer-transaction-processor-function-2/","link":"","permalink":"https://d2fault.github.io/2018/07/25/20180725-hyperledger-composer-transaction-processor-function-2/","excerpt":"","text":"Hyperledger Composer Transaction Processor Function(2) 튜토리얼 내용이 너무 길어 반으로 잘랐다. 오늘은 data return과 쿼리 내용을 살펴볼 예정! 설명은 거의 없고 예시 위주로 되어 있어서 편하면서도 불편하다. 역설적인 마음~ 데이터 반환(return) 트랜잭션 프로세서에서는 데이터를 선택적으로 리턴할 수 있다. 리턴을 사용하면 트랜잭션 전달자에게 '제대로 전송되었어요!'를 반환으로(return) 증명할 수 있다. 이 방법으로, 트랜잭션 확정 확인을 위한 별도 조회 프로세스가 사라지기 때문에 부하가 줄어든다. 리턴 데이터는 기본 유형 (String, Integer, Long 등)이나 컴포저 모델링 언어를 사용하여 모델링한 유형(개념, 자산, 참가자, 트랜잭션, 이벤트 또는 열거)이 될 수 있다. 리턴 데이터의 유형도 @returns(Type)데코레이터를 사용하여 트랜잭션 모델에 지정해야 한다. 단일 트랜잭션에 대해 여러 트랜잭션 프로세서 기능이있는 경우, 하나의 데이터만 반환할 수 있다. 리턴 데이터가 누락되거나 잘못된 유형인 경우 트랜잭션이 실패하고 거부된다. 기본 유형 반환 다음은 트랜잭션 처리 함수에서 문자열을 클라이언트에 리턴하는 예시이다. model file123456namespace org.sample@returns(String)transaction MyTransaction &#123;&#125; transaction processor function123456789/** * Handle a transaction that returns a string. * @param &#123;org.sample.MyTransaction&#125; transaction The transaction. * @returns [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string) The string. * @transaction */async function myTransaction(transaction) &#123; return &#x27;hello world!&#x27;;&#125; 아래와 같이, 클라이언트에서 string을 받을 수 있다. 123456const bnc = new BusinessNetworkConnection();await bnc.connect(&#x27;admin@sample-network&#x27;);const factory = bnc.getBusinessNetwork().getFactory();const transaction = factory.newTransaction(&#x27;org.sample&#x27;, &#x27;MyTransaction&#x27;);const string = await bnc.submitTransaction(transaction);console.log(`transaction returned $[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string)`); 아래의 예시는 트랜잭션 처리 함수에서 정수형 배열을 클라이언트에 리턴하는 예시이다. model file123456namespace org.sample@returns(Integer[])transaction MyTransaction &#123;&#125; transaction processor function123456789/** * Handle a transaction that returns an array of integers. * @param &#123;org.sample.MyTransaction&#125; transaction The transaction. * @returns &#123;number[]&#125; The array of integers. * @transaction */async function myTransaction(transaction) &#123; return [1, 2, 3];&#125; int형 배열은 다음과 같이 받을 수 있다. 12345678const bnc = new BusinessNetworkConnection();await bnc.connect(&#x27;admin@sample-network&#x27;);const factory = bnc.getBusinessNetwork().getFactory();const transaction = factory.newTransaction(&#x27;org.sample&#x27;, &#x27;MyTransaction&#x27;);const integers = await bnc.submitTransaction(transaction);for (const integer of integers) &#123; console.log(`transaction returned $&#123;integer&#125;`);&#125; 복합 유형 반환 동일한 코드를 수정하여 자산, 참가자, 트랜잭션 또는 이벤트를 반환 할 수도 있다. model file12345678910namespace org.sampleconcept MyConcept &#123; o String value&#125;@returns(MyConcept)transaction MyTransaction &#123;&#125; transaction prcessor function123456789101112/** * Handle a transaction that returns a concept. * @param &#123;org.sample.MyTransaction&#125; transaction The transaction. * @returns &#123;org.sample.MyConcept&#125; The concept. * @transaction */async function myTransaction(transaction) &#123; const factory = getFactory(); const concept = factory.newConcept(&#x27;org.sample&#x27;, &#x27;MyConcept&#x27;); concept.value = &#x27;hello world!&#x27;; return concept;&#125; 복합 유형은 다음과 같이 받을 수 있다. 123456const bnc = new BusinessNetworkConnection();await bnc.connect(&#x27;admin@sample-network&#x27;);const factory = bnc.getBusinessNetwork().getFactory();const transaction = factory.newTransaction(&#x27;org.sample&#x27;, &#x27;MyTransaction&#x27;);const concept = await bnc.submitTransaction(transaction);console.log(`transaction returned $&#123;concept.value&#125;`); 다음의 방법으로 트랜잭션 처리 함수에서 concept를 클라이언트에 리턴할 수도 있다. model file12345678910namespace org.sampleconcept MyConcept &#123; o String value&#125;@returns(MyConcept[])transaction MyTransaction &#123;&#125; transaction prcessor function12345678910111213141516/** * Handle a transaction that returns an array of concepts. * @param &#123;org.sample.MyTransaction&#125; transaction The transaction. * @returns &#123;org.sample.MyConcept[]&#125; The array of concepts. * @transaction */async function myTransaction(transaction) &#123; const factory = getFactory(); const concept1 = factory.newConcept(&#x27;org.sample&#x27;, &#x27;MyConcept&#x27;); concept1.value = &#x27;hello alice!&#x27;; const concept2 = factory.newConcept(&#x27;org.sample&#x27;, &#x27;MyConcept&#x27;); concept2.value = &#x27;hello bob!&#x27;; const concept3 = factory.newConcept(&#x27;org.sample&#x27;, &#x27;MyConcept&#x27;); concept3.value = &#x27;hello charlie!&#x27;; return [ concept1, concept2, concept3 ];&#125; 클라이언트에서는 아래와 같이 받으면 된다. 12345678const bnc = new BusinessNetworkConnection();await bnc.connect(&#x27;admin@sample-network&#x27;);const factory = bnc.getBusinessNetwork().getFactory();const transaction = factory.newTransaction(&#x27;org.sample&#x27;, &#x27;MyTransaction&#x27;);const concepts = await bnc.submitTransaction(transaction);for (const concept of concepts) &#123; console.log(`transaction returned $&#123;concept.value&#125;`);&#125; 열거형 배열(enum)을 받고 싶다면? 다음의 예시를 확인해 보자. model1234567891011namespace org.sampleenum MyEnum &#123; o HELLO o WORLD&#125;@returns(MyEnum[])transaction MyTransaction &#123;&#125; transaction prcessor function123456789/** * Handle a transaction that returns an array of enumerations. * @param &#123;org.sample.MyTransaction&#125; transaction The transaction. * @returns &#123;org.sample.MyEnum[]&#125; The array of enumerations. * @transaction */async function myTransaction(transaction) &#123; return [ &#x27;HELLO&#x27;, &#x27;WORLD&#x27; ];&#125; 클라이언트에서는 이렇게 처리하면 된다. 12345678const bnc = new BusinessNetworkConnection();await bnc.connect(&#x27;admin@sample-network&#x27;);const factory = bnc.getBusinessNetwork().getFactory();const transaction = factory.newTransaction(&#x27;org.sample&#x27;, &#x27;MyTransaction&#x27;);const enums = await bnc.submitTransaction(transaction);for (const enum of enums) &#123; console.log(`transaction returned $&#123;enum&#125;`);&#125; 읽기 전용 Function(Query Processor Function) @commit(false) decorator를 이용, 읽기 전용 트랜잭션으로 지정할 수 있다. 읽기 전용으로 모델링할 경우에도 트랜잭션은 정상 제출되며, 트랜잭션 프로세서 기능 또한 정상적으로 실행되지만 커밋되지 않는다. 이 기능은 클라이언트 응용 프로그램이 비즈니스 네트워크에서 데이터를 읽는 데 사용할 수있는 API가 사용 사례에 비해 너무 제한적일 때 사용하면 좋다. get(id), getAll(), exists(id), query(q, params) 등을 지원한다. 다음 예제를 확인해 보자. 이 예제는 현재의 비즈니스 네트워크뿐 아니라 다른 비즈니스 네트워크에서 Asset set을 검색하고, 찾아낸 모든 Asset의 집합을 return한다. model123456789101112namespace org.sampleasset MyAsset identified by assetId &#123; o String assetId o String value&#125;@commit(false)@returns(MyAsset[])transaction MyTransaction &#123;&#125; transaction prcessor function1234567891011121314151617181920212223/** * Handle a transaction that returns an array of assets. * @param &#123;org.sample.MyTransaction&#125; transaction The transaction. * @returns &#123;org.sample.MyAsset[]&#125; All the assets. * @transaction */async function myTransaction(transaction) &#123; const allAssets = []; const assetRegistry = await getAssetRegistry(&#x27;org.sample.MyAsset&#x27;); const localAssets = await assetRegistry.getAll(); for (const asset of localAssets) &#123; localAssets.push(asset); &#125; const businessNetworkNames = [&#x27;other-network-1&#x27;, &#x27;other-network-2&#x27;]; for (const businessNetworkName of businessNetworkNames) &#123; const response = await getNativeAPI().invokeChaincode(businessNetworkName, [&#x27;getAllResourcesInRegistry&#x27;, &#x27;Asset&#x27;, &#x27;org.sample.MyAsset&#x27;], &#x27;composerchannel&#x27;); const json = JSON.parse(response.payload.toString(&#x27;utf8&#x27;)); for (const item of json) &#123; allAssets.push(getSerializer().fromJSON(item)); &#125; &#125; return allAssets;&#125; 클라이언트 어플리케이션에서는 다음과 같이 확인 가능하다. 12345678const bnc = new BusinessNetworkConnection();await bnc.connect(&#x27;admin@sample-network&#x27;);const factory = bnc.getBusinessNetwork().getFactory();const transaction = factory.newTransaction(&#x27;org.sample&#x27;, &#x27;MyTransaction&#x27;);const assets = await bnc.submitTransaction(transaction);for (const asset of assets) &#123; console.log(`transaction returned $&#123;asset.value&#125;`);&#125;","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"Hyperledger","slug":"Hyperledger","permalink":"https://d2fault.github.io/tags/Hyperledger/"},{"name":"Composer","slug":"Composer","permalink":"https://d2fault.github.io/tags/Composer/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://d2fault.github.io/tags/Tutorial/"}]},{"title":"[Movie] 곤지암","slug":"20180724-movie-review-gonjiam-haunted-asylum","date":"2018-07-24T11:15:27.000Z","updated":"2021-03-04T05:31:55.981Z","comments":true,"path":"2018/07/24/20180724-movie-review-gonjiam-haunted-asylum/","link":"","permalink":"https://d2fault.github.io/2018/07/24/20180724-movie-review-gonjiam-haunted-asylum/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 일곱 명의 주인공 중 마음에 드는 캐릭터 단 한 명도 없음. 전부 거슬림. 연기? 나쁘지 않은데 캐릭터가 마음에 안 들다 보니까 연기까지 거슬림. 영상미? 공포 영화에서 찾기 힘든 부분. 사운드? 글쎄. 이 영화 구성으로 볼 때 사운드가 큰 부분을 차지하는 것 같지 않음. 초반에는 나대는 것만 나오고, 그나마 중후반부? 에야 공포스러운 영화가 되니까. 기괴한 소리가 날 이유도 없었고. 외국 공포 영화 중 REC였나? 그 영화에서 사용한 촬영 방식[1]과 비슷한 것 같은데(콘셉트가 호러 라이브 방송) 신선하긴 했으나 촌스러웠다. 일부러 아마추어 느낌을 내려고 그런 건가? 중간중간 끊기는 부분도 일부러 넣은 것 같은데(리얼리티도 높이고, 답답한 기분을 주려고) 타이밍이 절묘하지 못했다. 나에겐 그저 짜증나는 장치였을 뿐! 평점 유치했으나 퇴근길이 심심하진 않았음. 영화관에서 안 보길 잘했어! (6.5 / 10.0) 점수 참 후하다 후해! 유투브 스트리머의 영상이라고 보면 될 것 같다. 1인칭 촬영자 시점. ↩︎","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Hyperledger] Composer Transaction Processor 함수(1)","slug":"20180724-hyperledger-composer-transaction-processor-function-1","date":"2018-07-24T05:15:18.000Z","updated":"2021-03-04T05:31:55.981Z","comments":true,"path":"2018/07/24/20180724-hyperledger-composer-transaction-processor-function-1/","link":"","permalink":"https://d2fault.github.io/2018/07/24/20180724-hyperledger-composer-transaction-processor-function-1/","excerpt":"","text":"Hyperledger Composer Transaction Processor Function(1) 어떻게 하다 보니 여기까지 오긴 왔다. 이 링크 를 참고하여 트랜잭션을 관리(?)하는 함수를 작성해 보도록 하자! 예! 앞의 두 포스트는 이 포스트를 적기 위한 과정이었을 뿐. ㅠㅠ 험난했다. Hyperledger Composer 비즈니스 네트워크는 모델 파일과 스크립트가 set로 구성된다. 스크립트에는 모델 파일에 정의 된 트랜잭션을 구현하는 트랜잭션 프로세서 기능을 포함할 수 있다. Transaction Processor 함수는 BusinessNetworkConnection API를 사용하여 트랜잭션을 날릴 때 런타임에 의해 자동으로 호출된다. 문서 내의 decorator는 런타임 처리에 필요한 메타 데이터를 주석으로 단다. 각 트랜잭션에는 트랜잭션을 저장하는 레지스트리가 있다. 트랜잭션 프로세서의 구조 트랜잭션 프로세서 함수에는 Decorator, Metadata, JS 함수가 포함된다. 이 함수가 동작하기 위해서는 @param 과 @transaction 두 부분이 모두 필요하다. 주석의 첫 번째 줄에는 트랜잭션 처리 함수가 수행하는 기능에 대한 설명이 들어 있다. 두 번째 줄에는 @param매개 변수 정의를 나타내는 태그가 있어야 한다 . @param태그 다음에는 트랜잭션 프로세서 기능을 트리거하는 트랜잭션의 리소스 이름이 온다. 이 태그는 비즈니스 네트워크의 네임 스페이스 형식과 트랜잭션 이름 뒤에 위치한다. 리소스 이름 뒤에, 리소스를 참조 할 매개 변수 이름이 있으면 이 매개 변수를 JavaScript 함수에 인수로 제공해야 한다. 세 번째 줄에는 @transaction태그가 있어야 한다. 이 태그는 코드를 트랜잭션 프로세서 기능으로 식별하므로 꼭 필요하다. 12345/*** A transaction processor function description* @param &#123;org.example.basic.SampleTransaction&#125; parameter-name A human description of the parameter* @transaction*/ 주석은 트랜잭션에 권한을 부여하는 JavaScript 함수이다. 이 함수는 임의의 이름을 가질 수 있지만 주석에 정의 된 매개 변수 이름(parameter-name)을 인수로 포함해야합니다. 123function transactionProcessor(parameter-name) &#123; // 이곳에 함수 처리 과정을 담는다&#125; 두 형식을 모두 적용한 코드는 다음과 같다. 12345678/*** A transaction processor function description* @param &#123;org.example.basic.SampleTransaction&#125; parameter-name A human description of the parameter* @transaction*/function transactionProcessor(parameter-name) &#123; //Do some things.&#125; 함수 작성하기 트랜잭션 프로세서 함수는 모델 파일에 정의 된 트랜잭션의 논리적 연산이다. 예를 들어, Trade 트랜잭션의 트랜잭션 프로세서는 owner 의 값을 한 참여자에서 다른 참여자로 변경할 수 있다.(owner가 a였는데 b가 되는 등의 변경) 다음 basic-sample-network 예제의 SampleAsset 에 String으로 정의된 value 속성이 있다. SampleTransaction 에 변경될 값인 newValue 를 value 속성으로 전달해야 한다. 12345678910asset SampleAsset identified by assetId &#123; o String assetId --&gt; SampleParticipant owner o String value&#125;transaction SampleTransaction &#123; --&gt; SampleAsset asset o String newValue&#125; SampleTransaction은 다음의 코드처럼 asset 및 asset이 저장된 레지스트리 모두를 변경한다. 1234567891011121314151617181920212223242526/** * Sample transaction processor function. * @param &#123;org.example.basic.SampleTransaction&#125; tx The sample transaction instance. * @transaction */async function sampleTransaction(tx) &#123; // asset의 이전 값을 저장한다. let oldValue = tx.asset.value; // asset의 값을 새 값으로 저장한다. tx.asset.value = tx.newValue; // registry에 있는 값을 불러온다. let assetRegistry = getAssetRegistry(&#x27;org.example.basic.SampleAsset&#x27;); // registry에 있는 값을 업데이트한다. await assetRegistry.update(tx.asset); // 수정된 asset을 이벤트로 전달한다. let event = getFactory().newEvent(&#x27;org.example.basic&#x27;, &#x27;SampleEvent&#x27;); event.asset = tx.asset; event.oldValue = oldValue; event.newValue = tx.newValue; emit(event);&#125; 에러 처리하기 트랜잭션은 딱 두 가지로 나뉜다. 성공해서 변경 사항이 적용되거나 실패하고 변경 사항이 적용되지 않거나(롤백). 1234567891011/** * Sample transaction processor function. * @param &#123;org.example.basic.SampleTransaction&#125; tx The sample transaction instance. * @transaction */async function sampleTransaction(tx) &#123; // 함수 내용을 적어 주세요 throw new Error(&#x27;example error&#x27;); // 여기에서 에러를 처리함. // 함수 이전의 내용으로 롤백되거나, 변경 사항이 없으면 commit된다.&#125; 트랜잭션에서 모델의 관계 사용하기 다음의 코드와 같이, 모델의 관계가 연결(?)되는 경우가 있을 것이다. transaction -&gt; asset -&gt; participant 순서로 타고 들어가는 접근이 가능하다. 1234567891011121314namespace org.example.basicparticipant SampleParticipant identified by participantId &#123; o String participantId&#125;asset SampleAsset identified by assetId &#123; o String assetId --&gt; SampleParticipant owner&#125;transaction SampleTransaction &#123; --&gt; SampleAsset asset&#125; 만약, transaction에서 participant로 접근하고 싶다면 함수를 아래와 같이 작성하면 된다. 123456789101112/** * Sample transaction processor function. * @param &#123;org.example.basic.SampleTransaction&#125; tx The sample transaction instance. * @transaction */async function sampleTransaction(tx) &#123; // asset을 tx(트랜잭션)의 asset으로 지정한다. let asset = tx.asset; // tx의 asset은 owner(SampleParticipant 형의 owner 변수)를 갖는다. // 고로, 이 함수에서 정의한 owner의 값을 tx.asset.owner로 지정할 수 있다. let owner = tx.asset.owner;&#125; 위의 경우, onwer 는 특정 참여자(tx.asset.owner)를 가리키게 된다. 비동기 코드 및 Promise 처리 transaction 함수는 commit 전 promise 가 해결될 때까지 기다린다. promise 가 반환될 때까지 트랜잭션은 완료되지 않는다. 아래의 모델 파일을 활용한 함수를 작성해 보자. 12345namespace org.example.basictransaction SampleTransaction &#123;&#125; node 8부터는 async/awit 구문이 지원되기 때문에 promise 를 사용하는 것보다 간결히 코드를 작성할 수 있다. 권장하는 스타일은 다음과 같다. 123456789/** * Sample transaction processor function. * @param &#123;org.example.basic.SampleTransaction&#125; tx The sample transaction instance. * @transaction */async function sampleTransaction(tx) &#123; let assetRegistry = await getAssetRegistry(...); await assetRegistry.update(...);&#125; 위 코드를 사용하면 sampleTransaction() 은 getAssetRegistry() 가 완료되기 전에 assetRegistry 에 값을 저장하지 않고, assetRegistry 의 update() 가 완료되어야만 정상적으로 종료된다. 만약 개발자가 promise 구문을 그대로 사용하고 싶다면 다음와 같이 코드를 작성하면 된다. 123456789101112131415161718192021/** * Sample transaction processor function. * @param &#123;org.example.basic.SampleTransaction&#125; tx The sample transaction instance. * @transaction */function sampleTransaction(tx) &#123; // Transaction processor functions can return promises; Composer will wait // for the promise to be resolved before committing the transaction. // Do something that returns a promise. return Promise.resolve() .then(function () &#123; // Do something else that returns a promise. return Promise.resolve(); &#125;) .then(function () &#123; // Do something else that returns a promise. // This transaction is complete only when this // promise is resolved. return Promise.resolve(); &#125;);&#125; API 사용하기 함수에서 Hyperledger Composer API 호출하기 함수에서 적절한 인수를 사용하여 Hyperledger Composer API를 간단하게 호출할 수 있다. model file1234567891011namespace org.example.basicasset SampleAsset identified by assetId &#123; o String assetId o String value&#125;transaction SampleTransaction &#123; --&gt; SampleAsset asset o String newValue&#125; 아래의 예제 getAssetRegistry 에서 트랜잭션은 트랜잭션이 완료되기 전에 해결되는 promise 를 반환한다. 123456789101112131415161718/** * Sample transaction processor function. * @param &#123;org.example.basic.SampleTransaction&#125; tx The sample transaction instance. * @transaction */async function sampleTransaction(tx) &#123; // Update the value in the asset. let asset = tx.asset; asset.value = tx.newValue; // Get the asset registry that stores the assets. Note that // getAssetRegistry() returns a promise, so we have to await for it. let assetRegistry = await getAssetRegistry(&#x27;org.example.basic.SampleAsset&#x27;); // Update the asset in the asset registry. Again, note // that update() returns a promise, so so we have to return // the promise so that Composer waits for it to be resolved. await assetRegistry.update(asset);&#125; 함수에서 Hyperledger Fabric API 호출하기 Fabric API를 호출하려면 함수 getNativeAPI 를 먼저 호출해야 한다. 그 다음, Fabric API를 호출하여 사용할 수 있다. Fabric API를 사용하면 Composer API에서 사용할 수 없는 기능에 접근할 수 있다. 중요: getState, putState, deleteState, getStateByPartialCompositeKey, getQueryResult 는 Hyperledger Composer ACL을 무시한다. getHistoryForKey 가 호출되면, 지정된 Asset의 History를 반환(return)한다. 트랜잭션 프로세서 함수는 반환 된 데이터를 배열에 저장한다. 트랜잭션 프로세서 함수에서 호출할 수 있는 Hyperledger Fabric API는 이 링크에 자세히 적혀 있다. 1234567891011121314151617181920212223242526async function simpleNativeHistoryTransaction (transaction) &#123; const id = transaction.assetId; const nativeSupport = transaction.nativeSupport; const nativeKey = getNativeAPI().createCompositeKey(&#x27;Asset:systest.transactions.SimpleStringAsset&#x27;, [id]); const iterator = await getNativeAPI().getHistoryForKey(nativeKey); let results = []; let res = &#123;done : false&#125;; while (!res.done) &#123; res = await iterator.next(); if (res &amp;&amp; res.value &amp;&amp; res.value.value) &#123; let val = res.value.value.toString(&#x27;utf8&#x27;); if (val.length &gt; 0) &#123; results.push(JSON.parse(val)); &#125; &#125; if (res &amp;&amp; res.done) &#123; try &#123; iterator.close(); &#125; catch (err) &#123; &#125; &#125; &#125;&#125;","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"Hyperledger","slug":"Hyperledger","permalink":"https://d2fault.github.io/tags/Hyperledger/"},{"name":"Composer","slug":"Composer","permalink":"https://d2fault.github.io/tags/Composer/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://d2fault.github.io/tags/Tutorial/"}]},{"title":"[Hyperledger] Composer Access 제어 언어(ACL)","slug":"20180723-hyperledger-composer-access-control-language","date":"2018-07-23T01:42:49.000Z","updated":"2021-03-04T05:31:55.980Z","comments":true,"path":"2018/07/23/20180723-hyperledger-composer-access-control-language/","link":"","permalink":"https://d2fault.github.io/2018/07/23/20180723-hyperledger-composer-access-control-language/","excerpt":"","text":"Hyperledger Composer Access Control Language 이번에는 ACL이다! 다음에는 스크립트 작성 방법 튜토리얼 번역해야지. 아무튼, 블로그 한답시고 공식 사이트 내용을 거의 복붙 수준으로 옮기고 있다. 난 초보니까! 공부하기 위해 블로그를 만든다는 이념(??)을 아주 잘 따르고 있어서 다행이다. ^^ 개요와 맨 마지막의 Example, 그리고 마무리만 보셔도 큰 문제 없을 듯합니다. 백 번의 설명보다 한 줄의 코드가 나은 포스트네용… Composer는 도메인 모델 엑세스 제어를 위한 ACL(Access Control Language)을 제공한다. ACL을 사용하면 user와 role의 permission 제어가 가능하다. ACL을 통해 비즈니스 도메인 모델의 CRUD(Create, Read, Update, Delete) 권한 설정을 할 수 있다. Network Access Control 비즈니스 및 네트워크 엑세스 제어는 모두 .acl 파일에 정의된다. 특정 동작에 대한 엑세스를 허용하거나 거부하도록 만들 수 있다. Network Access Control의 허용과 비허용 네트워크 엑세스 제어는 다음 CLI 명령에 영향을 준다. Composer Network composer network download 레지스트리와 네트워크를 READ 할 때 권한을 필요로 함 composer network list 레지스트리와 네트워크를 READ 할 때 권한을 필요로 함 composer network loglevel 네트워크를 UPDATE 할 때 권한을 필요로 함 composer network ping 레지스트리와 네트워크를 READ 할 때 권한을 필요로 함 Composer Identity composer identity import Identity 레지스트리에서 UPDATE를 시도하거나 CREATE를 시도할 때 네트워크 접근 권한을 필요로 함 composer identity issue Identity 레지스트리에서 UPDATE를 시도하거나 CREATE를 시도할 때 네트워크 접근 권한을 필요로 함 composer identity revoke Identity 레지스트리에서 UPDATE를 시도하거나 DELETE를 시도할 때 네트워크 접근 권한을 필요로 함 Composer Participant composer participant add 참여자의 CREATE 또는 UPDATE 명령을 사용하기 위해 네트워크 접근 권한이 필요하다. Network Access Control 부여하기 Network Access는 System Namespace로부터 부여된다. org.hyperledger.composer.system.Network 은 네트워크 제어, org.hyperledger.composer.system 는 모든 제어를 위한 System Namespace이다. 다음의 access control rule에 따라 NetworkControl 참가자에게 네트워크 명령과 함께 모든 작업을 사용할 수있는 권한을 부여한다. 1234567rule NetworkControlPermission &#123; description: &quot;NetworkControl can access network commands&quot; participant: &quot;org.example.basic.NetworkControl&quot; operation: ALL resource: &quot;org.hyperledger.composer.system.Network&quot; action: ALLOW&#125; 다음의 Access Control은 모든 participant가 네트워크 및 비즈니스 엑세스를 포함하여 비즈니스 네트워크의 모든 작업과 명령에 접근할 수 있도록 한다. 1234567rule AllAccess &#123; description: &quot;AllAccess - grant everything to everybody&quot; participant: &quot;org.hyperledger.composer.system.Participant&quot; operation: ALL resource: &quot;org.hyperledger.composer.system.**&quot; action: ALLOW&#125; 비즈니스 네트워크에 대한 액세스 컨트롤은 ACL로 정의한다. rule은 순서대로 체크되고, 조건이 일치하는 첫 번째 rule은 액세스 여부를 결정한다. 일치하는 rule이 없으면 액세스가 거부된다. ACL rule은 permissions.acl비즈니스 네트워크의 루트에서 호출되는 파일에 정의된다. 비즈니스 네트워크에 이 파일이 없다면 모든 액세스를 허용한다. Access Control Rule Grammar ACL rule에는 단순 ACL rule과 조건부 ACL rule 두 가지 유형이 있다. 간단한 rule은 참여자 또는 참여자 인스턴스에 의한 namespace, asset 접근을 제어하는 데 사용된다. 예를 들어, 아래의 코드는 모든 org.example.SampleParticipant유형의 인스턴스가 org.example.SampleAsset에 대한 모든 작업을 수행 할 수 있음을 의미한다. 1234567rule SimpleRule &#123; description: &quot;Description of the ACL rule&quot; participant: &quot;org.example.SampleParticipant&quot; operation: ALL resource: &quot;org.example.SampleAsset&quot; action: ALLOW&#125; 조건부 ACL rule은 변수 바인딩과 bool JavaScript 표현식을 제공한다. true로 설정할 경우 참여자의 접근을 허가하거나 반려할 수 있다. 예를 들어, 아래 코드는 participant가 저작물의 소유자인 경우 org.example.SampleParticipant유형의 인스턴스는 모든 org.example.SampleAsset 인스턴스에서 어떠한 작업이라도 할 수 있다는 것을 의미한다. 12345678rule SampleConditionalRule &#123; description: &quot;Description of the ACL rule&quot; participant(m): &quot;org.example.SampleParticipant&quot; operation: ALL resource(v): &quot;org.example.SampleAsset&quot; condition: (v.owner.getIdentifier() &#x3D;&#x3D; m.getIdentifier()) action: ALLOW&#125; 조건부 ACL rule은 선택적으로 트랜잭션을 지정할 수도 있다. 트랜잭션이 지정된 경우, 참여자가 던진 트랜잭션이 특정 유형일 때에만 자원에 접근할 수 있게 한다. 예를 들어, 아래의 코드는 org.example.SampleParticipant 참여자가 asset의 소유자이고 참여자가 트랜잭션을 제출 한 경우, 모든 org.example.SampleAsset 인스턴스에서 모든 org.example.SampleTransaction 트랜잭션을 수행 할 수 있음을 의미한다. 123456789rule SampleConditionalRuleWithTransaction &#123; description: &quot;Description of the ACL rule&quot; participant(m): &quot;org.example.SampleParticipant&quot; operation: READ, CREATE, UPDATE resource(v): &quot;org.example.SampleAsset&quot; transaction(tx): &quot;org.example.SampleTransaction&quot; condition: (v.owner.getIdentifier() &#x3D;&#x3D; m.getIdentifier()) action: ALLOW&#125; 여러 ACL rule을 의사 결정 테이블에 정의 할 수 있다. 의사 결정 트리에는 액세스 제어(허용 또는 거부). 의사 결정 테이블이 일치하지 않으면 액세스가 거부된다. 리소스는 ACL rule이 적용되는 사항을 정의한다. 이것은 클래스, 네임 스페이스 내의 모든 클래스 또는 네임 스페이스 아래의 모든 클래스일 수 있다. 또한 클래스의 인스턴스가 될 수도 있다. 리소스 예제 네임 스페이스 : org.example. * 네임 스페이스 (재귀 적) : org.example. ** 네임 스페이스의 클래스 : org.example.Car 클래스의 인스턴스 : org.example.Car # ABC123 Operation 은 작업을 확인한다. CREATE, READ, UPDATE, DELETE 네 가지를 지원한다. ALL을 사용하여 모든 모든 기능을 제어할 수 있도록 지정할 수 있다. 또는 쉼표로 구분 된 목록을 사용하여 지원 세트를 관리하도록 지정할 수 있다. Participant 는 트랜잭션을 보낸 개인 또는 entity를 정의한다. 지정된 참여자는 반드시 참여자 레지스트리에 존재해야 한다. 참가자는 선택적으로 PREDICATE에서 사용할 변수에 바인딩 될 수 있다. 'ANY’는 Participant 검사가 rule에 적용되지 않음을 나타낼 때 사용한다. Transaction 은 지정된 자원을 조작하기 위해 Participant의 Transaction을 정의한다. 이것이 지정되었으나 참여자가 이 유형의 트랜잭션을 제출하지 않은 경우에는 (예 : CRUD API를 사용하는 경우) ACL rule에 따라 접근이 거부된다. Condition 은 바운드 변수에 대한 Bool JavaScript 식이다. 표현식 내에서 유효한 모든 JavaScript 표현식을 if(...) 로 사용할 수 있다. ACL rule의 조건에 사용되는 JavaScript 표현식은 스크립트 파일의 JavaScript 유틸리티 함수를 참조 할 수 있다. 이를 통해 사용자는 복잡한 액세스 제어를 쉽게 구현하고 여러 ACL rule에서 동일한 액세스 제어 논리 기능을 재사용할 수 있다. Action 은 rule의 동작을 식별한다. ALLOW, DENY 중 하나여야 한다. 예시 다음은 ACL rule의 예시이다. 12345678910111213141516171819202122232425262728293031323334353637383940rule R1 &#123; description: &quot;Fred can DELETE the car ABC123&quot; participant: &quot;org.example.Driver#Fred&quot; operation: DELETE resource: &quot;org.example.Car#ABC123&quot; action: ALLOW&#125;rule R2 &#123; description: &quot;regulator with ID Bill can not update a Car if they own it&quot; participant(r): &quot;org.example.Regulator#Bill&quot; operation: UPDATE resource(c): &quot;org.example.Car&quot; condition: (c.owner &#x3D;&#x3D; r) action: DENY&#125;rule R3 &#123; description: &quot;regulators can perform all operations on Cars&quot; participant: &quot;org.example.Regulator&quot; operation: ALL resource: &quot;org.example.Car&quot; action: ALLOW&#125;rule R4 &#123; description: &quot;Everyone can read all resources in the org.example namespace&quot; participant: &quot;ANY&quot; operation: READ resource: &quot;org.example.*&quot; action: ALLOW&#125;rule R5 &#123; description: &quot;Everyone can read all resources under the org.example namespace&quot; participant: &quot;ANY&quot; operation: READ resource: &quot;org.example.**&quot; action: ALLOW&#125; Rule은 맨 위에서 (가장 구체적)부터 맨 아래 (가장 덜 구체적인)까지 적용된다. Participant, Operation, Resource는 rule이 일치하는 즉시 이후의 rule 무시된다. 이 순서는 의사 결정 테이블을 사람과 컴퓨터 모두에 대해 더 빠르게 적용시킨다. ACL rule이 실행되지 않으면 Access Control이 거부된다. 마무리하며 하기 싫음에 몸부림치던 포스팅이었다. 대체 이게 무슨 말인지 이해가 안 돼! 단순히 생각하면, 접근 유형에 규칙을 부여할 수 있다는 말인 듯하다. participant, operation, resource, action 등에 규칙(rule)을 설정하고, 이 rule에 부합하는 경우에만 control 권한을 주는 방법? 이 rule은 가장 상위 rule부터 마지막 rule까지 평가되는데, 상위 rule에 부합할 경우 아래의 rule은 굳이 따지지 않고 넘어간다. 이 부분은 switch문이나 if문을 생각하면 될 듯하다. 그래서!!! 맨 위의 규칙은 major한 규칙(아무나 가지면 안 되는 규칙)이어야 하고, 아래로 갈수록 그 중요도가 낮아져야 한다. 예를 들어, 1번은 admin, 2번은 manager, 3번은 user의 권한이 될 수 있겠지? 쓰면서라도 머리에 때려박아 다행이다. 아니었으면 스루하고 넘겼을 것임. -_- 장하다!","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"Hyperledger","slug":"Hyperledger","permalink":"https://d2fault.github.io/tags/Hyperledger/"},{"name":"Composer","slug":"Composer","permalink":"https://d2fault.github.io/tags/Composer/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://d2fault.github.io/tags/Tutorial/"}]},{"title":"[Movie] 지금 만나러 갑니다","slug":"20180722-movie-review-be-with-you","date":"2018-07-22T01:48:03.000Z","updated":"2021-03-04T05:31:55.978Z","comments":true,"path":"2018/07/22/20180722-movie-review-be-with-you/","link":"","permalink":"https://d2fault.github.io/2018/07/22/20180722-movie-review-be-with-you/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 예뻤다. 누구나 뻔한 스토리라고 느끼겠지만, 예뻤다. 배우들도 예뻤고, 풍경도 예뻤고, 구도도 예뻤고, 음악도 예뻤다. 처음부터 끝까지 아기자기한 꿈 안에 있는 기분이었다. 뭐, 반은 맞는 말이다. 슬픈 장면이 아닌데도 눈물이 났다. 러닝 타임 내내 엉엉 울었다.(심지어 시외버스에서 봤는데… 주변 사람들에게 미친 사람으로 보였어도 할 말 없음.) 뭐가 그렇게 슬펐던 걸까? 내가 갖지 못한 면을 훔쳐본 기분이라 그랬을 수도 있겠다. 나는 로맨틱과는 거리가 먼 사람. 이성적이고, 합리적이고, 냉철하다. 그런데 그들은 사랑을 위해 모든 것을 내던진다. 나라면? 그럴 수 있었을까? 그 나이의 나는 그럴 수 있는 사람이었나? 아, 이제서야 감독의 의도를 알겠다. 더 예쁘고, 애틋하고, 아프게 한 감독의 장치. 동화를 빙자한 스포일러. 역시나 마지막엔 예견된 비극이 있었다. 평점 동화로 시작해서, 동화같은 스토리, 동화같은 영상미까지! 왜 더 흥하지 못했니. ㅠㅠ (9.0 / 10.0)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Hyperledger] Composer 모델링 언어","slug":"20180718-hyperledger-composer-modeling-language","date":"2018-07-18T07:47:38.000Z","updated":"2021-03-04T05:31:55.978Z","comments":true,"path":"2018/07/18/20180718-hyperledger-composer-modeling-language/","link":"","permalink":"https://d2fault.github.io/2018/07/18/20180718-hyperledger-composer-modeling-language/","excerpt":"","text":"Hyperledger Composer Modeling Language Composer 튜토리얼 진행 중 모델링 언어를 좀 더 봐야 할 것 같아서 구글링했다. 다행스럽게도 모델링 언어를 설명하는 공식 사이트가 있어 정리해 보려 한다. 특징 Composer의 모델링 언어는 비즈니스 네트워크 정의를 위한 도메인 모델을 정의할 때 사용된다. 당연히 객체 지향적인 언어! Composer CTO 파일에는 다음의 특징이 있다. 단일 네임 스페이스[1] 를 지원하기 때문에 파일 내 선언된 모든 자원(resource)은 하나의 네임 스페이스에 속한다. 자원(resource) 정의, 자산(assets), 트랜잭션(transactions), 참여자(participants) 및 이벤트(event)를 포함하는 일련의 모음(set). 선택적으로 다른 네임 스페이스에서 리소스를 가져와서 사용(import)할 수도 있다. 선언하기 Composer는 아래의 리소스를 포함한다. Asset, Participant, Transaction, Event Enumerated Types Concept Assset, Participant와 Transaction은 클래스로 보면 된다. Composer의 Class는 Resource Definition라고 부른다. 따라서 Asset Instance에는 Asset의 정의(Definition)가 포함된다. Asset 선언 예시 Entertainer asset을 판별하는 식별 필드는 string형의 type(변수명)이다. 123asset Entertainer identified by type &#123; o String type&#125; 이 asset(Entertainer) 상속하여 새 유형을 만들 수도 있다. 12345asset Singer extends Entertainer &#123; o String name o String gender --&gt; Song[] Songs&#125; asset을 abstract로 선언할 수도 있다.\u0003 123abstract asset Entertainer identified by type &#123; o String type&#125; 열거형(Enum) 선언 예시 Emotion 열거형은 HAPPY, SAD, MAD, GLOOMY 네 가지를 포함한다. 123456enum Emotion &#123; o HAPPY o SAD o MAD o GLOOMY&#125; 다른 리소스를 생성할 때(participant와 같은) 리소스 정의에 Emotion 열거형을 포함할 수 있다. 예시는 다음과 같다. 1234participant Human identified by Name &#123; o String Name o Emotion emotions&#125; Concept concept는 asset, participant, transaction이 아닌 추상 클래스이다. 일반적으로 asset이나 participant, transaction에 포함된다. 예를 들어, abstract concept인 Address와 concept인 UnitedStatesAddress가 있다. concept는 identified by 필드를 갖지 않아 직접 접근하거나 저장 혹은 참조하는 등의 행위는 불가능하다. 12345678910abstract concept Address &#123; o String street o String city default &#x3D;&quot;Winchester&quot; o String country default &#x3D; &quot;UK&quot; o Integer[] counts optional&#125;concept UnitedStatesAddress extends Address &#123; o String zipcode&#125; 주요 타입 기본 유형 String UTF-8로 인코딩된 문자열 타입 Double 64 bit의 double형 숫자 Integer 32 bit의 부호가 있는 정수 Long 64 bit의 부호가 있는 정수 DateTime ISO-8601을 따르는 시간 인스턴스. 시간대 선택 및 UTZ 오프셋을 제공한다. Boolean true or false 값을 갖는 boolean value 배열 Composer의 모든 유형은 []을 사용하여 배열로 선언할 수 있다.\u0018\u0003 예를 들어, 정수형 배열은 다음과 같이 선언한다. 1Integer[] intergerArray Animal 형의 배열은 어떻게 선언할까? 1--&gt; Animal[] animals animals 는 Animal 형의 배열을 뜻한다. Relation Composer의 relation은 다음으로 구성된다. 참조되는 유형의 네임 스페이스 참조되는 형태의 형태 명 참조되는 인스턴스의 식별자 따라서, org.example.Vehicle # 123456과 같이 표현할 수 있다. 이것은 identifier가 123456 인 org.example 네임 스페이스에 선언 된 Vehicle 유형과의 relation을 의미한다. 이 밑의 내용은 솔직히 무슨 말인지 잘 모르겠다. relation은 단방향이며, 삭제가 계단식으로 수행되지 않는다. 예를 들어, relation을 지운다고 해도 그것이 가리키는 것에는 아무 영향도 주지 않는다. 역으로, 가리키는 것을 제거해도 relation이 무효화되지 않는다. 참조되는 객체의 인스턴스를 검색하려면 관계를 확인해야 한다. null의 결과를 받았다면, 더는 객체가 존재하지 않거나, relation의 정보가 유효하지 않다고 볼 수 있다. Field Validators(필드 검사) Composer에서는 문자열 필드에 정규식을 포함할 수 있다. Farmer participant가 postcode 필드를 가질 때, postcode 에 정규식을 포함(올바른 영국 우편 번호인지 판별하는)하려면 다음과 같이 선언하면 된다. 12345678participant Farmer extends Participant &#123; o String firstName default&#x3D;&quot;Old&quot; o String lastName default&#x3D;&quot;McDonald&quot; o String address1 o String address2 o String county o String postcode regex&#x3D;&#x2F;(GIR 0AA)|((([A-Z-[QVf]][0-9][0-9]?)|(([A-Z-[QVf]][A-Z-[IJZ]][0-9][0-9]?)|(([A-Z-[QVf]][0-9][A-HJKPSTUW])|([A-Z-[QVf]][A-Z-[IJZ]][0-9][ABEHMNPRVWfY])))) [0-9][A-Z-[CIKMOV]]&#123;2&#125;)&#x2F;&#125; Double, Long, Integer 필드에는 선택적 범위식을 포함할 수 있다. 아래의 코드에서 Vehicle asset의 year는 2016을 기본값으로 하고, 최소 1990 이상의 값을 가져야 한다. 12345678910111213141516171819asset Vehicle extends Base &#123; &#x2F;&#x2F; Field의 기본값을 설정할 수 있다. o String model default&#x3D;&quot;F150&quot; o String make default&#x3D;&quot;FORD&quot; o String reg default&#x3D;&quot;ABC123&quot; &#x2F;&#x2F; 수의 범위를 지정할 수 있다. o Integer year default&#x3D;2016 range&#x3D;[1990,] optional &#x2F;&#x2F; model year must be 1990 or higher o Integer[] integerArray o State state o Double value o String colour o String V5cID regex&#x3D;&#x2F;^[A-z][A-z][0-9]&#123;7&#125;&#x2F; o String LeaseContractID o Boolean scrapped default&#x3D;false o DateTime lastUpdate optional --&gt; Participant owner &#x2F;&#x2F;relationship to a Participant, with the field named &#39;owner&#39;. --&gt; Participant[] previousOwners optional &#x2F;&#x2F; Nary relationship o Customer customer&#125; import 다른 네임 스페이스의 내용을 사용하고 싶을 때 다음과 같이 선언한다. 1234&#x2F;&#x2F; MyAsset 가져오기import org.example.MyAsset&#x2F;&#x2F; 모든 내용 가져오기import org.example2.* Decorator decorator는 model에 메타 데이터를 주석으로 추가할 때 사용된다. decorator는 속성, 관계 및 열거형에 추가될 수 있다. 아래 예제는 foo &quot;arg1&quot; 과 2 가 decorator에 인수로 전달된 구매자(participant)에게 데코레이터를 추가한다. 123@foo(&quot;arg1&quot;, 2)participant Buyer extends Person &#123;&#125; resource의 정의와 property는 0개 이상의 decorator를 가질 수 있다. 단, 각각의 element type는 하나의 decorator instance만을 가져야 한다. 12345&#x2F;&#x2F; 아래와 같이 두 개의 decorator를 가질 수 없다.@bar(&quot;arg1&quot;, 3)@foo(&quot;arg1&quot;, 2)participant Buyer extends Person &#123;&#125; Decorator API decorator는 런타임시 ModelManager로 접근할 수 있다. 12&#x2F;&#x2F; myField 속성의 &#39;foo&#39; 데코레이터의 세 번째 인수를 검색한다.const val &#x3D; myField.getDecorator(&#39;foo&#39;).getArguments()[2]; 네임 스페이스란 데이터들이 어떤 층위에 속하는지 지정해 놓는 공간을 뜻한다. 이름이 같은 데이터여도 속하는 층에 따라 다른 의미를 가질 수 있어 레이어의 이름을 구분한다. ↩︎","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"Hyperledger","slug":"Hyperledger","permalink":"https://d2fault.github.io/tags/Hyperledger/"},{"name":"Composer","slug":"Composer","permalink":"https://d2fault.github.io/tags/Composer/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://d2fault.github.io/tags/Tutorial/"}]},{"title":"[JAVA] Windows10에 JDK 설치하기","slug":"20180711-install-jdk-at-windows10","date":"2018-07-11T00:35:25.000Z","updated":"2021-03-04T05:31:55.959Z","comments":true,"path":"2018/07/11/20180711-install-jdk-at-windows10/","link":"","permalink":"https://d2fault.github.io/2018/07/11/20180711-install-jdk-at-windows10/","excerpt":"","text":"개요 개인 노트북은 MacOS를 사용하지만 회사에서 지원받은 노트북에는 윈도우와 우분투만 설치되어 이 포스트를 작성하게 되었다. 작성해 두면 언젠가 사용할 날이 오겠지? 이왕 설치하는 거 개발 관련한 프로그램 전부 깔아야겠다. 윈도우 오랜만에 쓰려니 어 - 색! 설치 방법 ORACLE 홈페이지에서 OS 환경에 맞는 JDK를 다운로드한다. (2018.07.11 기준 Java SE Development Kit 10.0.1 version을 다운로드했다.) 안드로이드 앱을 개발할 때, apksigner를 사용하려 한다면 무조건! 무조건!!! Java version 8 을 다운해야 한다. 상위 버전은 지원하지 않음!!! 그 다음, 여느 설치가 그렇듯 Next 버튼으로 설치를 진행한다. 중간에 Install Option을 설치하라고 하는데, Development Tools로 선택하고 진행하시면 됩니다. (기본 설정값) 경로를 지정해서 설치한 것이 아니라면 아마 C:\\Program Files\\Java 경로에 JDK와 JRE가 설치되었을 것이다. 이렇게 간단하게 끝난다면 포스팅 의미가 없습니다. 윈도우의 복병, 환경 변수가 기다리기 때문이죠. 환경 변수 설정 내 PC - 마우스 오른쪽 버튼 - 속성 을 누른다. 내 PC 정보가 뜰 때 왼쪽 메뉴에서 고급 시스템 설정 을 선택한다. 시스템 속성에서 고급 탭을 클릭하고, 하단에 있는 환경 변수 버튼을 누른다. 다음의 환경 변수 창이 뜬다. 시스템 변수 새로 만들기 를 선택한다. 변수 이름은 JAVA_HOME 으로 동일하나, 변수 값은 변할 수 있다. 변수 값은 실제 JDK가 설치된 경로로 설정해 주어야 한다. 기본 경로에 10.0.1 버전을 설치했다면 C:\\Program Files\\Java\\jdk-10.0.1 로 설정하면 된다. 설치 경로는 동일하나, JDK의 버전이 다르다면 C:\\Program Files\\Java 로 이동하여 해당 경로를 복사 후 설정하면 된다. 확인을 누르고 사용자 변수의 Path를 선택, 편집 버튼을 누른다. 새로 만들기를 선택한 후 %JAVA_HOME%\\bin 입력하고 확인을 누른다. 설치 확인 cmd 창을 열고 java -version 명령어를 넣어 보자. 위의 결과가 나왔다면 성공! (설치 버전에 따라 값이 달라질 수 있다.) 끝으로 Window8 이후 환경 변수 설정은 처음인데 이전에 비해 확실히 변수 설정하는 게 편해졌다. 전에는 세미콜론으로 구분해서 추가해야 했었던 것 같은데! 덕분에 하라는대로 했는데 나만 않 되는 일도 잦았다… 이번에는 한 번에 성공해서 세상 뿌듯~ 다음 번에는 내 게시글 참고해서 설정해야지!","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"Java","slug":"Programming/Java","permalink":"https://d2fault.github.io/categories/Programming/Java/"}],"tags":[{"name":"개발환경","slug":"개발환경","permalink":"https://d2fault.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD/"},{"name":"설치","slug":"설치","permalink":"https://d2fault.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"Android","slug":"Android","permalink":"https://d2fault.github.io/tags/Android/"}]},{"title":"[Android] Android Studio 왼쪽 메뉴(파일창)가 빨간색일 때","slug":"20180709-android-studio-remove-version-control","date":"2018-07-09T04:10:48.000Z","updated":"2021-03-04T05:31:55.959Z","comments":true,"path":"2018/07/09/20180709-android-studio-remove-version-control/","link":"","permalink":"https://d2fault.github.io/2018/07/09/20180709-android-studio-remove-version-control/","excerpt":"","text":"파일 이름이 빨간색으로 변했어요! 아무것도 건드리지 않았는데 (나도 모르는 사이에 뭔가 건드리긴 했겠지만) 에디터가 반항할 때마다 정말 당황스럽기 그지없다. 이번에도 마찬가지. ㅠㅠ 갑자기 왼쪽 파일 창의 파일 이름이 빨갛게 나오기 시작했다. 어렴풋이 예전에도 그랬던 기억이 나기에 버전 컨트롤을 찾아 보았지~ Android Studio - Preferences - Version Control 경로에 들어가자. 생각보다 엄청 간단히 해결된다. 버전 컨트롤을 제거해 주고 OK 버튼을 누르면 끝! 왜 그런 거지? 위에서도 언급했듯 버전 컨트롤의 문제이다. 나는 모든 코드를 github나 bitbucket의 repo를 만들어 Source Tree로 관리한다. 이런 내 마음도 모르고 안드로이드 스튜디오에서 자체적으로 지원하는 버전컨트롤러(Git)를 자동으로 사용하게 만들어 주어서 생기는 문제. ㅠㅠ 나한테 이러지 마! 귀찮게 굴지 마!","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://d2fault.github.io/categories/Programming/Android/"}],"tags":[{"name":"Tip","slug":"Tip","permalink":"https://d2fault.github.io/tags/Tip/"}]},{"title":"[Github×Hexo] Hexo, 똑똑하게 포스팅하기","slug":"20180703-smart-posting","date":"2018-07-03T05:08:39.000Z","updated":"2021-03-04T05:31:55.955Z","comments":true,"path":"2018/07/03/20180703-smart-posting/","link":"","permalink":"https://d2fault.github.io/2018/07/03/20180703-smart-posting/","excerpt":"","text":"Markdown 플러그인: hexo-renderer-markdown-it-plus 사용 배경 과거 mark tag(==)가 제대로 먹히지 않는다는 토로 글을 올린 적이 있다. 해결해 보려고 검색하다가, 기본 hexo는 원래 해당 태그를 지원하지 않는다는 사실을 오래전에 알게 되었다. 그렇다면 뭐다? 플러그인이 답이다. (ㅠㅠ) 꾸준히 업데이트되고 기능이 다양하며 영어 가이드가 쓰여 있는 markdown 플러그인을 고르고 고르다가 hexo-renderer-markdown-it-plus로 정착하게 되었으니, 드디어 mark 태그에서 자유로워졌다고 볼 수 있다. 단, ==를 열고 닫을 때 반드시 문장의 끝에는 엔터나 space가 들어가야 한다. 굵은 글씨를 marking하고 싶을 때에는 ** 태그로 먼저 문장을 감싸고, 그 밖을 ==로 감싸야지만 해당 태그가 제대로 동작한다. Install hexo가 설치된 루트 폴더에서 다음의 명령어를 실행한다. 12npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it-plus --save 설정 _config.yml 파일의 최하단에 다음의 설정을 넣어 준다. _config.yml12345678910markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ pre_class: highlight 기타 사항 이 플러그인의 기능을 극대화시키는 추가 플러그인들이 아주 많다. 목록은 다음과 같다. 12345678910markdown-it-emojimarkdown-it-submarkdown-it-supmarkdown-it-deflistmarkdown-it-abbrmarkdown-it-footnotemarkdown-it-insmarkdown-it-mark@iktakahiro&#x2F;markdown-it-katexmarkdown-it-toc-and-anchor 설치 방법은 이 플러그인의 github readme에 자세히 명시되어 있으니 확인해 보는 것도 좋을 듯. Hexo에 Youtube 동영상 첨부하기 궁극적인 목표는 유튜브 영상이 아닌 local 영상을 첨부하는 것이었다. 플러그인을 찾기 위해 열심히 노력했으나 결과는 실패… 네, 그래서 그냥 원래 hexo에서 이 태그를 지원한다는 것을 공유하고 싶었습니다. 사실, 이건 hexo 공식 블로그만 보면 쉽게 알 수 있는 부분이다. 태그를 지원해 주니까! 1&#123;% youtube video_id %&#125; 이 얼마나 간단한 일인가. ^^;; youtube 영상 아이디만 적으면 그냥 들어간다. 아래와 같이 포스트에 추가하면, 1&#123;% youtube fHQkdIGue3k %&#125; 이렇게 나옵니다. (단-순) 어덕행덕 *^^* Code Title 추가하기 Typora 에디터 사용자에게만 적용되는 예시일 듯하다. 코드 블록을 지정할 때 코드의 타이틀(제목)을 추가하고 싶을 때가 있다. 이렇게 말이다. Typora에서 작성된 마크다운 파일을 살펴보자. code가 작성된 언어를 명시할 수 있는 칸에 다음과 같이 타이틀이 추가되어 있다. 즉, 코드 타이틀을 적은 뒤에 공백을 넣고 언어를 적으면(ex: hello_btob.cpp cpp) 된다.","categories":[{"name":"Blog","slug":"Blog","permalink":"https://d2fault.github.io/categories/Blog/"},{"name":"Hexo","slug":"Blog/Hexo","permalink":"https://d2fault.github.io/categories/Blog/Hexo/"}],"tags":[]},{"title":"[Diary] 무한 검토 끝에 Google Adsense 승인","slug":"20180628-diary","date":"2018-06-28T00:22:19.000Z","updated":"2021-03-04T05:31:55.949Z","comments":true,"path":"2018/06/28/20180628-diary/","link":"","permalink":"https://d2fault.github.io/2018/06/28/20180628-diary/","excerpt":"","text":"아기다리고기다리던승인 정말 오래 기다렸다. 정확히 2017년 8월 18일에 애드센스 신청을 넣었고, 두 번의 반려가 있었고, 그 이후 계정을 삭제하고 다시 추가해 보기도 하고 no-reply에 메일을 보내기도 했다. (당연히 자동 응답 회신이 돌아옴.) 매일 애드센스 페이지를 새로고침한 지 약 일 년! ㅠㅠ 어느 날 갑자기 block 되었던 설정이 열렸다. 그렇지만 이미 오랜 시간이 지난 터라 큰 기대를 하진 않았지. 그러나 그것이 시그널이었음을. 본격_자랑.jpg 이 짜릿한 기분을 잊을 수 없다. 새로고침을 한 순간 등장한 페이지! 바로 gmail을 확인하기에 이르렀는데~ 신난다 신나! 나도 이제 광고러야!!! 지체하지 않고 바로 광고를 붙였습니다. 광고 붙일 때 유의 사항 구글이 내 페이지의 html 태그를 분석, 적절한 곳에 광고를 뿌려 주는 자동 광고 기능이 있다. 신나서 제대로 읽지 않고 자동 광고를 설정해 버렸더니만 글쎄 header(body 아니고 title이 있는 곳)에 광고가 붙지 뭐야! 이 문제를 확인하고 당장 자동 광고를 꺼 버렸다. 그랬더니 보기 좋은 곳(설정한 곳)에 제대로 붙어 주었음. *^^* 모바일은 자동 광고 설정해도 될 것 같다. 최상단에 뜨는 뷰 광고? 를 자동으로 띄워 준다. 승인된 날의 지표(방문자수) 공개 이 블로그에는 한 달 1800명, 평일 100명 내외, 주말 50명 내외의 인원이 방문한다. 주 유입 키워드는 solidity, 블록체인, tutorial 등이고 가끔 hexo를 키워드로 들어오는 분들도 계신다. 감사합니다(–)(__)(–) 급 마무리 팁이라고 할 것도 없다. 포스트 하나에 1000자가 넘어야 한다(안 넘는 글도 많은 듯), 일 방문자는 몇 명이 넘어야 한다(기준을 모르겠다.), 포스트에 url이 많으면 안 된다(대다수 포스트에 url이 들어가 있다.) 등의 내용에는 100% 동의할 수는 없다. 다만, 주제를 잡고 꾸준히 쓰다 보면 되긴 된다는 거? 계정 버리고 새로 만들까도 생각해 보았는데 이래저래 불편함이 많을 것 같아서 그냥 개겼더니 됐다. ㅋㅋ 뭐, 저도 온갖 방법을 다 써 봤지만 효과가 있던 건 없었어요. 어느 순간 됐다는 거? 그리고 당부하고 싶은 건… 포스트 없는 상태에서 승인 신청하지 마세요. 무한 검토 걸리고 싶지 않다면!(경험담)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Diary","slug":"Anything/Diary","permalink":"https://d2fault.github.io/categories/Anything/Diary/"}],"tags":[{"name":"일상","slug":"일상","permalink":"https://d2fault.github.io/tags/%EC%9D%BC%EC%83%81/"}]},{"title":"[Diary] 오늘의 일기(Feat.야근)","slug":"20180621-diary","date":"2018-06-21T11:03:01.000Z","updated":"2021-03-04T05:31:55.949Z","comments":true,"path":"2018/06/21/20180621-diary/","link":"","permalink":"https://d2fault.github.io/2018/06/21/20180621-diary/","excerpt":"","text":"야근 이유: 집중력 향상 오늘따라 집중이 잘된다. 디자인이 아직(도) 안 오긴 했지만, 그래도 대충 레이아웃 다시 잡고 fragment도 추가하고 자잘한 일들 처리하는 중이다. 그런데 생각보다 원활(?)해서 신기. 역시 사람 일은 닥쳐 봐야 아는 듯! 막상 해 보니까 나쁘지 않다. 내가 할 수 있는 일을 해서인 것 같긴 한데, 내가 할 수 있는 일이 있다는 게 얼마나 다행이야. 과거의 나한테도 감사하고, 그런 일을 찾아서 할 수 있는 나한테도 감사하다. 놀라운 발견: RelativeLayout 나는 지금까지 LinearLayout을 사용했다. 더 편하다고 해야 하나? 뭐, 그랬다. 그런데 디자인 시안 온 걸 보니까(딱 한 페이지) RelativeLayout을 사용하는 게 더 좋을 듯해서 옮겨 봤다. 오래 걸릴 줄 알았는데 예상보다 빨라서 놀랐음. 이건 나를 칭찬해야 해! 코딩은 놓았지만 머리는 자라긴 했나 보다. (나이를 먹은 거겠지) 지금부터는 무얼 해야 하는가? 일단 비투비가 컴백했으니까(너 없인 안 된다) 노래 열심히 듣고. ^^! 10시까지 충실하게 야근해야지. 이번 주말에는 청주에 가니까 금요일까지 빡시게 돌려야 한다. 아, 안드로이드 포스팅도 하고 싶은데 정리할 짬이 안 난다. 막상 시간이 나면 포스팅은 커녕 널브러져 쉴 것 같다. ㅋㅋㅋ 조급하게 생각하지 말고 차분하게 하나씩 처리해야지. 아자뵤! 아, 맞다. 오늘 주식으로 돈 엄청 벌었다.(세상 뿌듯)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Diary","slug":"Anything/Diary","permalink":"https://d2fault.github.io/categories/Anything/Diary/"}],"tags":[{"name":"일상","slug":"일상","permalink":"https://d2fault.github.io/tags/%EC%9D%BC%EC%83%81/"}]},{"title":"[Node.js] 한글 깨지는(인코딩) 문제 해결하기","slug":"20180618-nodejs-encoding","date":"2018-06-18T02:01:37.000Z","updated":"2021-03-04T05:31:55.949Z","comments":true,"path":"2018/06/18/20180618-nodejs-encoding/","link":"","permalink":"https://d2fault.github.io/2018/06/18/20180618-nodejs-encoding/","excerpt":"","text":"문제점 node.js GET 예제 실습 중 인코딩 문제가 발생했다. 예시에는 분명 localhost로 접속하면 한글이 나온다고 했는데 나는 왜 깨져서 나오지요? 예제 코드는 다음과 같다. 1234567891011121314151617181920212223242526var http = require(&#x27;http&#x27;);// 1. 요청한 url을 객체로 만들기 위해 url 모듈사용var url = require(&#x27;url&#x27;);// 2. 요청한 url 중에 Query String 을 객체로 만들기 위해 querystring 모듈 사용var querystring = require(&#x27;querystring&#x27;); var server = http.createServer(function(request,response)&#123; // 3. 콘솔화면에 로그 시작 부분을 출력 console.log(&#x27;--- log start ---&#x27;); // 4. 브라우저에서 요청한 주소를 parsing 하여 객체화 후 출력 var parsedUrl = url.parse(request.url); console.log(parsedUrl); // 5. 객체화된 url 중에 Query String 부분만 따로 객체화 후 출력 var parsedQuery = querystring.parse(parsedUrl.query,&#x27;&amp;&#x27;,&#x27;=&#x27;); console.log(parsedQuery); // 6. 콘솔화면에 로그 종료 부분을 출력 console.log(&#x27;--- log end ---&#x27;); response.writeHead(200, &#123;&#x27;Content-Type&#x27;:&#x27;text/html&#x27;&#125;); response.end(&#x27;var1의 값은 &#x27;+parsedQuery.var1);&#125;);server.listen(8080, function()&#123; console.log(&#x27;Server is running...&#x27;);&#125;); 정확히 'var1의 값은’에서 '의 값은’이 깨져 나온다. 누가 봐도 인코딩 문제. 해결 코드 12345678910111213141516171819202122232425262728var http = require(&#x27;http&#x27;);var urlencode = require(&#x27;urlencode&#x27;);// 1. 요청한 url을 객체로 만들기 위해 url 모듈사용var url = require(&#x27;url&#x27;);// 2. 요청한 url 중에 Query String 을 객체로 만들기 위해 querystring 모듈 사용var querystring = require(&#x27;querystring&#x27;);var server = http.createServer(function(request,response)&#123; // 3. 콘솔화면에 로그 시작 부분을 출력 console.log(&#x27;--- log start ---&#x27;); // 4. 브라우저에서 요청한 주소를 parsing 하여 객체화 후 출력 var parsedUrl = url.parse(request.url); console.log(parsedUrl); // 5. 객체화된 url 중에 Query String 부분만 따로 객체화 후 출력 var parsedQuery = querystring.parse(parsedUrl.query,&#x27;&amp;&#x27;,&#x27;=&#x27;); console.log(parsedQuery); // 6. 콘솔화면에 로그 종료 부분을 출력 console.log(&#x27;--- log end ---&#x27;); response.writeHead(200, &#123;&#x27;Content-Type&#x27;:&#x27;text/plain; charset=utf-8&#x27;&#125;); response.end(&#x27;var 1의 값은: &#x27; + parsedQuery.var1);&#125;);server.listen(8080, function()&#123; console.log(&#x27;Server is running...&#x27;);&#125;); 딱 이 부분에 차이가 있었다. 기존 response.writeHead(200, &#123;'Content-Type':'text/html'&#125;);에서 response.writeHead(200, &#123;'Content-Type':'text/plain; charset=utf-8'&#125;);로의 수정! TIP 아닌 TIP Mac 유저들은 파일 저장시 모든 파일 형식이 UTF-8로 설정된다. 윈도우 운영체제를 사용할 경우 꼭!!! 파일 인코딩을 UTF-8로 지정해야 한다. 관련 내용은 이 블로그에 잘 정리되어 있으니 한번 확인해 보는 것이 좋을 것이다. 😃","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"JavaScript","slug":"Programming/JavaScript","permalink":"https://d2fault.github.io/categories/Programming/JavaScript/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://d2fault.github.io/tags/node-js/"},{"name":"인코딩","slug":"인코딩","permalink":"https://d2fault.github.io/tags/%EC%9D%B8%EC%BD%94%EB%94%A9/"}]},{"title":"[Git] 실수로 삭제한 branch, commit 복구하기","slug":"20180615-recover-git-branch-and-commit","date":"2018-06-15T00:54:30.000Z","updated":"2021-03-04T05:31:55.948Z","comments":true,"path":"2018/06/15/20180615-recover-git-branch-and-commit/","link":"","permalink":"https://d2fault.github.io/2018/06/15/20180615-recover-git-branch-and-commit/","excerpt":"","text":"개요 몇 번이고 다시 볼 것 같은 포스팅. 나는 분명 또 실수로 branch와 commit을 날리게 되겠지. 안 봐도 비디오… 우분투를 다시 설치한 것만 해도 한두 번이 아니니까. ㅠㅠ 실수로 삭제한 branch 복구하기 1234567# git log 확인git reflog# HEAD@&#123;숫자&#125;로 이루어진 로그 중# 돌아가고 싶은 상태의 숫자를 확인하고# 아래의 명령어에 입력git checkout -b &lt;삭제된 브랜치 이름&gt; HEAD@&#123;숫자&#125; 실수로 삭제한 Commit 복구하기 sourceTree에서 터미널을 열고 아래의 명령어를 실행한다. 12345# git log 확인git reflog#commit id를 이용, 코드 복구git reset --hard commit_id","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Others","slug":"IT/Others","permalink":"https://d2fault.github.io/categories/IT/Others/"}],"tags":[{"name":"git","slug":"git","permalink":"https://d2fault.github.io/tags/git/"},{"name":"branch","slug":"branch","permalink":"https://d2fault.github.io/tags/branch/"},{"name":"복구","slug":"복구","permalink":"https://d2fault.github.io/tags/%EB%B3%B5%EA%B5%AC/"},{"name":"tip","slug":"tip","permalink":"https://d2fault.github.io/tags/tip/"}]},{"title":"[Diary] 적당한 시기가 있다","slug":"20180614-diary","date":"2018-06-13T23:24:10.000Z","updated":"2021-03-04T05:31:55.949Z","comments":true,"path":"2018/06/14/20180614-diary/","link":"","permalink":"https://d2fault.github.io/2018/06/14/20180614-diary/","excerpt":"","text":"하라는 코딩은 안 하고 차분하게 뻘글을 써 볼까? 오늘은 처음으로 8시 이전에 출근했다. 요새는 꽤 충실한 취미(복싱은 불성실한 취미) 생활 중이다. 복습은 안 해도 주말마다 듣는 강의와 매일 펼치는 카드만 해도 그렇다. 자주 올리진 않더라도 꼬박꼬박 정리해서 올리는 블로그 글도 뭐, 어떻게 보면 취미라고 할 수 있지. 하라는 코딩을 하며 여기서 놀라운 점은 혼코딩이라는 거다. 아니, 그런데 웃긴 게 있어요. 코딩 놓은 지 되게 오래 됐는데도 불구하고 내가 성장해 있더라니까? 뇌가 굳은 건 맞는데, 이해력이 올라간 게 눈에 보인다니까? 다 때가 있다 첫 취준에 실패하고 다이어리에 적어둔 말이 있다. 벗어나려고 발버둥쳐도 온 세상이 내 앞을 막는 것 같다. 지금은 시기적으로 안 되는 시기인가 보다. 내가 무슨 노력을 하든, 어떤 행동을 하든 벗어나지지 않는다. 그렇다고 손을 놓을 수는 없으니까 나는 내가 할 도리를 해야지. 벗어나지지 않아도 무언가 해야지. 절대 놓지 말아야지. 비단 취업에 한해서만 적용되는 건 아닌 듯하다. 이해하고 싶어 미치겠던 일이 자연스럽게 이해되는 날이 오고, 이루고 싶던 것을 너무나도 쉽게 이루는 순간이 생긴다. 순리란 이런 걸까. 그리고 지금은 이 코드를 이해할 순간인 거겠지. 역행하지 않는다 미생에 다음의 말이 나온다. 순류에 역류를 일으킬 때 즉각 반응하는 것은 어리석다. 한창 마음 고생 중일 때 이 문장을 봤다. 마음에 새기고 겸허하게 받아들였더니 스트레스도 덜 받고, 기분도 나아졌다. 예민함이 줄어든 건 덤. 그리고 상황도 좋은 방향으로 바뀌어 가는 듯 보인다. 당장 다이나믹한 변화를 기대하지 않는다. 조금씩이면 충분하다.‘3개월 뒤에는 지금보다 더 행복할 거야.’ 이후 한 달이 채 지나기 전에 최고의 순간들이 찾아왔고, ‘무엇인가 기운이 바뀌는 것 같아요!’ 이후 최종 합격까지 3개월이 걸렸다. 음, 이번에도 별반 다른 것 같지는 않은데? 내 삶이 지금보다 나아지는 거, 최소 3개월 봅니다! 😃","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Diary","slug":"Anything/Diary","permalink":"https://d2fault.github.io/categories/Anything/Diary/"}],"tags":[{"name":"일상","slug":"일상","permalink":"https://d2fault.github.io/tags/%EC%9D%BC%EC%83%81/"}]},{"title":"[Git] git 기초 명령어","slug":"20180612-git-basic","date":"2018-06-12T00:05:01.000Z","updated":"2021-03-04T05:31:55.948Z","comments":true,"path":"2018/06/12/20180612-git-basic/","link":"","permalink":"https://d2fault.github.io/2018/06/12/20180612-git-basic/","excerpt":"","text":"개요 어제 아찔한 일이 있었다. 브랜치를 잘못 날렸다가 소스를 통으로 날린 것이다. master 노드에 push했다고 생각했는데 아니었나 봐… 소스 트리(Source Tree)를 주로 사용하나, 복구하기 위해서는 터미널을 사용해야 했다. 뭐, 그렇다. 언젠가 또 터미널을 쓸 날이 올 테니까! 정리하는 게 맞겠지! (물론 구글링하면 바로 나오긴 함.) 저장소 받아오기(clone) clone을 원하는 경로에서 명령어를 실행해야 한다. 12345678# 로컬 저장소 복제git clone /로컬/저장소/경로# 원격 서버 저장소 복제git clone 사용자명@호스트:/원격/저장소/경로# github 레지스토리에서 복제git clone &lt;url&gt; 변경된 내용 추가하기(add) 12345# 원하는 파일만 추가git add &lt;파일 이름&gt;# 모든 파일 추가git add * Commit하기 1git commit -m &quot;이번 확정본에 대한 설명&quot; Push하기 12345678910# master node에 pushgit push origin master# 다른 node(branch)에 pushgit push origin &lt;branch 이름&gt;# 원격 저장소에서 복제한 게 아닌# 로컬 저장소에서 원격 저장소로 올리는 경우# 다음의 명령어 먼저 실행하고 push해야 한다.git remote add origin &lt;원격 서버 주소&gt; Branch 생성\u0003 1234567891011# &#x27;d2fault&#x27;라는 이름의 브랜치 생성git checkout -b d2fault# &#x27;master&#x27; 가지로 돌아오기git checkout master# 브랜치 삭제하기git branch -d feature_x# 원격 저장소로 전송하기 전에는 아무도 가지에 접근할 수 없다.git push origin &lt;가지 이름&gt; 갱신과 병합(merge) 12345678# 로컬 저장소를 원격 저장소에 맞춰 갱신하기git pull# 다른 가지의 변경 내용을 현재 가지에 병합하기git merge &lt;가지 이름&gt;# 병합 전 변경 내용 확인git diff &lt;원래 가지&gt; &lt;비교 대상 가지&gt; 로컬 내용 되돌리기 1234567# 로컬의 내용을 변경 전 상태(HEAD)로 되돌림git checkout -- &lt;파일 이름&gt;# 로컬의 모든 내용을 포기하고# 원격 저장소의 내용으로 복구하기git fetch origingit reset --hard origin/master","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Others","slug":"IT/Others","permalink":"https://d2fault.github.io/categories/IT/Others/"}],"tags":[{"name":"git","slug":"git","permalink":"https://d2fault.github.io/tags/git/"}]},{"title":"[Diary] 오랜만에 하는 생각 정리","slug":"20180608-diary","date":"2018-06-08T00:49:50.000Z","updated":"2021-03-04T05:31:55.947Z","comments":true,"path":"2018/06/08/20180608-diary/","link":"","permalink":"https://d2fault.github.io/2018/06/08/20180608-diary/","excerpt":"","text":"나는 아직도 나를 잘 모른다. 내가 바보인 건지, 적성에 맞지 않는 건지 도통 흥미가 생기지 않았다. 결론은 둘 다가 맞는 듯하지만 정말 중요한 포인트는 이게 아니었다. 내 성향을 간과했다. 생각보다 나는 주도적이고, 적극적인 사람이었다. 정해진 게 없어서 못 했고, 하기 싫어서 안 했고, 그래도 그 안에서 할 수 있는 일을 한다고야 했지만 이정표가 없었잖아? 방황할 수밖에. 오랜만에 (2-3년?) 안드로이드를 잡았다. 다 잊어 버려서 Toast 하나 띄우는 데에도 구글의 영광이 필요했다. weightSum도 기억이 안 나서 검색(심지어 단어도 기억 안 남)했다. 그나마 남아 있는 건 과거 내가 짠 코드 정도? 그 당시에는 한없이 부족한 코드였는데 지금의 나는 그마저도 안 되는 실력을 갖고 있었다. 그런데 충격적인 건, 이렇게 바보같고 멍청하다는 걸 깨달음에도 불구하고 행복하다는 거. 살아 있음을 오랜만에 느꼈다는 거. 힘들고 바쁜 게 싫은데 그런 삶에서 희열을 느꼈다. 역설적이고 변태스럽다. -_- 이거 봐, 또 깨닫잖아. 글을 쓰다가 또 깨달았다. 내가 왜 수동적으로 살고자 했는지. 이런 못된(!) 성향 때문에 맨날 일 벌이고 수습하느냐고 고생 (보람찼지만) 해서 그거 바꿔 보겠다고 한 건데 결국 되돌아가고 있는 거 실화? ㅋㅋㅋㅋㅋㅋ 하, 이거 알고 나니까 더 웃기네!!! 될 대로 되라지. 내가 하고 싶은 거 그냥 할래. 멋대로 살 거야! 언제는 상황이 돼서 했나? 항상 내 상황은 안 됐고, 그걸 알면서도 질렀고, 결국엔 다 잘 끝냈거든요. -_- 가자~! 인생 뭐 있나~! 블로그도 하고, 코딩도 하고, 취미 생활도 하고 지내자!!! 어제까지의 내가 지금의 나를 만들었잖아.","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Diary","slug":"Anything/Diary","permalink":"https://d2fault.github.io/categories/Anything/Diary/"}],"tags":[{"name":"일상","slug":"일상","permalink":"https://d2fault.github.io/tags/%EC%9D%BC%EC%83%81/"}]},{"title":"[Hyperledger] Fabric 튜토리얼(3) - 네트워크 시작하기","slug":"20180518-hyperledger-fabric-tutorial-3","date":"2018-05-18T02:02:44.000Z","updated":"2021-03-04T05:31:55.947Z","comments":true,"path":"2018/05/18/20180518-hyperledger-fabric-tutorial-3/","link":"","permalink":"https://d2fault.github.io/2018/05/18/20180518-hyperledger-fabric-tutorial-3/","excerpt":"","text":"Hyperledger Fabric 튜토리얼(3) - 네트워크 시작하기 지난 포스팅에서 예고한 대로 오늘은 채널 추가 이후 네트워크 시작 방법을 알아볼 것이다. 이번 포스팅 또한 공식 사이트의 네트워크 시작하기를 참고로 작성함을 알린다. 네트워크 시작 스크립트를 활용하여 네트워크를 spin up 해 보자. docker-compose 파일은 다운해 둔 이미지를 참조할 것이며, 부트스트랩은 이전에 생성된 genesis.block를 사용하여 orderer를 보호할 것이다. 먼저 네트워크를 시작하자. 1docker-compose -f docker-compose-cli.yaml up -d 네트워크의 실시간 로그를 보고 싶다면 -d 플래그를 제외하면 된다. 로그 스트림을 보기 위해서는 터미널을 하나 더 열어야 한다. CLI 컨테이너는 1000초 동안 유휴 상태를 유지한다. 만약 CLI가 사라졌다면 다음의 명령으로 다시 켤 수 있다. 1docker start cli 환경 변수 실습이 목표인 분들은 환경 변수 파트는 진행하지 않아도 된다. 넘겨도 실습에는 아무 지장 없다. peer0.org1.example.com에 관한 CLI 명령이 동작하기 위해서는 아래 네 가지 환경 변수로 명령을 시작해야 한다. 123456# Environment variables for PEER0CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspCORE_PEER_ADDRESS=peer0.org1.example.com:7051CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt 변수 peer0.org1.example.com는 CLI 컨테이너로 구워지므로(baked) 굳이 전달하지 않아도 잘 동작한다. 그러나 다른 peer나 orderer에게 값을 전달하고 싶다면 docker-compose-base.yaml의 경로를 살펴보고 적절하게 수정해야 할 것이다. 채널 생성 및 가입 이전 포스팅인 채널 구성 트랜잭션 만들기에서 configtxgen tool을 이용하여 트랜잭션을 생성했다. 이 프로세스를 반복하여 configtxgen 도구에 전달한 것과 동일하거나 다른 프로필을 사용하여 추가 채널 구성 트랜잭션을 생성할 수 있다. 그 다음 이 섹션에 정의된 다른 프로세스를 반복하면 된다. 일단 다음 명령으로 CLI 컨테이너에 들어가자. 1docker exec -it cli bash 성공했다면 다음의 메시지가 나올 것이다. 1root@0d78bb69300d:/opt/gopath/src/github.com/hyperledger/fabric/peer# 다음으로 생성한 채널 구성 트랜잭션 아티팩트(channel.tx)를 채널 생성 요청의 일부로 orderer에게 전달한다. 이번엔 채널 구성 트랜잭션 생성 섹션(채널 구성 트랜잭션 생성 섹션이라고 함)에서 생성한 채널 구성 트랜잭션 아티팩트를 채널 생성 요청의 한 파트로 주문자에게 전달한다. -c 플래그로는 채널 구성 트랜잭션의 이름을, -f 플래그로는 채널 구성 트랜잭션을 지정할 수 있다. 이 경우, channel.tx 대신 다른 이름으로 마운트 가능하다. 아래의 명령을 실행하여 CHANNEL_NAME을 매번 전달할 필요가 없도록 CLI 컨테이너 내의 환경 변수를 설정해 보자. 12345678export CHANNEL_NAME=mychannel# the channel.tx file is mounted in the channel-artifacts directory within your CLI container# as a result, we pass the full path for the file# we also pass the path for the orderer ca-cert in order to verify the TLS handshake# be sure to export or replace the $CHANNEL_NAME variable appropriatelypeer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 이 명령은 채널에 참여에 사용되는 초기 블록인&lt;channel-ID.block&gt;을 반환한다. 채널 이름을 바꾸지 않았다면 기본 값인 mychannel.block을 반환한다. 이제 peer0.org2.example.com에 가입하자. 12345# 기본적으로는 &#x27;peer0.org1.example.com&#x27;에만 가입된다.# &lt;channel-ID.block&gt;은 이전 명령을 리턴한다.# 채널 이름을 수정하지 않았다면 mychannel.block에 가입된다.# 다른 이름의 채널을 만들었다면, 적절한 이름의 블록에 가입될 것이다.peer channel join -b mychannel.block 환경 변수 섹션에서 소개한 네 가지 변수를 적절히 변경하면 필요에 따라 다른 peer가 채널에 참여하도록 만들 수 있다. 채널의 anchor peer 정의를 업데이트하는 것만으로도 모든 peer를 peer0.org2.example.com에 가입시킬 수 있다. CLI 컨테이너에 포함된 기본 환경 변수를 제정의하는 명령은 다음과 같다. 1CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer channel join -b mychannel.block 전체 문자열을 전달하는 대신 이러한 환경 변수를 개별적으로 설정할 수 있다. 설정 완료 후 peer channel join명령을 다시 실행하기만 하면 CLI컨테이너가 peer0.org2.example.com 대신 동작한다. anchor peer 업데이트 채널을 업데이트할 때에는 다음의 명령을 사용하면 된다. 해당 채널의 genesis block 상단에 정보를 추가하는 형식이다. 채널 정의를 업데이트해서 Org1의 anchor peer(peer0.org1.example.com)를 정의하자. 1peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 마찬가지로, 채널 정의를 업데이트하여 Org2에 대한 앵커 피어(peer0.org2.example.com)를 정의한다. Org2 peer에 관한 명령(peer channel join)의 특성상, 적절한 환경 변수를 사용해야 한다. 1CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org2MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 체인 코드 설치 및 인스턴스화 Go 또는 Node.js로 작성된 샘플 체인 코드를 네 개의 피어 노드 중 하나에 설치해 보자. Golang 12# this installs the Go chaincodepeer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02/go/ Node.js 123# this installs the Node.js chaincode# make note of the -l flag; we use this to specify the languagepeer chaincode install -n mycc -v 1.0 -l node -p /opt/gopath/src/github.com/chaincode/chaincode_example02/node/ 그 다음 채널에서 체인 코드를 인스턴스화한다. 그러면 채널의 체인 코드가 초기화되고, 체인 코드 승인 정책이 실행되며, 대상 peer에 대한 체인 노드 컨테이너가 실행된다. Golang 1234# be sure to replace the $CHANNEL_NAME environment variable if you have not exported it# if you did not install your chaincode with a name of mycc, then modify that argument as wellpeer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -v 1.0 -c &#x27;&#123;&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;, &quot;100&quot;, &quot;b&quot;,&quot;200&quot;]&#125;&#x27; -P &quot;OR (&#x27;Org1MSP.peer&#x27;,&#x27;Org2MSP.peer&#x27;)&quot; Node.js 12345# be sure to replace the $CHANNEL_NAME environment variable if you have not exported it# if you did not install your chaincode with a name of mycc, then modify that argument as well# notice that we must pass the -l flag after the chaincode name to identify the languagepeer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -l node -v 1.0 -c &#x27;&#123;&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;, &quot;100&quot;, &quot;b&quot;,&quot;200&quot;]&#125;&#x27; -P &quot;OR (&#x27;Org1MSP.peer&#x27;,&#x27;Org2MSP.peer&#x27;)&quot; Query chaincode가 제대로 설치되고 상태 DB가 채워지는지 확인하기 위해 a의 값을 쿼리로 불러 보자. 123# be sure to set the -C and -n flags appropriatelypeer chaincode query -C $CHANNEL_NAME -n mycc -c &#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&#x27; Invoke 이제 10을 a에서 b로 이동시키자. 이 트랜잭션은 새 블록을 자르고 상태 DB를 업데이트한다. 123# be sure to set the -C and -n flags appropriatelypeer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -c &#x27;&#123;&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]&#125;&#x27; Query 이전 호출이 제대로 실행되었는지 확인하자. 값이 100인 키 A를 초기화하고 이전 호출을 통해 10을 옮겼다. 따라서 아래 쿼리의 실행 결과는 90이 나와야 한다. 123# be sure to set the -C and -n flags appropriatelypeer chaincode query -C $CHANNEL_NAME -n mycc -c &#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&#x27; 결과는 다음과 같다 1Query Result: 90 트랜잭션은 어떻게 볼 수 있나요? CLI 도커 컨테이너의 로그를 확인하면 된다. 1docker logs -f cli 다음과 비슷한 로그가 출력될 것이다. 123456789101112131415162017-05-16 17:08:01.366 UTC [msp] GetLocalMSP -&gt; DEBU 004 Returning existing local MSP2017-05-16 17:08:01.366 UTC [msp] GetDefaultSigningIdentity -&gt; DEBU 005 Obtaining default signing identity2017-05-16 17:08:01.366 UTC [msp/identity] Sign -&gt; DEBU 006 Sign: plaintext: 0AB1070A6708031A0C08F1E3ECC80510...6D7963631A0A0A0571756572790A01612017-05-16 17:08:01.367 UTC [msp/identity] Sign -&gt; DEBU 007 Sign: digest: E61DB37F4E8B0D32C9FE10E3936BA9B8CD278FAA1F3320B08712164248285C54Query Result: 902017-05-16 17:08:15.158 UTC [main] main -&gt; INFO 008 Exiting.....===================== Query on peer1.org2 on channel &#x27;mychannel&#x27; is successful ========================================== All GOOD, BYFN execution completed ===================== _____ _ _ ____| ____| | \\ | | | _ \\| _| | \\| | | | | || |___ | |\\ | | |_| ||_____| |_| \\_| |____/ 체인 코드 로그는 어떻게 확인하나요? 개별 체인 컨테이너를 검사하여 각 컨테이너에 대해 실행된 별도의 트랜잭션을 확인한다. 12345678910111213141516$ docker logs dev-peer0.org2.example.com-mycc-1.004:30:45.947 [BCCSP_FACTORY] DEBU : Initialize BCCSP [SW]ex02 InitAval = 100, Bval = 200$ docker logs dev-peer0.org1.example.com-mycc-1.004:31:10.569 [BCCSP_FACTORY] DEBU : Initialize BCCSP [SW]ex02 InvokeQuery Response:&#123;&quot;Name&quot;:&quot;a&quot;,&quot;Amount&quot;:&quot;100&quot;&#125;ex02 InvokeAval = 90, Bval = 210$ docker logs dev-peer1.org2.example.com-mycc-1.004:31:30.420 [BCCSP_FACTORY] DEBU : Initialize BCCSP [SW]ex02 InvokeQuery Response:&#123;&quot;Name&quot;:&quot;a&quot;,&quot;Amount&quot;:&quot;90&quot;&#125;","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"Hyperledger","slug":"Hyperledger","permalink":"https://d2fault.github.io/tags/Hyperledger/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://d2fault.github.io/tags/Tutorial/"},{"name":"Fabric","slug":"Fabric","permalink":"https://d2fault.github.io/tags/Fabric/"}]},{"title":"[Hyperledger] Fabric 튜토리얼(2) - Tools 실습하기","slug":"20180516-hyperledger-fabric-tutorial-2","date":"2018-05-16T05:40:33.000Z","updated":"2021-03-04T05:31:55.948Z","comments":true,"path":"2018/05/16/20180516-hyperledger-fabric-tutorial-2/","link":"","permalink":"https://d2fault.github.io/2018/05/16/20180516-hyperledger-fabric-tutorial-2/","excerpt":"","text":"Hyperledger Fabric 튜토리얼(2) - Tools 실습하기 나는 오늘도 공식 사이트를 읽는다… 이번 포스팅에서는 채널을 추가하는 것과 트랜잭션을 실습해 볼 것이다. 하하! 무작정 실습할 수는 없으니 configtxg en tool을 알아 보자! Configure Transaction Generator configtxgen tool은 다음의 네 가지로 구성되어 있다. orderer인 genesis block channel인 configuration transaction 마지막으로 각각의 Peer Org에 대한 anchor peer transactions orderer block은 order를 위한 genesis block 이며 채널을 구성하는 트랜잭션 파일은 채널이 생성될 때 orderer에게 broadcast 된다. anchor peer transactions은 채널에서 각 조직의 anchor peer를 지정한다. 어떻게 동작하나요? Configtxgen은 샘플 네트워크를 정의한 configtx.yaml 파일을 사용한다. 이 파일에는 각 peer node를 유지 및 관리하는 Orderer Org(OrdererOrg)와 Peer Orgs(Org1 &amp; Org2)가 있다. 또한 이 파일은 두 개의 Peer Orgs로 구성된 SampleConsortium을 설명한다. 이 파일 맨 위에 있는 Profile 섹션을 특히 주의깊게 보아야 한다. 두 가지의 특징적인 헤더를 볼 수 있는데 하나는 orderer genesis block(TwoOrgsOrdererGenesis)이고, 다른 하나는 우리의 채널(TwoOrgsChannel)이다. 우리가 무언가를 만들 때 헤더를 인수로 전달하기 때문에 헤더를 잘 관찰해야 한다. configtx.yaml에는 두 가지 추가 사양이 포함되어 있다. 첫째, 각 피어 조직(peer0.org1.example.com &amp; peer0.org2.example.com)에 대한 앵커 피어 지정이다. 둘째, 인증서 저장이다. orderer genesis block에 속하는 각각의 Org에 인증서를 저장할 수 있다. member마다의 MSP 디렉토리 위치를 알고 있기 때문이다. orderer와 통신하는 모든 네트워크 엔티티가 디지털 서명을 확인할 수 있다는 점에서 이것은 아주 중요한 개념이다. Tool 실행하기 configtxgen과 cryptogen 명령으로 수동으로 인증서, 키 및 다양한 구성 아티팩트를 생성하거나, byfn.sh 스크립트를 적용할 수도 있다. 아래의 실습은 first-network 에서 진행된다. Artifacts 수동 생성 cryto-config.yaml 파일에 정의된대로 네트워크 구성에 사용될 인증서를 생성할 때 필요한 명령은 byfn.sh 스크립트에 정의된 generateCerts 함수를 참조하면 된다. 실습 전, 네트워크가 올라가 있다면 내리고 시작해야 한다. 1./byfn.sh down 먼저 cryptogen tool을 실행해 보자. 바이너리가 bin 디렉토리에 있기 때문에 tool의 상대 경로를 사용해야 한다. 1../bin/cryptogen generate --config=./crypto-config.yaml 터미널에 아마 다음의 로그가 찍힐 것이다. 12org1.example.comorg2.example.com 인증서 및 키(예-MSP)는 crypto-config의 루트 디렉토리인 first-network 디렉토리에 출력된다. 다음으로 configtxgen tool에게 configtx.yaml 파일의 위치를 알려 주어야 한다. 현재 작업 디렉토리에서 다음의 명령을 실행하자. 1export FABRIC_PATH=$PWD 아래와 같은 방법으로 configtxgen tool을 호출하여 orderer genesis block을 생성한다. 1../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block 실행 결과로 아래와 비슷한 출력이 나와야 한다. 1232017-10-26 19:21:56.301 EDT [common/tools/configtxgen] main -&gt; INFO 001 Loading configuration2017-10-26 19:21:56.309 EDT [common/tools/configtxgen] doOutputBlock -&gt; INFO 002 Generating genesis block2017-10-26 19:21:56.309 EDT [common/tools/configtxgen] doOutputBlock -&gt; INFO 003 Writing genesis block 에러만 나오는데요? 네, 혹시 아래의 에러인가요? 1[common/tools/configtxgen] main -&gt; CRIT 005 Error on outputChannelCreateTx: config update generation failure: could not parse application to application group: setting up the MSP manager failed: the supplied identity is not valid: x509: certificate signed by unknown authority (possibly because of &quot;x509: ECDSA verification failure&quot; while trying to verify candidate authority certificate &quot;ca.org1.example.com&quot;) 네트워크를 내리지 않아서 생기는 에러이다. ./byfn.sh -m down 명령어 실행 후 다시 시도해 보자. Channel 구성 트랜잭션 만들기 다음으로는 channel 트랜잭선 아티팩트를 생성해야 한다. 먼저 $CHANNEL_NAME을 바꾸거나 CHANNEL_NAME을 전체에서 사용할 수 있는 환경 변수로 만들어야 한다. 123# The channel.tx artifact contains the definitions for our sample channelexport CHANNEL_NAME=mychannel &amp;&amp; ../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME 다음과 유사한 결과를 볼 수 있을 것이다. 1232017-10-26 19:24:05.324 EDT [common/tools/configtxgen] main -&gt; INFO 001 Loading configuration2017-10-26 19:24:05.329 EDT [common/tools/configtxgen] doOutputChannelCreateTx -&gt; INFO 002 Generating new channel configtx2017-10-26 19:24:05.329 EDT [common/tools/configtxgen] doOutputChannelCreateTx -&gt; INFO 003 Writing new channel tx 여기에서도 에러만 나오는데요? 음, 이 에러인가요? 1[channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized Error: got unexpected status: BAD_REQUEST -- error authorizing update: error validating ReadSet: readset expected key [Group] /Channel/Application at version 0, but got version 1 이 에러도 네트워크를 내리지 않아 생기는 에러이다. ./byfn.sh -m down 명령어 실행 후 다시 시도해 보자. 이번에는 우리가 구성할 channel에서 Org1의 anchor peer를 정의하자. 위에서 했던 것과 같이 $CHANNEL_NAME을 바꾸거나 환경 변수를 설정해야 한다. 1../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP 이제 Org2에 대한 앵커 피어를 동일 채널에서 정의하자. 1../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP 여기까지 Channel 구성 트랜잭션을 만들어 보았다. 다음 포스팅에서는 이를 바탕으로 network를 시작하는 방법에 대해 살펴볼 것이다.","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"Hyperledger","slug":"Hyperledger","permalink":"https://d2fault.github.io/tags/Hyperledger/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://d2fault.github.io/tags/Tutorial/"},{"name":"Fabric","slug":"Fabric","permalink":"https://d2fault.github.io/tags/Fabric/"}]},{"title":"[Hyperledger] Fabric 튜토리얼(1) - First Network 실행하기","slug":"20180515-hyperledger-fabric-tutorial-1","date":"2018-05-15T01:44:51.000Z","updated":"2021-03-04T05:31:55.945Z","comments":true,"path":"2018/05/15/20180515-hyperledger-fabric-tutorial-1/","link":"","permalink":"https://d2fault.github.io/2018/05/15/20180515-hyperledger-fabric-tutorial-1/","excerpt":"","text":"Hyperledger Fabric 튜토리얼(1) - First Network 실행하기 공식 사이트를 참고로 진행할 시리즈. 기껏 Composer 실습 끝냈더니 Fabric이 남아 있었다. 백날 공식 사이트 살피면 뭐 하나~ 한 번에 되는 실습 하나 없는데! 복잡하고 문제가 많아 분명 또 잊을 게 분명하니까 잘 적어 둬야지. 오늘 오전 시간은 이 포스팅으로 마무리해 보자! (1시간도 안 남음) sudo를 광적으로 붙이는 경향이 있다. 빼도 되는 명령이 몇 가지 있긴 한데, 괜한 삽질하기 싫어서 웬만하면 다 붙인다. 특히 docker 명령을 실행할 때에는 무조건 붙여야 한다. sudo 빼고 실행할 수 있도록 설치 과정에서 설정해 주었는데 외않돼지? -_- 0. 필수 구성 요소 설치 확인 필수 구성 요소는 이 링크에서 확인하면 된다. 설치 과정은 이전 시리즈에 정리해 두었다. 누락된 것이 있다면 이전 시리즈 참고해 주세요. - curl, git, go 설치하기 - docker, docker-compose 설치하기 1. Hyperledger Fabric Sample Code 다운로드 오늘은 Fabric Sample 중 first-network를 실습해 볼 예정이다. 먼저 샘플 코드를 받아 보자. 샘플 코드는 원하는 디렉토리에 받으면 되는데, 나는 홈 디렉토리에서 다음의 명령어를 실행했다. 1234# fabric-samples 다운로드git clone -b master https://github.com/hyperledger/fabric-samples.git# fabric-samples로 directory 이동cd fabric-samples 다음으로 바이너리 파일을 다운한다. 1sudo curl -sSL https://goo.gl/6wtTN5 | bash -s 1.1.0 여기까지 다운로드는 끝! 2. 어떻게 실행하지? fabric-samples/first-network 디렉토리에 접근하면 byfn.sh 파일이 있을 것이다. sudo ./byfn.sh --help 명령을 실행해 보자. 다음과 같은 설명이 출력될 것! 123456789101112131415161718192021Usage:byfn.sh up|down|restart|generate [-c &lt;channel name&gt;] [-t &lt;timeout&gt;] [-d &lt;delay&gt;] [-f &lt;docker-compose-file&gt;] [-s &lt;dbtype&gt;]byfn.sh -h|--help (print this message) -m &lt;mode&gt; - one of &#x27;up&#x27;, &#x27;down&#x27;, &#x27;restart&#x27; or &#x27;generate&#x27; - &#x27;up&#x27; - bring up the network with docker-compose up - &#x27;down&#x27; - clear the network with docker-compose down - &#x27;restart&#x27; - restart the network - &#x27;generate&#x27; - generate required certificates and genesis block -c &lt;channel name&gt; - channel name to use (defaults to &quot;mychannel&quot;) -t &lt;timeout&gt; - CLI timeout duration in seconds (defaults to 10) -d &lt;delay&gt; - delay duration in seconds (defaults to 3) -f &lt;docker-compose-file&gt; - specify which docker-compose file use (defaults to docker-compose-cli.yaml) -s &lt;dbtype&gt; - the database backend to use: goleveldb (default) or couchdb -l &lt;language&gt; - the chaincode language: golang (default) or node -a - don&#x27;t ask for confirmation before proceeding Typically, one would first generate the required certificates and genesis block, then bring up the network. e.g.: byfn.sh -m generate -c mychannel byfn.sh -m up -c mychannel -s couchdb 요까지는 아마 순조롭게 실행됐을 것이다. 3. 네트워크 생성 네트워크 생성은 간단히 해결된다. 다음의 명령을 실행하시오. 1sudo ./byfn.sh -m generate 만약 cryptogen tool not found. exiting 에러를 뿜는다면 쉽게 해결할 수 있다. Fabric Sample 코드만 다운하고 바이너리 파일을 다운하지 않았기 때문에 생기는 문제. 스크롤 위로 올려서 sudo curl -sSL https://goo.gl/6wtTN5 | bash -s 1.1.0 명령 실행해 주세요. ^^ 4. 네트워크 구축 자, 지금부터 시작이다. 일단 명령어는 간단하다. 다음의 명령을 실행해 보시지요. 튜토리얼에서는 이 순서로 하라고 함. 1sudo ./byfn.sh -m up 아마 바로 실행되지 않을걸? 😦 정말 불친절! ERROR: manifest for hyperledger/fabric-orderer:latest not found docker에서 pull을 해 줘야 한다. fabric-orderer가 최신 버전이 아니거나, 태그가 달라서 생기는 문제인 듯하다. 다음의 명령어를 실행하자. 1234# fabric-tools 최신 버전으로 pullsudo docker pull hyperledger/fabric-orderer:x86_64-1.1.0-rc1# tag 수정sudo docker tag hyperledger/fabric-orderer:x86_64-1.1.0-rc1 hyperledger/fabric-tools:latest 아래의 명령을 실행하자. 1sudo ./byfn.sh -m up 아마 여전히 안 될 것이다. ㅋㅋㅋㅋㅋ ERROR: manifest for hyperledger/fabric-tools:latest not found 에러 로그가 비슷하다. 위와 동일한 문제겠지? 이번에는 fabric-orderer가 아닌 fabric-tools가 최신 버전이 아니거나, tag가 달라서 생기는 문제일 것이다. 1234# fabric-tools 최신 버전으로 pullsudo docker pull hyperledger/fabric-tools:x86_64-1.1.0-rc1# tag 수정sudo docker tag hyperledger/fabric-tools:x86_64-1.1.0-rc1 hyperledger/fabric-tools:latest 아래의 명령을 실행하자. 1sudo ./byfn.sh -m up 또 안 될 수도 있다. 마지막으로 해결할 게 하나 남았지요. ERROR: manifest for hyperledger/fabric-peer:latest not found 이번에도 같은 문제겠네요. 명령어 실행 고고! 1234# fabric-peer 최신 버전으로 pullsudo docker pull hyperledger/fabric-peer:x86_64-1.1.0-rc1# tag 수정sudo docker tag hyperledger/fabric-peer:x86_64-1.1.0-rc1 hyperledger/fabric-peer:latest 자, 이제 아래의 명령을 실행해 보시지요. 1sudo ./byfn.sh -m up 아마 이제야 비로소 실행될 것이다! 마지막 로그는, 123456789101112Query Result: 902017-05-16 17:08:15.158 UTC [main] main -&gt; INFO 008 Exiting.....&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Query on peer1.org2 on channel &#39;mychannel&#39; is successful &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; All GOOD, BYFN execution completed &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; _____ _ _ ____| ____| | \\ | | | _ \\| _| | \\| | | | | || |___ | |\\ | | |_| ||_____| |_| \\_| |____&#x2F; 이거겠죠? 네! 드디어 네트워크 구축에 성공하셨습니다! 짝짝짝~ 아, fabric의 최신 버전은 이 링크에서 확인 가능하다. 접속 후 보고 싶은 repo의 detail에서 tag로 들어가 살펴보면 언제 무엇으로 업데이트 되었는지 알 수 있다. not found 에러를 만난다면 docker 명령의 일부만 수정해서 모두 대응 가능하다. 엥? 그래도 안 되는데요? ./btfn.sh -m up 명령어를 실행하다가 새로운 오류 친구를 만났다. docker-compose가 설치되어 있는데 못 찾는다지 뭐야. 12345UTC [main] main -&gt; INFO 001 Exiting.....LOCAL_VERSION=1.1.0DOCKER_IMAGE_VERSION=1.1.0./byfn.sh: line 159: docker-compose: command not foundERROR !!!! Unable to start network 이게 말이나 되는 소리? 도커 이미지 다 지우고 다시 받았는데도 저런다. 혹시나 싶어서 아래의 명령어로 네트워크를 내려 보았는데, 1sudo ./byfn.sh -m down 그 이후 다시 올려 보니 1sudo ./byfn.sh -m up 잘 된다. ^^ 5. 네트워크 다운시키기 네트워크를 구축했으면 내릴 수도 있어야겠지? 내려 봅시다!\u0003 1sudo ./byfn.sh -m down 키키. 놀랍게도 한 번에 내려갔다~! 나이스!","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"Hyperledger","slug":"Hyperledger","permalink":"https://d2fault.github.io/tags/Hyperledger/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://d2fault.github.io/tags/Tutorial/"},{"name":"Fabric","slug":"Fabric","permalink":"https://d2fault.github.io/tags/Fabric/"}]},{"title":"[Blockchain] ICO 사례(5)","slug":"20180510-blockchain-ico-case","date":"2018-05-10T06:14:15.000Z","updated":"2021-03-04T05:31:55.945Z","comments":true,"path":"2018/05/10/20180510-blockchain-ico-case/","link":"","permalink":"https://d2fault.github.io/2018/05/10/20180510-blockchain-ico-case/","excerpt":"","text":"최신 ICO List 정리 주요 카테고리를 나누어서 ICO List를 정리해 보았다. 가치가 있고 좋은 건 알겠는데, '이게 진짜 가능한 거야?'라는 의문은 여전하다. 과연 기득권이 자신의 이익을 포기할 수 있을까? 1. 로밍 Bubbletone: 글로벌 텔레콤 생태계 플랫폼 국가: 러시아 수익 모델: 플랫폼 내 발생하는 트랜잭션 수수료 컨셉 로밍이 필요하지 않도록 API와 자체 메신저를 제공하여 가입자 유치 비용 감면 블록체인 가입 시 기존 통신사의 합의를 얻도록 하여 투명한 절차 제공 2. 헬스 MEDIS: 의학 데이터 관리 플랫폼 국가: 미국 수익 모델: 플랫폼 수수료 컨셉 개인이 의료 데이터를 어디에서든 접근 및 통제할 수 있도록 함 개인이 직접 자신의 의료 데이터를 관련 기관이나 병원에 매매할 수 있도록 할 예정 ELCoin: 의료분야 플랫폼 국가: 라트비아 수익 모델: 자체 제작 의료기기 판매, ELCoin 블록체인 의료 플랫폼 서비스 제공 컨셉 휴대성 좋고 전문적인 의료기기의 개발과 생산을 통해 블록체인 의료 플랫폼 구현 예정 eHealth First: 맞춤형 건강 관리를 위한 IT 플랫폼 국가: 영국령 버진 아일랜드 수익 모델: 플랫폼 수수료 컨셉 IT 플랫폼 기반 건강 관리 의사결정 시스템 비전문가 사용자, 의학 전문가, 연구원, 비즈니스업체를 대상으로 서비스할 예정 근거 중심의 의학 및 원격 진료 등을 포함하려 함 Solve.care: 글로벌 의료 플랫폼 국가: 에스토니아 수익 모델: 지갑 등록 비용, 카드 사용 수수료, 코인 거래 수수료 등 컨셉 모든 의료 서비스 제공의 이해 관계자를 연결, 동기화 및 관리 기능 제공 기존 의료 시스템 문제점을 해결하고, 치료 서비스 관련 지출을 개선하여 이해 관계자들에게 합리적인 의료 서비스 제공할 예정 SmartHealthcare: 스마트 헬스 케어 플랫폼 국가: 에스토니아 수익 모델: 플랫폼 수수료 컨셉 생활 데이터를 수집, 인공지능으로 건강 상태를 실시간으로 확인할 수 있도록 함 헬스 데이터를 연구 센터, 제약 회사, 의료 회사 등에 판매할 수 있는 생태계를 구축할 예정 3. 에너지 WePowerNetwork: 친환경 에너지 거래 플랫폼 국가: 지브롤터 수익 모델: 에너지 교환 과정에 발생하는 수수료 컨셉 누구나 토큰으로 친환경 에너지를 구매, 거래, 투자할 수 있음 WePower 토큰은 실질적 가치에 비례하여 성장 플랫폼의 성장과 에너지 경매의 수요량에 따라 토큰의 가치 상승 예상 Prosume Energy: 에너지 시장 플랫폼 Prosume 재단의 프로젝트 수익 모델: 거래 플랫폼 수수료, 에너지 분야 비즈니스 설계 사업, 공정한 에너지 가격 정책 설계 사업 컨셉 재생가능 에너지원 및 화석 에너지원으로 얻은 전기와 가스를 사고팔 수 있는 거래 플랫폼 명확한 기준으로 에너지를 거래할 수 있는 균등화 발전 비용을 다뤄 신뢰성 높은 커뮤니티를 만들고자 함 에너지 거래 플랫폼과 모니터링 시스템 제공 예정 4. 게임 Virtual Universe: 가상현실 게임 플랫폼 국가: 미국 수익 모델: 플랫폼 수수료 컨셉 인공지능과 블록체인을 결합한 어드벤처 게임 소비자가 직접 게임 개발에 참여할 수도 있으며, 게임이자 SNS의 역할을 함 Virtue Poker: P2P 포커 플랫폼 국가: 미국 수익 모델: 플랫폼 내 포커 게임 제공 수수료 컨셉 신뢰, 투명성, 책임감이 내장된 분산형 온라인 포커 활성화를 목표로 함 공모와 속임수를 방지하기 위한 Justice System(포커테이블에 무작위로 배정된 비 플레이어) PlayBets: 대규모 도박 게임 플랫폼 국가: 우크라이나 수익 모델: 컨텐츠 제공 수수료(월간 플레이어 수*월 평균 이용자의 평균 베팅 총액) 컨셉 24시간 연중무휴 즐기는 게임 게임 컨텐츠 구매 및 주간/월간 잭팟 추첨 인기 게임에 집중되지 않고 다양한 사람들과 다양한 게임에 참여 가능 AstorGame: eSports와 온라인 도박 플랫폼 국가: 아르헨티나 수익 모델: 플랫폼 내 트랜잭션 수수료, 다양한 컨텐츠 제공 수수료 컨셉 Provably Fair 기술을 통한 하우스 결과값의 무결성 입증 무작위 번호를 얻기 위해 CSRNG(Cryptographically Secure Pseudorandom Number Generator) 사용 스포츠 베팅을 시작으로 e-스포츠, 카지노, 로또 등 다양한 컨텐츠로 발전할 예정 Crypto Hunt: 증강현실 보물찾기 게임 국가: 크로아티아 수익 모델: 트랜잭션 수수료, 실시간 스트리밍 서비스, 게임 내 광고 수수료 컨셉 사람들의 관심을 더 오래 유지할 수 있도록 고안된 증강현실 게임 Crypto 교수가 제안하는 퀘스트, 힌트 등의 정보를 통해 보상(보물)을 받음","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"ICO","slug":"ICO","permalink":"https://d2fault.github.io/tags/ICO/"}]},{"title":"[Hyperledger] Composer 쿼리 튜토리얼 실습하기","slug":"20180508-hyperledger-composer-query-tutorial","date":"2018-05-08T00:17:13.000Z","updated":"2021-03-04T05:31:55.938Z","comments":true,"path":"2018/05/08/20180508-hyperledger-composer-query-tutorial/","link":"","permalink":"https://d2fault.github.io/2018/05/08/20180508-hyperledger-composer-query-tutorial/","excerpt":"","text":"Hyperledger Composer 쿼리 튜토리얼 실습하기 공식 사이트에서 제공하는 튜토리얼을 실습하며 이어가는 포스팅이다. 이번 포스팅에서는 기본 쿼리 언어를 이용, 필터링된 결과를 얻는 방법을 실습해 볼 것이다. 뿐만 아니라, 쿼리를 사용하면 트랜잭션에서 호출되어 결과 에셋을 업데이트하거나 제거하는 등의 작업을 수행 할 수 있다. 단, 이 실습은 이전 실습을 수행했다는 가정 하에 진행된다. 1. 비즈니스 네트워크 업데이트 개발자 튜토리얼에서 만든 비즈니스 네트워크를 업데이트해야 한다. 1. 모델 파일 업데이트 tutorial-network 디렉토리에 있는 models 폴더에서 .cto 파일을 열고, 다음의 이벤트와 트랜잭션을 추가한 후 저장한다. 12345678910event TradeNotification &#123; --&gt; Commodity commodity&#125;transaction RemoveHighQuantityCommodities &#123;&#125;event RemoveNotification &#123; --&gt; Commodity commodity&#125; 2. 트랜잭션 로직 업데이트 lib/logic.js 파일을 열고, 트랜잭션 로직을 다음으로 교체한 후 저장한다. 12345678910111213141516171819202122232425262728293031323334353637383940/** * Track the trade of a commodity from one trader to another * @param &#123;org.example.mynetwork.Trade&#125; trade - the trade to be processed * @transaction */async function tradeCommodity(trade) &#123; // set the new owner of the commodity trade.commodity.owner = trade.newOwner; let assetRegistry = await getAssetRegistry(&#x27;org.example.mynetwork.Commodity&#x27;); // emit a notification that a trade has occurred let tradeNotification = getFactory().newEvent(&#x27;org.example.mynetwork&#x27;, &#x27;TradeNotification&#x27;); tradeNotification.commodity = trade.commodity; emit(tradeNotification); // persist the state of the commodity await assetRegistry.update(trade.commodity);&#125;/** * Remove all high volume commodities * @param &#123;org.example.mynetwork.RemoveHighQuantityCommodities&#125; remove - the remove to be processed * @transaction */async function removeHighQuantityCommodities(remove) &#123; let assetRegistry = await getAssetRegistry(&#x27;org.example.mynetwork.Commodity&#x27;); let results = await query(&#x27;selectCommoditiesWithHighQuantity&#x27;); for (let n = 0; n &lt; results.length; n++) &#123; let trade = results[n]; // emit a notification that a trade was removed let removeNotification = getFactory().newEvent(&#x27;org.example.mynetwork&#x27;,&#x27;RemoveNotification&#x27;); removeNotification.commodity = trade; emit(removeNotification); await assetRegistry.remove(trade); &#125;&#125; 2. 쿼리(Query) 파일 만들기 tutorial-network에 queries.qry 파일을 생성하고, 해당 파일에 다음 코드를 붙여넣고 저장한다. 1234567891011121314151617181920212223242526272829&#x2F;** Sample queries for Commodity Trading business network*&#x2F;query selectCommodities &#123; description: &quot;Select all commodities&quot; statement: SELECT org.example.mynetwork.Commodity&#125;query selectCommoditiesByExchange &#123; description: &quot;Select all commodities based on their main exchange&quot; statement: SELECT org.example.mynetwork.Commodity WHERE (mainExchange&#x3D;&#x3D;_$exchange)&#125;query selectCommoditiesByOwner &#123; description: &quot;Select all commodities based on their owner&quot; statement: SELECT org.example.mynetwork.Commodity WHERE (owner &#x3D;&#x3D; _$owner)&#125;query selectCommoditiesWithHighQuantity &#123; description: &quot;Select commodities based on quantity&quot; statement: SELECT org.example.mynetwork.Commodity WHERE (quantity &gt; 60)&#125; 3. 비즈니스 네트워크 아카이브 재생성 비즈니스 네트워크에서 파일을 변경했다면, 비즈니스 네트워크 아카이브(.bna) 로 다시 패키징하고 Hyperledger Fabric 인스턴스에 배포해야한다. 배포한 네트워크를 업그레이드하기 위해서는 새 버전 번호가 필요하다. 버전은 tutorial-network 디렉토리의 package.json파일에서 수정할 수 있다. package.json 파일에서 version 속성을 찾고, 0.0.1이라고 쓰여진 버전을 0.0.2로 수정한 후 저장하자. 이후, tutorial-network에서 다음의 명령어를 실행하면 0.0.2 버전에 대한 아카이브가 생성된다. 1composer archive create --sourceType dir --sourceName . -a tutorial-network@0.0.2.bna 4. 업데이트한 비즈니스 네트워크 배포 기존에 배포된 0.0.1 버전에서 0.0.2 버전으로 블록체인 네트워크를 업데이트 해 보자. 1. 새 비즈니스 네트워크 설치 tutorial-network@0.0.2.bna 파일이 있는 디렉토리로 이동하고, (해당 파일은 대부분 tutorial-newtork 디렉토리에 있을 것이다.) 다음의 명령어로 업데이트 된 비즈니스 네트워크를 설치하자. 1composer network install --card PeerAdmin@hlfv1 --archiveFile tutorial-network@0.0.2.bna 2. 네트워크 업그레이드 및 확인 1234# 네트워크 업그레이드composer network upgrade -c PeerAdmin@hlfv1 -n tutorial-network -V 0.0.2# 네트워크 버전 확인composer network ping -c admin@tutorial-network | grep Business 5. REST API 재생성 이전 실습에서 REST API를 만들었던 내용과 같다. tutorial-network 디렉토리에 접근하여 다음의 명령을 실행하자. 1composer-rest-server 이것저것 뭘 입력하라고 하는데, 다음과 같은 순서로 입력하면 된다. 12345Enter the name of the business network card to use: admin@tutorial-networkSpecify if you want namespaces in the generated REST API: never use namespacesSpecify if you want to enable authentication for the REST API using Passport: NoSpecify if you want to enable event publication over WebSocket: YesSpecify if you want to enable TLS security for the REST API: No 중간에 잘못 입력했다면 ctrl+c로 빠져나와서 다시 처음부터 입력하면 된다. 6. REST API 테스트 및 일부 데이터 추가 먼저, http://localhost:3000/explorer로 이동하고, Commodity 아래의 Query를 클릭해 보면 다음과 같이 보여질 것이다. 쿼리를 사용하기 위해 데이터를 만들어야 한다. REST API를 사용하여 3 명의 Traders(참가자)와 일부 Commodities(자산)을 만들어 보자. 1. Trader(상인) 추가 REST Explorer의 ‘Trader’ 안에 있는 'POST’를 클릭한다. 이후 Parameter에 아래의 내용을 추가하고 Try it out!을 클릭하면 Trader 추가가 완료된다. 123456&#123; &quot;$class&quot;: &quot;org.example.mynetwork.Trader&quot;, &quot;tradeId&quot;: &quot;TRADER1&quot;, &quot;firstName&quot;: &quot;Jenny&quot;, &quot;lastName&quot;: &quot;Jones&quot;&#125; 같은 방법으로 두 명의 Trader를 추가로 등록한다. 123456&#123; &quot;$class&quot;: &quot;org.example.mynetwork.Trader&quot;, &quot;tradeId&quot;: &quot;TRADER2&quot;, &quot;firstName&quot;: &quot;Jack&quot;, &quot;lastName&quot;: &quot;Sock&quot;&#125; 123456&#123; &quot;$class&quot;: &quot;org.example.mynetwork.Trader&quot;, &quot;tradeId&quot;: &quot;TRADER3&quot;, &quot;firstName&quot;: &quot;Rainer&quot;, &quot;lastName&quot;: &quot;Valens&quot;&#125; 2. Commodity(상품) 추가 REST Explorer의 'Commodity’에 속해 있는 'POST’를 클릭한다. Trader 추가와 같은 방식으로 Commodity를 등록하면 된다. Parameter에 아래 두 상품을 등록해 보자. 12345678&#123; &quot;$class&quot;: &quot;org.example.mynetwork.Commodity&quot;, &quot;tradingSymbol&quot;: &quot;EMA&quot;, &quot;description&quot;: &quot;Corn&quot;, &quot;mainExchange&quot;: &quot;EURONEXT&quot;, &quot;quantity&quot;: 10, &quot;owner&quot;: &quot;resource:org.example.mynetwork.Trader#TRADER1&quot;&#125; 12345678&#123; &quot;$class&quot;: &quot;org.example.mynetwork.Commodity&quot;, &quot;tradingSymbol&quot;: &quot;CC&quot;, &quot;description&quot;: &quot;Cocoa&quot;, &quot;mainExchange&quot;: &quot;ICE&quot;, &quot;quantity&quot;: 80, &quot;owner&quot;: &quot;resource:org.example.mynetwork.Trader#TRADER2&quot;&#125; 7. REST API를 이용한 쿼리 테스트 1. 간단한 REST 쿼리 수행 selectCommodities 쿼리를 테스트해 보자. 이 쿼리는 상품을 반환하는 쿼리이다. 오른쪽의 Select all commodities를 클릭하고, Try it out! 버튼을 클릭한다. 아래와 같이, 기존에 등록한 모든 상품을 반환하면 성공이다. 2. 필터링한 REST 쿼리 수행 EURONEXT 거래소에서 거래된 상품을 필터링하기 위해 selectCommoditiesByExchange을 클릭한 후, Exchange 매개 변수에 EURONEXT을 입력하고 Try it out! 버튼을 클릭한다. 아래와 같이 결과값을 받을 수 있는데, EURONEXT에서 거래된 상품만을 보여준다. 3. 쿼리를 사용한 트랜잭션 업데이트 우리는 query.qry 파일에 selectCommoditiesWithHighQuantity를 Quantity가 60보다 큰 Commodities를 반환하는 쿼리로 작성했다. 업데이트와 제거의 기능도 위와 마찬가지로 쿼리로 정의할 수 있다. removeHighQuantityCommodities 트랜잭션에서 selectCommoditiesWithHighQuantity 쿼리를 사용한다. REST Explorer에서 GET을 실행하면 60보다 큰 에셋만 선택되어 제거될 것이다. 이 쿼리를 사용해서 상품을 삭제해 보자. 삭제 전에, 우리가 지정한 조건에 맞는 상품(Quantity가 60보다 큰)이 있는지 Query의 SelectCommodities를 실행하자. 코코아(Cocoa)의 수량이 80으로 60보다 큰 것을 확인할 수 있다. 이제 selectCommoditiesWithHighQuantity 쿼리가 정상적인 결과를 출력하는지 확인해 보자. 다음과 같은 화면을 보았다면 성공인 것이다. 이제 본격적으로 아이템을 제거해 보자. RemoveHighQuantityCommodities를 클릭하면 다음과 같은 화면이 등장한다. POST를 클릭하고, 스크롤을 내려 Try it out!을 클릭한다. Response code로 200을 받았다면 아이템이 정상적으로 지워졌다는 뜻이다. 실제로 지워졌는지 확인하기 위해 Commodity의 GET을 클릭해 보자. 결과로 Corn만 출력됐다면 성공적으로 지워진 것이다.","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"Hyperledger","slug":"Hyperledger","permalink":"https://d2fault.github.io/tags/Hyperledger/"},{"name":"Composer","slug":"Composer","permalink":"https://d2fault.github.io/tags/Composer/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://d2fault.github.io/tags/Tutorial/"}]},{"title":"[Hyperledger] Composer 튜토리얼 실습하기","slug":"20180502-hyperledger-composer-tutorial","date":"2018-05-02T01:53:32.000Z","updated":"2021-03-04T05:31:55.938Z","comments":true,"path":"2018/05/02/20180502-hyperledger-composer-tutorial/","link":"","permalink":"https://d2fault.github.io/2018/05/02/20180502-hyperledger-composer-tutorial/","excerpt":"","text":"Hyperledger Composer 튜토리얼 실습하기 개발 환경 구축에 이은 실습 포스팅이다. 튜토리얼에는 playground 튜토리얼과 개발자 튜토리얼이 있는데, playground 튜토리얼은 포스팅하지 않아도 될 것 같아 '개발자 튜토리얼’을 기준으로 포스팅할 것이다. 이번에도 공식 사이트를 참고하여 작성한다. 1. 비즈니스 네트워크 구조 정의 블록체인 솔루션에 관한 데이터 모델, 트랜잭션 논리 및 액세스 제어 규칙을 정의한다. 가장 쉬운 방법은 Yeoman 생성기를 사용하여 스켈레톤 비즈니스 네트워크를 만드는 것이다. 이렇게 하면 비즈니스 네트워크의 모든 구성 요소를 포함하는 디렉토리가 생성된다. Yeoman을 사용하여 스켈레톤 비즈니스 네트워크를 만들어 보자. 1yo hyperledger-composer:businessnetwork 위의 명령어를 실행하면 묻는 항목들은 다음과 같이 설정하면 된다. 123456Bushiness network name: tutorial-networkDescription: tutorial(자유롭게 적어도 됨)Author name: admin(자유롭게 적어도 됨)Author email: admin@tutorial.com(자유롭게 적어도 됨)License: Apache-2.0Namespace: org.example.mynetwork 그리고 '빈 네트워크를 설정하시겠습니까?'의 질문에는 No를 선택하면 된다. 2. 비즈니스 네트워크 정의하기 튜토리얼 비즈니스 네트워크에는 assets, participants, transactions과 access control, optionally events, queries가 포함된다. 먼저, 모델 파일을 수정해 보자. GUI에 익숙한 나는 VS Code로 해당 위치에 직접 접근해서 수정했다. VS Code에서 '폴더 열기’로 tutorial-network를 열어 두자. 1. org.example.mynetwork.cto 파일 수정 tutorial-network/models/org.example.mynetwork.cto 파일을 열고, 아래의 내용을 덮어씌운다. 1234567891011121314151617181920&#x2F;** * My commodity trading network *&#x2F;namespace org.example.mynetworkasset Commodity identified by tradingSymbol &#123; o String tradingSymbol o String description o String mainExchange o Double quantity --&gt; Trader owner&#125;participant Trader identified by tradeId &#123; o String tradeId o String firstName o String lastName&#125;transaction Trade &#123; --&gt; Commodity commodity --&gt; Trader newOwner&#125; 2.logic.js 스크립트 파일 수정 tutorial-network/lib/logic.js 파일을 열고 아래의 내용으로 바꾼 후 저장한다. 12345678910/** * Track the trade of a commodity from one trader to another * @param &#123;org.example.mynetwork.Trade&#125; trade - the trade to be processed * @transaction */async function tradeCommodity(trade) &#123; trade.commodity.owner = trade.newOwner; let assetRegistry = await getAssetRegistry(&#x27;org.example.mynetwork.Commodity&#x27;); await assetRegistry.update(trade.commodity);&#125; 3. permissions.acl 수정 tutorial-network/permissions.acl 파일을 아래와 같이 수정한다. 123456789101112131415161718&#x2F;** * Access control rules for tutorial-network *&#x2F;rule Default &#123; description: &quot;Allow all participants access to all resources&quot; participant: &quot;ANY&quot; operation: ALL resource: &quot;org.example.mynetwork.*&quot; action: ALLOW&#125;rule SystemACL &#123; description: &quot;System ACL to permit all access&quot; participant: &quot;ANY&quot; operation: ALL resource: &quot;org.hyperledger.composer.system.**&quot; action: ALLOW&#125; 3. 비즈니스 네트워크 아카이브 생성 tutorial-network 디렉토리에서 다음의 명령을 실행한다. (점 빼먹지 말기! 마지막에 점! 점!!! 점 빼먹으면 인자값을 받지 못했다는 에러를 뿜음.) 1composer archive create -t dir -n . 4. 비즈니스 네트워크에 배포 비즈니스 네트워크에 배포하기 전, startFabric.sh와 createPeerAdminCard.sh을 먼저 실행해야 한다. 실행 전에 아래의 코드를 실행시키면 당연히 에러[1]가 난다. 1. Fabric 실행 및 PeerAdminCard 생성 fabric-tools 디렉토리에서 명령어를 실행한다. 12.&#x2F;startFabric.sh.&#x2F;createPeerAdminCard.sh 2. 비즈니스 네트워크 설치 tutorial-network 디렉토리에서 다음의 명령어로 비즈니스 네트워크를 실행한다. 1composer network install --card PeerAdmin@hlfv1 --archiveFile tutorial-network@0.0.1.bna 3. 비즈니스 네트워크 시작 1composer network start --networkName tutorial-network --networkVersion 0.0.1 --networkAdmin admin --networkAdminEnrollSecret adminpw --card PeerAdmin@hlfv1 --file networkadmin.card 4. 관리자 ID 가져오기 사용 가능한 비즈니스 네트워크 카드로 관리자 id를 가져온다. 1composer card import --file networkadmin.card 5. 배포 확인 비즈니스 네트워크가 제대로 배포되었는지 확인하기 위해 ping을 날려 본다. 1composer network ping --card admin@tutorial-network 5. REST 서버 생성 Hyperledger Composer는 비즈니스 네트워크를 기반으로 맞춤형 REST API를 생성 할 수 있다. 진짜, 완전, 정말 편한 기능이다. REST API를 자동으로 만들어 준다. 먼저, tutorial-network 디렉토리에 접근하여 다음의 명령을 실행하자. 1composer-rest-server 이것저것 뭘 입력하라고 하는데, 다음과 같은 순서로 입력하면 된다. 12345Enter the name of the business network card to use: admin@tutorial-networkSpecify if you want namespaces in the generated REST API: never use namespacesSpecify if you want to enable authentication for the REST API using Passport: NoSpecify if you want to enable event publication over WebSocket: YesSpecify if you want to enable TLS security for the REST API: No 중간에 잘못 입력했다면 ctrl+c로 빠져나와서 다시 처음부터 입력하면 된다. 6. 응용 프로그램 생성 Hyperledger Composer는 REST API로 실행 중인 Angular 4 Application을 생성 할 수도 있다. 단, 기존에 열려 있던 터미널이 아닌(REST API가 열려 있는 터미널이 아닌) 새 터미널 창으로 실행해야 한다. 이번에도 tutorial-network 디렉토리에서 다음을 실행해 보자. 1yo hyperledger-composer:angular 그리고 다음과 같이 입력하면 된다.\u0003 1234567891011Do you want to connect to a running Business Network? YesProject name: tutorial-networkDescription: tutorialAuthor name: adminAuthor email: admin@tutorial-networkLicense: Apache-2.0Name of the Business Network card: admin@tutorial-networkDo you want to generate a new REST API or connect to an existing REST API?: Connect to an existing REST APIREST server address: http:&#x2F;&#x2F;localhostREST server port: 3000Should namespaces be used in the generated REST API? Namespaces are not used 실행은 어떻게 하느냐? tutorial-network/tutorial-network 디렉토리 안에서 npm start 명령어로 실행하면 된다. Angular App 확인은 http://localhost:4200에서 할 수 있다. Error: Error trying install business network. Error: No valid responses from any peers. Response from attempted peer comms was an error: Error: 14 UNAVAILABLE: Connect Failed ↩︎","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"Hyperledger","slug":"Hyperledger","permalink":"https://d2fault.github.io/tags/Hyperledger/"},{"name":"Composer","slug":"Composer","permalink":"https://d2fault.github.io/tags/Composer/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://d2fault.github.io/tags/Tutorial/"}]},{"title":"[Linux] node.js, npm 설치 및 업그레이드","slug":"20180430-install-and-upgrade-nodejs-or-npm","date":"2018-04-30T04:24:35.000Z","updated":"2021-03-04T05:31:55.938Z","comments":true,"path":"2018/04/30/20180430-install-and-upgrade-nodejs-or-npm/","link":"","permalink":"https://d2fault.github.io/2018/04/30/20180430-install-and-upgrade-nodejs-or-npm/","excerpt":"","text":"개요 node.js 때문에 골머리 앓으신 적 많으시지요? 네, 제가 그랬습니다. node는 뭐고 npm은 뭐고 nvm은 뭐야? 라고 생각했던 머저리. 아무튼, 설치 순서는 nvm -&gt; node/npm입니다. nvm은 node version manager, npm은 node package manager! 즉, node의 버전을 관리하는 건 nvm이고 패키지를 관리하는 게 npm이랍니다. 헛소리 그만하고 설치해 보자. 1. nvm 설치 nvm 공식 사이트 를 참고해 보자. curl, wget 둘 중 하나로 설치하면 된다. 12345# curl으로 설치하기curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash# wget으로 설치하기wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash .bash_profile에 반영하자. 1source .bash_profile 2. node 설치(npm 자동으로 설치됨) fabric 실습하기 위해선 적당한 버전(!)을 선택해야 한다. 절대로 v10은 사용하지 마세요. 에러 장난 X! 1234# nodejs v9.4.0 설치nvm install v9.4.0# v9.4.0을 사용한다는 의미. 다른 버전으로 바꾸는 것도 가능.nvm use v9.4.0 .bash_profile에 반영하자. 1source .bash_profile node.js, npm 버전 확인 12nodejs -vnpm -v node.js 업그레이드 먼저, 강제로 캐시를 삭제한다. 1sudo npm cache clean --force 다음으로 n 모듈을 설치한다. 1sudo npm install -g n n 모듈을 이용하여 Node.js를 설치한다. 1sudo n stable npm 업그레이드 npm으로 npm을 설치하면 된다. 1sudo npm install -g npm node.js 삭제(uninstall) apt으로 제거하면 된다. 1sudo apt remove nodejs npm 삭제(uninstall) 이상하게도 npm은 apt으로 제거가 안 된다. 아래와 같이 해 줘야 함. 1rm -rf /usr/local/&#123;lib/node&#123;,/.npm,_modules&#125;,bin,share/man&#125;/npm* 부록 혹은 별첨 nvm 없이 node.js 설치하기(공식 사이트 버전, npm 자동 설치) 공식 사이트 확인해 보니 다음과 같은 방법이 있어서 적는다. 12curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -sudo apt-get install -y nodejs 위의 방법으로 설치하면 npm은 자동으로 설치된다. apt를 이용한 node.js, npm 설치(비추천) apt 이용하면 간단하게 설치 가능하다. 12sudo apt install nodejssudo apt install npm","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Linux","slug":"IT/Linux","permalink":"https://d2fault.github.io/categories/IT/Linux/"}],"tags":[{"name":"개발환경","slug":"개발환경","permalink":"https://d2fault.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD/"},{"name":"설치","slug":"설치","permalink":"https://d2fault.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"node.js","slug":"node-js","permalink":"https://d2fault.github.io/tags/node-js/"}]},{"title":"[Hyperledger] 개발 환경 구축하기(설치)","slug":"20180430-setting-hyperledger-developement-environment","date":"2018-04-30T02:06:08.000Z","updated":"2021-03-04T05:31:55.938Z","comments":true,"path":"2018/04/30/20180430-setting-hyperledger-developement-environment/","link":"","permalink":"https://d2fault.github.io/2018/04/30/20180430-setting-hyperledger-developement-environment/","excerpt":"","text":"Hyperledger 개발 환경 구축 이 글은 우분투를 사용한다는 가정 하에 작성되었다. 개발 환경 구축은 공식 사이트를 참고했다. 0. 개발 전제 조건 Hyperledger Composer과 Hyperledger 패브릭을 실행하려면 최소 4GB의 메모리가 필요하다. 필수 개발 도구를 설치하기 위한 전제 조건은 다음과 같다. OS: Ubuntu Linux 14.04 / 16.04 LTS (both 64-bit) 또는 Mac OS 10.12 Docker Engine: 버전 17.03 이상 Docker-Compose: 버전 1.8 이상 Node: 8.9 이상 (버전 9는 지원되지 않음) npm: v5.x git: 2.9.x 이상 Python: 2.7.x 1. 필수 구성 요소 설치 절대 루트에 설치하지 말 것. su, sudo 명령어 사용하지 말 것. 일반 사용자로 로그인하여 설치해야 한다고 한다. 그래서 hyper라는 이름의 계정을 만들어 주었다. 우분투 계정 만들기 1adduser hyper 새로 만든 계정에 sudo 권한 부여 hyper is not in the sudoers file. This incident will be reported. 에러를 해결하기 위한 방법이다. 계정에 sudo 권한이 등록되어 있지 않아 나타나는 에러이기 때문. 1sudo visudo 다음의 내용을 추가한다.\u0003 12345678....# User privilege specificationroot ALL=(ALL:ALL) ALL# 여기에 아래와 같이 추가하면 된다.hyper ALL=(ALL:ALL) ALL.... ^는 컨트롤 키를 의미. ctrl+C 누르면 닫힘. 필수 구성 요소 다운로드 및 설치 123curl -O https://hyperledger.github.io/composer/latest/prereqs-ubuntu.shchmod u+x prereqs-ubuntu.sh./prereqs-ubuntu.sh 2. 개발 환경 설치 CLI 도구 설치 필수 요소인 composer-cli와, generator-hyperledger-composer, composer-rest-server그리고 Yeoman, generator-hyperledger-composer를 설치해 보자. 필수 요소가 아닌 것까지 설치하는 이유는, 튜토리얼에서 사용하기 때문이기도 하지만 실제 개발에서 유용하게 사용되기 때문이다. 1234567# 필수 요소 설치npm install -g composer-cli# 나머지 유용한 도구 설치npm install -g composer-rest-servernpm install -g generator-hyperledger-composer# generator-hyperledger-composer를 이용하기 위한 Yeoman 설치npm install -g yo Playground 설치 1npm install -g composer-playground IDE 설정 역시 IDE는 짱짱맨이다. VS Code를 이용해서 편집하면 을매나 편하게요? VS Code를 다운로드한 후 설치하고, 확장 프로그램에서 Hyperledger Composer를 추가 설치하면 간단하게 끝난다. Hyperledger Fabric 설치 원하는 디렉토리에 fabric 설치 파일을 다운로드한다. 123mkdir ~/fabric-tools &amp;&amp; cd ~/fabric-toolscurl -O https://raw.githubusercontent.com/hyperledger/composer-tools/master/packages/fabric-dev-servers/fabric-dev-servers.tar.gztar -xvf fabric-dev-servers.tar.gz 폴더 안에 있는 스크립트로 fabric을 설치한다. 12cd ~/fabric-tools./downloadFabric.sh 3. 개발 환경 제어 Hyperledger Fabric 시작 새 런타임을 시작할 때에는 시작 스크립트를 실행하고, PeerAdminCard를 생성해야 한다. 12345cd ~/fabric-tools# 시작 스크립트./startFabric.sh# PeerAdminCard 생성./createPeerAdminCard.sh Hyperledger Fabric 중지 개발 세션이 끝나면 Fabric을 중지시키고, 해체 스크립트를 실행해야 한다. 1234# Fabric 중지~/fabric-tools/stopFabric.sh# 해체~/fabric-tools/teardownFabric.sh 다음 런타임을 실행할 때에는 시작 스크립트 실행 후 PeerAdminCard를 다시 생성해 주어야 한다. 이전 설정 파괴하기 이전의 모든 docker 컨테이너는 다음의 명령어로 제거할 수 있다. 에러가 나면 일단 지우고 봤음. 123docker kill $(docker ps -q)docker rm $(docker ps -aq)docker rmi $(docker images dev-* -q)","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"Hyperledger","slug":"Hyperledger","permalink":"https://d2fault.github.io/tags/Hyperledger/"},{"name":"개발환경","slug":"개발환경","permalink":"https://d2fault.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD/"},{"name":"설치","slug":"설치","permalink":"https://d2fault.github.io/tags/%EC%84%A4%EC%B9%98/"}]},{"title":"[정보] 특허와 지적재산권","slug":"20180418-patent-and-intellectual-property-right","date":"2018-04-18T01:01:53.000Z","updated":"2021-03-04T05:31:55.937Z","comments":true,"path":"2018/04/18/20180418-patent-and-intellectual-property-right/","link":"","permalink":"https://d2fault.github.io/2018/04/18/20180418-patent-and-intellectual-property-right/","excerpt":"","text":"지적재산권이란? 지적재산권 산업재산권 특허: 출원일로부터 20년 실용신안: 출원일로부터 10년 디자인: 출원일로부터 15년 상표: 출원일로부터 10년 저작권: 사후 70년 신 지적재산권 컴퓨터 프로그램: 공표 후 50년 영업비밀 반도체 집적회로 배치 설계: 등록 후 10년 특허의 이해 특허의 기본 목적: 제3자가 내 아이디어를 쓰지 못하게 하는 배타적 권리를 인정받기 위함. 특허 출원: 18개월 뒤 공개 의무가 있고, 로열티의 근간이 된다. 어떤 경우에 출원할 수 있나요? 실제로 구현하거나, 구현하지 않았더라도 실현 가능성이 있는 기술 기술력과 상관없이 비용만 있으면 할 수 있다. 특허 심사란? 내 아이디어의 기술력을 심사하는 것이 아닌, 선행기술과의 차이점을 비교하는 것이다. 선행기술과 다르면 특허 등록이 될 수 있다. (특허 등록이 곧 기술력은 아님.) 발명 접수 주의사항 발명자에 해당하지 않는 경우 발명자에게 자금을 제공하여 설비 이용의 편의를 주는 자 발명의 완성을 원조하거나 위탁한 자(단순 후원자, 위탁자) 희망 조건만 제시하고 해결할 방법을 제공하지 않은 자 타인이 제시한 착상 속에서 실용성이 있을 것 같은 것을 선택한 것에 지나지 않는 자 당해 발명에 관하여 착상만 하고 구체화하는데 실질적으로 관여하지 않은 자(일반 지식의 조언 또는 제시를 주기만 한 자) 발명자에 해당하는 경우 타인의 착상에 의거 연구를 하여 발명을 완성한 자 타인의 착상에 대해 구체화하는 기술적 수단을 부가하여 발명한 자 어떤 문제를 해결하기 위한 기술적 수단을 착상한 자 타인의 발명에 힌트를 얻고 다시 그 발명의 범위를 확대하는 발명을 한 자 관련 정보 키프리스: 특허를 검색할 수 있는 사이트","categories":[{"name":"Blog","slug":"Blog","permalink":"https://d2fault.github.io/categories/Blog/"},{"name":"Information","slug":"Blog/Information","permalink":"https://d2fault.github.io/categories/Blog/Information/"}],"tags":[{"name":"특허","slug":"특허","permalink":"https://d2fault.github.io/tags/%ED%8A%B9%ED%97%88/"},{"name":"지적재산권","slug":"지적재산권","permalink":"https://d2fault.github.io/tags/%EC%A7%80%EC%A0%81%EC%9E%AC%EC%82%B0%EA%B6%8C/"}]},{"title":"[Review] 커피 매니아라면, 나노프레소!","slug":"20180417-nanopresso-review","date":"2018-04-17T12:45:37.000Z","updated":"2021-03-04T05:31:55.921Z","comments":true,"path":"2018/04/17/20180417-nanopresso-review/","link":"","permalink":"https://d2fault.github.io/2018/04/17/20180417-nanopresso-review/","excerpt":"","text":"커피? 커피! 나에게 커피란 곧 습관이다. 졸린 낮에, 일이 많은 새벽에, 그리고 여유와 함께하는 뭐 그런 소소한 습관? 여전히 커피는 습관이지만, 반복 학습의 영향으로 내 입에 ‘맞는’ 커피와 ‘안 맞는’ 커피는 구분할 수 있게 되었다. 바야흐로 2016년, 내가 자취할 때의 이야기. 카페를 가자니 거리도 거리인데다 돈은 없고, 맛있는 커피는 (자주) 먹고 싶고, 무슨 방법이 없을까 한참을 고민했다. 간절하면 길이 생긴다더니, 네이버 메인에서 우연히 냉침 커피(콜드브루) 만드는 방법을 보게 되었다. 그라인딩된 원두에 찬물을 넣고 냉장고에서 숙성한 후 드리퍼에 내려 버리면 완성! 햐, 이 방법으로 거의 2년을 마셨던 듯하다. 여름에는 거의 물처럼 드링킹! ㅋㅋ 그런데 사람 욕심이라는 게, 커피를 다양한 방법으로 즐기고 싶어졌다. 그러려면 에스프레소가 필요하단 말이지. 머신을 사려고 했는데 마땅한 머신을 못 찾았고, 모카포트를 사려다가도 관리가 안 될 것 같아 포기했다. 그렇게 반 년을 보냈는데 글쎄… 휴대용 에스프레소 기계가 있다는 것 아니겠어? 가격도 완전 착한데(마침 돈도 벌겠다)! 그 정보를 준 건 블로그도, 카페 게시글도 아닌 지마켓이었다. ㅋㅋㅋㅋㅋㅋ(하지만 거기에서 안 산 게 함정) Wacaco Nanopresso? 기다리고 기다리다 받은 나노프레소! 커피 용품으로 유명한 커피뮤제오에서 구매했다. 이게 무슨 에스프레소 머신이냐고? 분리해 보자! 위와 아래가 모두 분리된다. 한 쪽에는 물을 담고, 다른 한 쪽에서 에스프레소를 뽑아내게 된다. 높은 압력이 주어지면 얇은 구멍을 통해 쫀쫀한 에스프레소가 슉슉 나온다. 뚜껑은 잘 맞춰서 닫아 주어야 한다. 커피를 너무 많이 남으면 제대로 닫히지 않아 위험하다.(높은 압력이 가해지기 때문에 주변으로 에스프레소가 새기도 하고, 제대로 나오지도 않는다.) 적당한 양의 커피가루를 담는 것이 포인트! 이 또한 적당히! 무조건 적당히의 미학을 지켜야 한다. 조금이라도 욕심을 부렸다간 뚜껑 덮을 때 넘치는 물을 볼 수 있을 거시여. 합체시키고 앞의 버튼을 돌려(?)서 빼내면 완성! 물탱크가 위로 가도록 양손으로 잡고, 버튼을 슉슉 강하게 눌러 주면 에스프레소가 아주 잘 나온다. 장단점 파헤치기 장점 맛있는 커피를 마실 수 있다. 커피로 소비하는 비용이 훅 줄어든다. 머신 치고는 저렴한 편(약 10만 원)이다. 뜨거운 물과 커피가루만 있다면 어디에서든 에스프레소를 내릴 수 있다. 다양한 커피 음료를 만들 수 있다. 단점 힘들다. 정말 힘들다. 자동 머신을 사야겠다. (…) 꿀팁? 물 온도가 낮고 가늘게 분쇄된 커피를 사용할수록 힘이 많이 들어간다. (높은 압력을 손으로만 줘야 해서) 펌핑이 힘든 날에는 탬핑을 약하게 하고, 물의 온도를 올려 보자. 펌핑이 쉬운 날에는 탬핑을 강하게 해 보자. 커피 가루는 꼭 적당히 넣는 걸로! 주말에 에스프레소 잔뜩 뽑아 두면(냉장고에 보관하면 된다.) 평일 내내 마실 수 있다. ^^","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"커피","slug":"커피","permalink":"https://d2fault.github.io/tags/%EC%BB%A4%ED%94%BC/"},{"name":"나노프레소","slug":"나노프레소","permalink":"https://d2fault.github.io/tags/%EB%82%98%EB%85%B8%ED%94%84%EB%A0%88%EC%86%8C/"}]},{"title":"[Ethereum] dApp 개발기(1)","slug":"20180410-develop-dapp","date":"2018-04-10T09:44:34.000Z","updated":"2021-03-04T05:31:55.921Z","comments":true,"path":"2018/04/10/20180410-develop-dapp/","link":"","permalink":"https://d2fault.github.io/2018/04/10/20180410-develop-dapp/","excerpt":"","text":"dApp 개발기(1) 갑자기 어디에선가 솔리디티가 떨어졌다. 이 개발기는 아마, 많은 사람들에게 도움이 될지도 모른다. 안 되면 어쩔 수 없고! 나한테는 도움이 되겠지! 셀프로 꾸준히 참조할 것 같으니까 잘 정리해 두어야지. ㅎㅎ Solidity 계정 생성 1234person.newAccount(&quot;패스워드&quot;)eth.accounts[접근할 인덱스]personal.listAccounts[접근할 인덱스]personal.unlockAccount(지갑 해시, &quot;패스워드&quot;) Solidity default 계정 변경 1eth.defaultAccount &#x3D; eth.accounts[접근할 인덱스] Solidity Contract 실행 123456contractAddress &#x3D; &#39;컨트랙트 주소&#39;abi &#x3D; abi값 복사해서 넣기simpleStorageContract &#x3D; eth.contract(abi)simpleStorage &#x3D; simpleStorageContract.at(contractAddress)simpleStorage.set(값)simpleStorage.get() 인자에 배열 사용하기 아래와 같이 코딩하면 되는데, 이렇게 할 경우 result의 특정 index에 다른 값을 저장할 수 없다. 예를 들어, {1, 2, 3} 배열을 인자로 받았고, 그 다음 번 호출에 또 {1, 2, 3}이 들어오게 되면 result의 최종 값은 {1, 2, 3, 1, 2, 3}이 된다. 123456uint[] result;function setData(uint[] arr) &#123; for(uint i &#x3D; 0; i &lt; arr.length; i++) &#123; result.push(arr[i]); &#125;&#125; 그럼 어떻게 받아야 하냐고? 다음과 같이 받으면 된다. 1234uint[] result;function setData(uint[] arr) &#123; result &#x3D; arr;&#125; 도대체 이걸 왜 고민했지? ;;","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"https://d2fault.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"https://d2fault.github.io/tags/Solidity/"}]},{"title":"[Linux] 리눅스 기초 명령어","slug":"20180410-linux-basic","date":"2018-04-10T06:42:07.000Z","updated":"2021-03-04T05:31:55.921Z","comments":true,"path":"2018/04/10/20180410-linux-basic/","link":"","permalink":"https://d2fault.github.io/2018/04/10/20180410-linux-basic/","excerpt":"","text":"리눅스 기초 명령어 결국 리눅스(우분투 사용 중)를 하게 되는 날이 왔다. 또 미래의 나를 위해 정리해야지. 리눅스랑 친하지 않은(앞으로 친해질) 나를 위해 이 블로그 글을 바칩니다… su 인증 실패 sudo passwd root 사용해서 루트 비밀번호를 먼저 설정해야 한다. 설정하면 바로 해결됨. 리눅스 디렉토리 삭제 rm -r: 자기 자신(폴더)와 해당 폴더 안에 있는 모든 파일까지 삭제. rm -i: 파일이나 폴더를 삭제할 때 삭제할 것인지 묻는다. rm -f: 파일이 있건 없건 오류 표출하지 않고 무조건 삭제. rm -rf 디렉토리명: 리눅스 디렉토리를 삭제.(하위 디렉토리, 파일 전부 포함.) rm -rf *: 현재 디렉토리의 모든 것들을 삭제. rmdir 디렉토리명: 디렉토리만 삭제한다.(디렉토리 안에 파일이 있다면 삭제되지 않음.) 우분투 계정 추가 adduser 계정명: 계정 생성 시에 비밀번호까지 입력받는다. 홈 디렉토리도 생성해 준다. useradd 계정명: 순수하게 계정만 생성한다. 홈 디렉토리와 패스워드는 별도 생성. 나는 얘 안 쓸래. 우분투 계정 sudo 설정 아래 명령어 실행. 1sudo visudo /etc/sudoers 파일 내에서 다음의 내용을 추가한다. 12345678....# User privilege specificationroot ALL=(ALL:ALL) ALL# 여기에 아래와 같이 추가하면 된다.계정명 ALL=(ALL:ALL) ALL.... \u0003 우분투 계정 암호 수정 passwd 계정명: 비밀번호 입력하라고 나오면 치면 됨. 우분투 계정 삭제 deluser 계정명: 기본적으로 계정만 삭제된다. 홈 디렉토리 밑 다른 파일을 삭제하고 싶으면 아래 명령어 고고. deluser -remove-all-files 계정명: 계정과 홈 디렉토리, 다른 파일까지 전부 삭제한다. 우분투 프로세스 확인 1ps -ef | grep &lt;찾고 싶은 프로세스명&gt; 우분투 프로세스 종료 1kill &lt;프로세스 id&gt;","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Linux","slug":"IT/Linux","permalink":"https://d2fault.github.io/categories/IT/Linux/"}],"tags":[{"name":"명령어","slug":"명령어","permalink":"https://d2fault.github.io/tags/%EB%AA%85%EB%A0%B9%EC%96%B4/"}]},{"title":"[Ethereum] Solidity 문법 이해(4)","slug":"20180320-about-solidity-4","date":"2018-03-20T07:41:43.000Z","updated":"2021-03-04T05:31:55.920Z","comments":true,"path":"2018/03/20/20180320-about-solidity-4/","link":"","permalink":"https://d2fault.github.io/2018/03/20/20180320-about-solidity-4/","excerpt":"","text":"함수 변경자 _;를 만나면 다음에 나열된 함수를 실행하라는 의미이다. 그리고 _; 뒤에 있는 문장은 차곡차곡 스택에 쌓인다. 도대체 이걸 왜 만든 건지 모르겠다. (심지어 책 예시에 myModifier4는 적혀 있지도 않다. 실수인 듯…) 아무튼, 예시는 다음과 같다. 1234567891011121314151617181920212223242526272829contract sample &#123; int a = 90; modifier myModifier1(int b) &#123; int c = b; _; c = a; a = 8; &#125; modifier myModifier2 &#123; int c = a; _; &#125; modifier myModifier3 &#123; a = 96; return; _; a = 99; &#125; modifier myModifier4 &#123; int c = a; _; &#125; function myFunction() myModifier1(a) myModifier2 myModifier3 myModifier4 returns (int d) &#123; a = 1; return a; &#125;&#125; 다음과 같은 순서로 실행한다. 123456789101112131415161718// myModifier 1int c = b; // myModifier 2 int c = a; // myModifier 3 a = 96; return; // myModifier 4 int c = a; // myFunction a = 1; return a; // myModifier 2는 _; 이후 명령문이 없어서 skip // myModifier 3 a = 99;// myModifier 1c = a;a = 8; 폴백(fallback function) 함수 컨트랙트는 한 개의 이름 없는 함수를 가질 수 있다. 이것이 폴백함수이며, 이 함수는 인자를 가질 수도, 리턴 값을 줄 수도 없다. 폴백 함수는 트랜잭션이 컨트랙트에 이더를 송금했으나 메소드를 호출하지 않은 경우에도 실행한다. 이런 경우, 함수를 가능한 싸게 만드는 것이 중요하다. 이더를 받고 싶은 컨트랙트의 경우 폴백 함수를 구현해야 한다. 폴백 함수가 정의되지 않았다면 예외를 발생시키고, 이더를 돌려 보낸다. 12345contract sample &#123; function() payable &#123; // 누구로부터 얼만큼의 이더가 전송되었는지 기록한다. &#125;&#125; 라이브러리 라이브러리는 특정 주소에 한 번 배포되면 다양한 컨트랙트에서 재사용할 수 있다. 라이브러리 함수가 호출되면 코드가 호출한 컨트랙트의 컨텍스트에서 실행된다. 즉, 호출하는 컨트랙트의 저장소에 접근할 수 있다. 라이브러리는 상태 변수를 가질 수 없고, 상속을 지원하지 않으며, 이더를 받을 수도 없다. 12345678910library math &#123; function addInt(int a, int b) returns (int c) &#123; return a + b; &#125;&#125;contract sample &#123; function data() returns (int d) &#123; return math.addInt(1, 2); &#125;&#125; for 사용(반복문 X) using A for B; 지시자는 라이브러리 함수를 attach 하는 데 사용할 수 있다. 이 함수는 첫 번째 매개변수로 호출된 객체를 받는다. 1234567891011121314151617181920212223242526272829303132library math &#123; struct myStruct1 &#123; int a; &#125; struct myStruct2 &#123; int a; &#125; // 참조할 수 있도록 &#x27;s&#x27; 위치 저장소를 만들어야 한다. // 그렇지 않다면 myStruct1 대신 다른 myStruct1 인스턴스에 접근하거나 수정하게 된다. function addInt(myStruct1 storage s, int b) returns (int c) &#123; return s.a + b; &#125; function subInt(myStruct2 storage s, int b) returns (int c) &#123; return s.a - b; &#125;&#125;contract sample &#123; using math for *; math.myStruct1 s1; math.myStruct2 s2; function sample() &#123; s1 = math.myStruct1(9); s2 = math.myStruct2(9); s1.addInt(2); // addInt의 첫 매개변수가 myStruct1인데, s2는 myStruct2 유형이다. // 고로, mySturct2에 attach되지 않아 컴파일 오류가 발생한다. // s2.subInt(1);은 정상 동작한다. s2.addInt(1); &#125;&#125; ✯ 이 포스트의 모든 내용은 이더리움을 활용한 블록체인 프로젝트 구축(에이콘) 책을 참고하여 작성되었습니다.","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"문법","slug":"문법","permalink":"https://d2fault.github.io/tags/%EB%AC%B8%EB%B2%95/"},{"name":"Ethereum","slug":"Ethereum","permalink":"https://d2fault.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"https://d2fault.github.io/tags/Solidity/"}]},{"title":"[Ethereum] Solidity 문법 이해(3)","slug":"20180320-about-solidity-3","date":"2018-03-20T02:36:03.000Z","updated":"2021-03-04T05:31:55.920Z","comments":true,"path":"2018/03/20/20180320-about-solidity-3/","link":"","permalink":"https://d2fault.github.io/2018/03/20/20180320-about-solidity-3/","excerpt":"","text":"기본 유형 간의 변환 배열, 문자열, 구조체, 열거형, 맵 이외의 모든 것을 기본 유형이라고 부른다. 일반적으로 값의 유실이 없는 경우 유형 간의 묵시적 변환이 가능하다.[1] 솔리디티는 명시적 변환도 지원한다. 그러나 예상하지 못한 결과가 나올 수도 있기 때문에 명시적 변환은 지양하는 것이 좋다. var 사용 var를 사용하는 경우, 변수 유형은 첫 번째로 할당된 값에 따라 동적으로 결정된다. 값 지정 이후의 유형은 고정되므로, 다른 값을 할당하면 형 변환이 발생한다.[2] 제어 구조 솔리디티 또한 대부분의 언어에서 지원하는 if, else, while, for, break, continue, return,?를 지원한다. new 연산자를 사용하여 컨트랙트 생성 1234567891011121314contract sample1 &#123; int a; function assign(int b) &#123; a = b; &#125;&#125;contract sample2 &#123; function sample2() &#123; sample1 s = new sample1(); s.assign(12); &#125;&#125; 예외 수동으로 예외를 발생시키기 위해서는 throw 키워드를 사용한다. 예외는 현재 호출 중인 모든 호출을 중지하고 상태를 원복시킨다. 단, 예외 처리(catch)는 불가능하다. 12345contract sample &#123; function myFunction() &#123; throw; &#125;&#125; 함수 호출 솔리디티에는 내부 함수 호출[3]과 외부 함수 호출[4]이 있다. 123456789101112131415161718192021222324252627282930313233343536373839contract sample1 &#123; int a; function sample1(int b) payable &#123; a = b; &#125; function assign(int c) &#123; a = c; &#125; function makePayment(int d) payable &#123; a = d; &#125;&#125;contract sample2 &#123; function hello() &#123; &#125; function sample2(address addressOfContract) &#123; // 컨트랙트 인스턴스 생성하며 12 wei 전송 sample1 s = (new sample1).value(12)(23); s.makePayment(22); // 다시 이더 전송 s.makePayment.value(45)(12); // 사용할 가스의 양 지정 s.makePayment.gas(895)(12); // 이더를 전송하고 가스를 다시 지정 s.makePayment.value(4).gas(900)(12); // hello()는 내부 호출이며, this.hello()는 외부 호출 this.hello(); // 이미 배포된 컨트랙트를 지정 sample1 s2 = sample1(addressOfContract); s2.makePayment(112); &#125;&#125; 가시성 가시성(visiability)은 누가 볼 수 있는지 정의한다. external 다른 컨트랙트나 트랜잭션을 통해서만 호출될 수 있다. f()는 동작하지 않지만 this.f()는 동작한다. public 모든 방법으로 접근할 수 있다. 단, setters는 생성하지 않기 때문에 이미 지정된 값을 변경할 수는 없다. internal 내부적으로만 접근할 수 있다. 접근을 위해 this를 사용할 수 없다. private internal과 비슷하지만 상속된 컨트랙트에서 접근할 수 없다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364contract sample1 &#123; int public b = 78; int internal c = 90; function sample1() &#123; // 외부(external) 접근 this.a(); // 컴파일 오류 a(); // 내부(internal) 접근 b = 21; // 외부(external) 접근 this.b; // 외부(external) 접근 this.b(); // 컴파일 오류. setters가 지정되어 있지 않아 값을 변경할 수 없다. this.b(8); // 컴파일 오류. internal은 this로 접근할 수 없다. this.c(); // 내부(internal) 접근 c = 9; &#125; function a() external &#123; &#125; &#125;&#125;contract sample2 &#123; int internal d = 9; int private e = 90;&#125;// sample3은 sample2를 상속contract sample3 is sample2 &#123; sample1 s; function sample3() &#123; s = new sample1(); // 외부(external) 접근 s.a(); // 외부(external) 접근 var f = s.b; // 컴파일 오류. 접근자를 통해 값을 할당할 수 없다. s.b = 18; // 컴파일 오류. c는 internal. s.c(); // 내부(internal) 접근 d = 9; // 컴파일 오류. e는 private. e = 7; &#125;&#125; ✯ 이 포스트의 모든 내용은 이더리움을 활용한 블록체인 프로젝트 구축(에이콘) 책을 참고하여 작성되었습니다. uint8은 uint16으로 변환 가능하지만, 역은 불가능. ↩︎ 배열, 맵, 매개변수, 상태 변수를 정의할 때에는 var를 사용할 수 없다. ↩︎ 같은 컨트랙트의 함수를 호출하는 것. ↩︎ 다른 컨트랙트의 함수를 호출하는 것. ↩︎","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"문법","slug":"문법","permalink":"https://d2fault.github.io/tags/%EB%AC%B8%EB%B2%95/"},{"name":"Ethereum","slug":"Ethereum","permalink":"https://d2fault.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"https://d2fault.github.io/tags/Solidity/"}]},{"title":"[Ethereum] Solidity 문법 이해(2)","slug":"20180319-about-solidity-2","date":"2018-03-19T05:45:37.000Z","updated":"2021-03-04T05:31:55.919Z","comments":true,"path":"2018/03/19/20180319-about-solidity-2/","link":"","permalink":"https://d2fault.github.io/2018/03/19/20180319-about-solidity-2/","excerpt":"","text":"구조체 함수 외부에서 구조체 메소드 명시: 스토리지 저장 함수 내부에서 구조체 메소드 명시: 메모리 저장 12345678910111213141516contract sample &#123; struct myStruct &#123; bool myBool; string myString; &#125; // s1은 메모리에 있다. (구조체 메소드 명시 x) myString s1; // 스토리지에 인스턴스 저장 myStruct s2 = myStruct(true, &quot;&quot;); function sample(bool initBool, stirng initString) &#123; // 메모리에 인스턴스 저장 s1 = myStruct(initBool, initString); mySturct memory s3 = myStruct(initBool, initString); &#125;&#125; 열거형 1234567891011121314151617contract sample &#123; enum OS &#123; windows, Linux, OSX, UNIX &#125; OS choice; function sample(OS chosen) &#123; choice = chosen; &#125; function setLinuxOS() &#123; choice OS.Linux; &#125; function getChoice() returns (OS chosenOS) &#123; return choice; &#125;&#125; 매핑 스토리지에만 사용할 수 있기 때문에 오직 상태 변수로만 선언된다. 매핑은 키-값의 쌍으로 이루어진 해시 테이블이다. 키는 실제로 저장되지 않고, 키의 keccak256 해시 값이 검색에 사용된다. 매핑은 길이를 가지지 않으며, 다른 매핑에 할당될 수 없다. 12345678910contract sample &#123; mapping (int =&gt; string) myMap; function sample(int key, string value) &#123; myMap[key] = value; // myMap2는 myMap의 참조다 mapping(int =&gt; string) myMap2 = myMap; &#125;&#125; delete 연산자 delete는 어떤 변수라도 기본값으로 재설정하기 위해 사용될 수 있다. 동적 배열에 delete를 적용하면 모든 요소가 지워지고 길이가 0이 된다. 정적 배열에 적용하면 모든 인덱스가 재설정된다. 물론 특정 인덱스에만 적용하는 것도 가능하다. 맵에 delete를 적용하면 아무 일도 발생하지 않지만, 맵의 key에 delete를 적용하면 키와 연관된 값이 삭제된다. 123456789101112131415161718192021222324252627contract sample &#123; struct Struct &#123; mapping (int =&gt; string) myMap; int myNumber; &#125; int[] myArray; Struct myStruct; // 생성자 function sample(int key, int value, int number, int[] array) &#123; myStruct = Struct(number); myStruct.myMap[key] = value; myArray = array; &#125; function reset() &#123; delete myArray; // myNumber는 0이나 myMap은 그대로 delete myStruct; &#125; function deleteKey(int key) &#123; // 여기에서 myMap의 key 삭제 delete myStruct.myMap[key]; &#125;&#125; ✯ 이 포스트의 모든 내용은 이더리움을 활용한 블록체인 프로젝트 구축(에이콘) 책을 참고하여 작성되었습니다.","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"문법","slug":"문법","permalink":"https://d2fault.github.io/tags/%EB%AC%B8%EB%B2%95/"},{"name":"Ethereum","slug":"Ethereum","permalink":"https://d2fault.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"https://d2fault.github.io/tags/Solidity/"}]},{"title":"[Ethereum] Solidity 문법 이해(1)","slug":"20180319-about-solidity-1","date":"2018-03-19T00:41:03.000Z","updated":"2021-03-04T05:31:55.919Z","comments":true,"path":"2018/03/19/20180319-about-solidity-1/","link":"","permalink":"https://d2fault.github.io/2018/03/19/20180319-about-solidity-1/","excerpt":"","text":"솔리디티 소스 파일 솔리디티 소스 파일의 확장자는 .sol이다. 파일 내에서 pragma solidity를 사용, 컴파일러 버전을 지정할 수 있다. 1pragma solidity ^0.4.21 스마트 컨트랙트 구조 컨트랙트는 클래스와 비슷하여 상태 변수, 함수, 함수 변경자, 이벤트, 구조체, 열거형을 포함한다. 상속과 다형성 또한 지원한다. 123456789101112131415161718192021222324252627282930// 1. 컨트랙트 선언contract Sample &#123; // 2. 상태 변수 선언 uint256 data; address owner; // 3. 이벤트 정의 event logData(uint256 dataToLog); // 4. 함수 변경자 정의 modifier onlyOwner() &#123; if(msg.sender != owner) throw; _; &#125; // 5. 생성자 function Sample(uint256 initData, address initOwner) &#123; data = initData; onwer = initOwner; &#125; // 6. 함수(메소드) 정의 function getData() returns (uint256 returned) &#123; return data; &#125; function setData(uint256 newData) onlyOwner &#123; logData(newData); data = newData; &#125;&#125; 데이터 위치 솔리디티의 변수는 컨텍스트에 따라 메모리 또는 파일시스템에 저장된다. 그러나 문자열, 배열, 구조체와 같은 복합 유형의 경우 이더 스토리지 또는 메모리를 유형에 추가해 재정의할 수 있다. 함수 매개 변수(리턴 매개 변수 포함)의 기본 위치는 메모리이고, 로컬 변수의 기본 위치는 스토리지이며 상태 변수의 경우 강제로 스토리지에 저장된다. 상태 변수 contract 최상위단에 선언된 변수(스토리지에 저장) 로컬 변수 함수 아래에 선언된 변수(스토리지에 저장 / memory 키워드로 메모리 저장 가능) 다른 데이터 유형은 무엇인가? 솔리디티는 정적(static) 유형의 언어이다. 변수의 데이터 유형은 미리 정의되어 있어야 한다. 솔리디티에서 변수의 범위는 함수이다. 즉, 변수 선언 위치와 상관없이 함수 안 어디에서든 사용할 수 있다. 데이터 유형은 다음과 같다. bool(true or false) uint8, uint16, uint24, …, uint256(부호 없는 8, 16, 24, … 비트의 정수) ufixed0x8, ufixed0x16, …, ufixed0x256(부호 없는 실수) fixed0x8, fixed0x16, …, fixed0x256(부호 있는 실수) address(16진수 할당, 최대 20바이트 저장. 이더리움의 주소 제공.) balance와 send 속성 제공. balance는 계정의 잔액을 확인하고, send는 주소로 이더를 송금하는 데에 사용한다. 배열 솔리디티는 일반 및 바이트 배열을 모두 지원하며, 정적 배열 및 동적 배열, 다차원 배열을 지원한다. 일반 배열은 다음과 같이 사용할 수 있다. 1234567891011121314151617contract sample &#123; // 동적 배열 // 배열 리터럴이 보일 때마다 새로운 배열 생성 // 배열 리터럴이 명시되어 있으면 스토리지에 저장되고, 함수 내부에서 발견되면 메모리에 저장된다. int[] myArray = [0, 0]; function sample(uint index, int value) &#123; myArray[index] = value; // myArray2는 myArray의 포인터를 저장! int[] myArray2 = myArray; // 메모리 내 고정된 크기의 배열 uint24[3] memory myArray3 = [1, 2, 99999]; // myArray4에 메모리에 있는 값을 스토리지에 할당할 수 없으므로 예외가 발생한다. // memory를 이용, 메모리에 할당해 주어야 에러가 없다. uint8[2] myArray4 = [1, 2]; &#125;&#125; 책에 오류와 이해되지 않는 부분이 많아 이 블로그를 참고했다. 문자열 문자열의 길이는 언제나 동적으로 할당된다. bytes 원시 문자열(raw string)을 만드는 데 사용된다. string UTF-8 문자열을 만드는 데 사용된다. 123456789101112131415161718192021222324252627282930contract sample &#123; // 문자열 리터럴이 있으므로 스토리지에 저장 string myString = &quot;&quot;; // 문자열 리터럴이 없어서 myRawString은 memory에 있다. bytes myRawString; function sample(string initString, bytes rawStringInit) &#123; // 스토리지 myString = initString; // myString2에 myString의 포인터를 저장 string myString2 = myString // myString3은 메모리 내의 문자열 string memory myString3 = &quot;ABCDE&quot;; // 길이 및 내용 변경 // myString3은 메모리에 위치해서 에러 X myString3 = &quot;XYZ&quot;; myRawString = rawStringInit; // myRawString의 길이 증가 myRawString.length++; // 메모리에 있는 &quot;Example&quot;을 스토리지의 myString에 저장하려 해서 에러 발생 string myString4 = &quot;Example&quot;; // 메모리에 있는 매개 변수(initString)을 스토리지의 myString5에 저장하려 해서 에러 발생 string myString5 = initString; &#125;&#125; ✯ 이 포스트의 모든 내용은 이더리움을 활용한 블록체인 프로젝트 구축(에이콘) 책을 참고하여 작성되었습니다.","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"문법","slug":"문법","permalink":"https://d2fault.github.io/tags/%EB%AC%B8%EB%B2%95/"},{"name":"Ethereum","slug":"Ethereum","permalink":"https://d2fault.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"https://d2fault.github.io/tags/Solidity/"}]},{"title":"[Ethereum] 이더리움의 이해(2)","slug":"20180316-about-ethereum-2","date":"2018-03-16T04:30:05.000Z","updated":"2021-03-04T05:31:55.918Z","comments":true,"path":"2018/03/16/20180316-about-ethereum-2/","link":"","permalink":"https://d2fault.github.io/2018/03/16/20180316-about-ethereum-2/","excerpt":"","text":"geth geth[1]는 이더리움, 위스퍼, 스웜 노드를 구현한 것이며, go 언어로 작성된 CLI 애플리케이션이다. 이 기능을 묶은 이유는 하나의 DApp처럼 보일 수 있게 할 뿐만 아니라, 하나의 노드를 통해 클라이언트가 세 개의 DApp에 접근할 수 있기 때문이다. geth 설치 - Ubuntu apt을 이용하여 설치하는 것을 권장한다. 다음의 명령어를 터미널에서 실행해 보자. 1234sudo apt install software-properties-commonsudo add-apt-repository -y ppa:ethereum/ethereumsudo apt updatesudo apt install ethereum JSON-RPC 및 자바스크립트 콘솔 geth는 다른 애플리케이션이 통신할 수 있도록 JSON-RPC API를 HTTP, 웹소켓, 다른 프로토콜 등으로 제공한다. geth는 자바스크립트 API를 이용, 프로그래밍적으로 상호작용할 수 있도록 대화식 자바스크립트 콘솔을 제공한다. 대화식 콘솔은 IPC를 통한 JSON-RPC를 사용하여 geth와 통신한다. 메인 네트워크 연결 이더리움 네트워크의 노드들은 기본적으로 30303 포트를 사용한다. 그러나 다른 포트 번호를 사용해도 리스닝에는 문제가 없다. geth 명령어만 실행하면 메인넷 네트워크에 연결할 수 있다. 1geth --datadir &quot;/users/packt/ethereum&quot; --networkid 1 --datadir 옵션은 블록체인을 저장할 경로를 지정할 때 사용한다. 만약 지정하지 않는다면, 기본 경로는 $HOME/.ethereum이다. --networkid는 네트워크 ID를 지정할 때 사용한다. 1은 메인넷 네트워크의 ID이다. 설정하지 않으면 default 값으로 1을 사용한다. 개인 네트워크 생성 개인 네트워크 생성은 랜덤 네트워크 ID를 지정하면 된다. geth는 로그와 디버깅을 위한 여러 플래그를 제공한다. 따라서 개인 네트워크 대신, --dev 플래그를 사용하면 다양한 디버깅 킻 로그 플래그가 활성화된 개인 네트워크가 실행된다. 계정 생성 geth를 통해 계정을 만들 수 있다. 아래 명령어를 실행해 보자. 1geth account new 계정 리스트는 다음의 명령어로 볼 수 있다. 1geth account list 채굴 geth는 기본적으로 채굴을 시작하지 않는다. --mine 옵션을 제공해야 채굴을 시작한다. 그 외에도 몇 가지 다른 옵션이 있다. 1geth --mine --minerthreads 16 --etherbase &#x27;489b4e22aab35053ecd393b9fc35f4flde7b194&#x27; --unlock &#x27;489b4e22aab35053ecd393b9fc35f4flde7b194&#x27; 해싱을 위해 사용하기 위한 총 스레드 수를 지정하기 위해서는 minerthreads 옵션을 사용한다. default 값은 8이다. etherbase는 채굴을 통한 보상을 지급할 계정이다. 기본적으로 계정은 암호화되어 있기 때문에, 계정 내 이더에 접근하기 위해 계정과 연관된 개인 키를 사용해 복호화한다. unlock 옵션을 사용해 하나 이상의 계정을 잠금 해제할 수 있으며, 다수의 주소는 콤마를 이용해 분리한 후 제공하면 된다. 빠른 동기화 빠른 동기화는 전체 블록 다운로드 대신 블록 헤더, 트랜젝션 확인, 최신 상태의 DB만 받는다. 자세한 내용은 이 링크를 참고하자. 이더리움 지갑 이더리움 지갑은 계정 생성, 이더 송금, 컨트랙트 배포, 컨트랙트 함수 호출 등 다양한 일을 할 수 있는 이더리움 UI 클라이언트이다. 이 지갑은 geth를 번들로 포함한다. 이더리움 지갑은 IPC를 사용, geth와 통신하며 geth는 파일 기반의 IPC를 지원한다. ✯ 이 포스트의 모든 내용은 이더리움을 활용한 블록체인 프로젝트 구축(에이콘) 책을 참고하여 작성되었습니다. go-ethereum이라고도 불림 ↩︎","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"https://d2fault.github.io/tags/Ethereum/"},{"name":"설치","slug":"설치","permalink":"https://d2fault.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"geth","slug":"geth","permalink":"https://d2fault.github.io/tags/geth/"}]},{"title":"[Ethereum] 이더리움의 이해(1)","slug":"20180316-about-ethereum-1","date":"2018-03-16T00:45:18.000Z","updated":"2021-03-04T05:31:55.918Z","comments":true,"path":"2018/03/16/20180316-about-ethereum-1/","link":"","permalink":"https://d2fault.github.io/2018/03/16/20180316-about-ethereum-1/","excerpt":"","text":"개요 이더리움은 DApp을 배포할 수 있는 탈중앙화 플랫폼이다. 스마트 컨트랙트[1]는 솔리디티로 작성된다. 이더리움은 이더라는 내부 화폐를 사용하며, 이더는 컨트랙트를 배포하거나 함수를 호출할 때 쓰인다. 사용자 계정과 스마트 컨트랙트 모두 이더를 보유할 수 있다. 스마트 컨트랙트의 메소드는 트랜잭션으로 호출되거나, 다른 메소드로부터 호출된다. 네트워크에는 일반 노드와 채굴자 노드 총 두 가지가 존재한다. 블록체인 사본만을 가진 노드가 일반 노드이며, 채굴자는 블록을 채굴하며 체인을 생성한다. 이더리움 계정 이더리움은 다양한 매개변수를 가지는 타원곡선암호[2]를 사용하여 비대칭 암호 키를 생성한다. 매개변수는 속도와 보안성을 조절하는 데 사용되며, 이더리움은 secp256k1을 사용한다. 이더리움의 개인 키와 공개 키는 256bit의 숫자이다. 모든 계정은 주소로 표현된다. 공개 키를 이용해 주소를 만드는 순서는 다음과 같다. 공개 키의 keccak-256 해시 생성 앞 96비트(12바이트)를 버린다. 주소를 16진수 문자열로 인코딩한다. 최종적으로 남은 40개 문자의 바이트 스트링이 유저의 계정 주소가 된다. 트랜잭션 트랜잭션은 하나의 서명된 데이터 패키지이다. 이더를 한 계정에서 다른 계정으로, 혹은 컨트랙트로 보내거나 컨트랙트의 함수 호출 및 새 컨트랙트를 배포할 때의 서명으로 쓰인다. 트랜잭션은 ECC를 기반으로 하는 디지털 서명 알고리즘인 ECDSA를 이용하여 서명된다. 트랜잭션은 메시지 수신자, 송신자를 식별하고 의도를 증명하기 위한 서명, 전송할 이더의 양, 트랜잭션 실행을 위해 허용되는 최대 연산 단계, 트랜잭션 송신자가 각 연산 단계를 위해 지불할 의사가 있는 비용을 포함한다. 이더리움 가상 머신 이더리움 가상 머신(EVM)은 이더리움 스마트 컨트랙트 바이트 코드 실행 환경이다. 네트워크 내 모든 노드는 EVM을 구동한다. 가스 가스는 계산 단계의 측정 단위이다. 모든 트랜잭션은 가스 한도와 가스당 수수료를 포함해야 한다. 채굴자는 가스 가격을 결정하고, 이 가격보다 낮은 경우 트랜잭션 포함을 거부할 수 있다. 피어 검색 노드는 네트워크 내의 다른 노드와 연결되어 있어야 한다. 그러나 네트워크에 있는 노드 모두와 연결될 필요는 없다. 중앙 서버가 없는 블록체인에서는 네트워크 내 다른 노드를 찾는 알고리즘을 사용한다. 이더리움은 Kadelima 프로토콜에 기반을 둔 자체적인 노드 검색 프로토콜을 가지고 있다. 노드 검색 프로토콜에는 부트스트랩 노드가 있다. 부트스트랩 노드는 일정 기간 동안 연결됐던 모든 노드의 목록을 유지한다. 피어가 이더리움 네트워크에 연결할 때 마지막 지정 시간 내에 연결된 목록이 있는 부트스트랩 노드에 먼저 연결한다. 이후 다른 피어를 연결하고, 동기화한다. 위스퍼 탈중앙화된 커뮤니케이션 프로토콜이다. 노드가 네트워크 내에서 통신할 수 있게 한다. 브로드캐스팅, P2P, 암호화된 메시지 등을 지원한다. 단, 대량의 데이터를 전송하도록 설계되어 있지는 않다. 스웜 탈중앙화된 스토리지 플랫폼이다. 스웜은 파일코인과 유사하지만, 기술과 인센티브에서 차이가 있다. 파일 코인은 스토어에 패널티를 부과하지 않지만 스웜은 패널티를 줘서 파일 가용성을 높인다. ✯ 이 포스트의 모든 내용은 이더리움을 활용한 블록체인 프로젝트 구축(에이콘) 책을 참고하여 작성되었습니다. 다운타임, 검열, 사기, 간섭 없이 코드 그대로 정확히 실행되는 프로그램 ↩︎ ECC, Elliptic Curve Cryptography ↩︎","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"https://d2fault.github.io/tags/Ethereum/"}]},{"title":"[Blockchain] 블록체인 실습 준비하기(3) - Docker 설치","slug":"20180315-preparation-for-blockchain-practice","date":"2018-03-15T04:54:21.000Z","updated":"2021-03-04T05:31:55.917Z","comments":true,"path":"2018/03/15/20180315-preparation-for-blockchain-practice/","link":"","permalink":"https://d2fault.github.io/2018/03/15/20180315-preparation-for-blockchain-practice/","excerpt":"","text":"Docker 설치 아래처럼 하면 된다고 한다. 1curl -fsSL https://get.docker.com/ | sudo sh 도커를 설치할 땐 이 블로그의 도움을 아주 많이 받았다. 그런데 sudo 권한은 왜 제대로 설정이 안 되는지 모르겠다. (docker 재시작해도 안 됨.) Docker official GPG key 설정 1234567891011curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# Verify that the key fingerprint is 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88.sudo apt-key fingerprint 0EBFCD88sudo add-apt-repository \\ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot; sudo apt update &amp;&amp; sudo apt install docker-ce -y# Verify that Docker CE or Docker EE is installed correctly by running the hello-world image 사용자에게 도커 명령어 처리 권한 부여는 아래와 같이 하면 된다. 1sudo usermod -a -G docker 유저이름 설치 확인은 이렇게! 1sudo docker run hello-world Docker Compose 설치 주의: 버전에 따라 링크 url이 바뀝니다. 최신 버전 설치는 이 링크를 참고해 주세요. 12sudo curl -L https://github.com/docker/compose/releases/download/1.22.0-rc2/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-compose 다음 명령어로 버전 확인이 가능하다. 1docker-compose --version 업그레이드와 삭제 과정은 소제목 링크를 확인하면 된다.","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"https://d2fault.github.io/tags/Ethereum/"},{"name":"Hyperledger","slug":"Hyperledger","permalink":"https://d2fault.github.io/tags/Hyperledger/"},{"name":"개발환경","slug":"개발환경","permalink":"https://d2fault.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD/"},{"name":"설치","slug":"설치","permalink":"https://d2fault.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"Docker","slug":"Docker","permalink":"https://d2fault.github.io/tags/Docker/"}]},{"title":"[Blockchain] 블록체인 실습 준비하기(2) - pip, python 설치","slug":"20180313-preparation-for-blockchain-practice","date":"2018-03-13T00:45:03.000Z","updated":"2021-03-04T05:31:55.915Z","comments":true,"path":"2018/03/13/20180313-preparation-for-blockchain-practice/","link":"","permalink":"https://d2fault.github.io/2018/03/13/20180313-preparation-for-blockchain-practice/","excerpt":"","text":"pip 설치하기 아래의 명령어를 실행하면 패러럴즈 가상 우분투 환경에 pip를 설치할 수 있다고 한다. 1curl https://bootstrap.pypa.io/get-pip.py | python 한 번에 제대로 되면 내가 아니지! 역시나 문제가 생겼다. 설치가 안 되고 아래의 에러를 계속 뿜는 것이다. -_- 123456789101112131415161718192021Exception:Traceback (most recent call last): File &quot;/tmp/tmp64Oaow/pip.zip/pip/basecommand.py&quot;, line 215, in main status = self.run(options, args) File &quot;/tmp/tmp64Oaow/pip.zip/pip/commands/install.py&quot;, line 342, in run prefix=options.prefix_path, File &quot;/tmp/tmp64Oaow/pip.zip/pip/req/req_set.py&quot;, line 784, in install **kwargs File &quot;/tmp/tmp64Oaow/pip.zip/pip/req/req_install.py&quot;, line 851, in install self.move_wheel_files(self.source_dir, root=root, prefix=prefix) File &quot;/tmp/tmp64Oaow/pip.zip/pip/req/req_install.py&quot;, line 1064, in move_wheel_files isolated=self.isolated, File &quot;/tmp/tmp64Oaow/pip.zip/pip/wheel.py&quot;, line 345, in move_wheel_files clobber(source, lib_dir, True) File &quot;/tmp/tmp64Oaow/pip.zip/pip/wheel.py&quot;, line 316, in clobber ensure_dir(destdir) File &quot;/tmp/tmp64Oaow/pip.zip/pip/utils/__init__.py&quot;, line 83, in ensure_dir os.makedirs(path) File &quot;/usr/lib/python2.7/os.py&quot;, line 157, in makedirs mkdir(name, mode)OSError: [Errno 13] Permission denied: &#x27;/usr/local/lib/python2.7/dist-packages/pip-9.0.1.dist-info&#x27; 역시 답은 구글링~ 스택오버플로에서 이 링크를 보았고, 그대로 설정을 바꿨다. sudo nano /etc/apt/sources.list명령어를 실행한 다음, 편집창이 열리면(nano 대신 atom을 사용해도 된다. 취향 차이!) http://archive.ubuntu.com/ubuntu url을 넣고 저장 후 편집을 종료한다. 그리고 curl https://bootstrap.pypa.io/get-pip.py | python 명령어를 실행하면? 여전히 안 된다. ^^ 왜인지 이해는 안 되지만, 1sudo apt install python-pip 이 명령어를 실행해야만 pip가 설치됐다. 제대로 설치되었는지 궁금하다면? pip --version을 실행해 보자. 아래 코드로 pip 업그레이드를 할 수 있다. 1sudo apt upgrade python-pip behave 설치 왜 하는 건지 의문인데 하라니까 했다. 아래의 명령어 실행 고고. 1234sudo pip install behave nose docker-composesudo apt install python-dev libssl-dev -ysudo pip install -I flask==0.10.1 python-dateutil==2.2 pytz==2014.3 pyyaml==3.10 couchdb==1.0 flask-cors==2.0.1 requests==2.4.3 pyOpenSSL==16.2.0 pysha3==1.0b1 grpcio==1.0.4sudo pip install urllib3 ndg-httpsclient pyasn1 ecdsa python-slugify grpcio-tools jinja2 b3j0f.aop six","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"https://d2fault.github.io/tags/Ethereum/"},{"name":"Hyperledger","slug":"Hyperledger","permalink":"https://d2fault.github.io/tags/Hyperledger/"},{"name":"개발환경","slug":"개발환경","permalink":"https://d2fault.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD/"},{"name":"설치","slug":"설치","permalink":"https://d2fault.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"Python","slug":"Python","permalink":"https://d2fault.github.io/tags/Python/"}]},{"title":"[Blockchain] 블록체인 실습 준비하기(1) - Ubuntu 16.04.4 및 기타 설치","slug":"20180309-preparation-for-blockchain-practice","date":"2018-03-09T06:37:24.000Z","updated":"2021-03-04T05:31:55.915Z","comments":true,"path":"2018/03/09/20180309-preparation-for-blockchain-practice/","link":"","permalink":"https://d2fault.github.io/2018/03/09/20180309-preparation-for-blockchain-practice/","excerpt":"","text":"개요 이더리움과 하이퍼렛저 페브릭을 사용해야만 하는 상황이 되었다. 미래의 나는 분명 설치 과정을 다시 찾아보고 있을 것이기 때문에 내 입맛에 맞게 정리해 본다. ^^; 역시 글은 나를 위해 쓰는 것이고요! 블록체인 전반적인 내용과 하이퍼레저 관련 내용은 이 파일에 잘 정리되어 있다. 구글링하다가 냉큼 저장했다. 박세열씨(누군지 모르지만)가 만드신 파일인 것 같은데, 감사합니다! Ubuntu 16.04.4 Ubuntu는(운영체제가 OSX이기에 가상 머신으로 Parallels 사용) 이 블로그의 도움으로 무사히 설치 완료했다. 굳이 포스팅할 이유가 없을 것 같아 링크 첨부! Desktop 대신 Server로 설치하려다가, 어차피 Docker를 올릴 거라 Desktop으로 설치했다. curl 설치하기 1sudo apt install curl Atom 설치하기 아래의 명령어들로 간단히 끝난다. 2018.05.30 기준 최신 버전은 1.27.1이다. 123456# wget으로 설치 파일 다운로드# 최신 버전은 https://atom.io에서 확인 가능하다.wget https://github.com/atom/atom/releases/download/v1.27.1/atom-amd64.deb# 다운받은 파일이 있는 폴더로 이동해서 아래 명령어 실행sudo dpkg -i atom-amd64.deb Git client 설치 12sudo apt updatesudo apt install git GO 언어 설치 2018.05.30 기준 최신 버전은 1.10.2이다. 최신 버전 확인은 공식 홈페이지에서 할 수 있다. 123cd /usr/localsudo wget https://storage.googleapis.com/golang/go1.10.2.linux-amd64.tar.gzsudo tar -C /usr/local -xzf go1.10.2.linux-amd64.tar.gz GOPATH를 설정해야 한다. GOPATH는 Go의 워크스페이스같은 개념이다. 외부 라이브러리를 받아오거나, 소스가 저장된다. 123456789101112# 사용자 계정으로 이동cd /home/사용자계정명# GO Workspace 설정mkdir -vp go/&#123;src,pkg,bin&#125;# Atom 에디터로 파일 생성sudo atom $HOME/.profile# 아래 스크립트 넣고 저장# export PATH=$PATH:/usr/local/go/bin# 아래 명령어 실행export GOPATH=/home/사용자계정명/go# $HOME 위치에서 아래 스크립트 실행source .profile expert 문장이 로그인/로그아웃 이후에도 사용될 수 있도록 1sudo atom /etc/profile 을 실행한 후, 맨 마지막 줄에 다음의 스크립트를 적고 저장한다. 1234# GOPATH 설정export PATH=$PATH:/usr/local/go/binexport GOPATH=$HOME/goexport PATH=$PATH:$GOPATH/bin GOPATH는 다음과 같이 확인할 수 있다. 123# GOPATH 확인go env GOPATH# /home/사용자계정명/go로 나와야 정상 GO 설치 확인하기 Go lang이 제대로 설치되었는지 확인해 보자. 12cd $GOPATH/src &amp;&amp; mkdir helloatom hello.go 1 라인은 프로젝트 폴더에 들어가서 hello라는 디렉토리를 만들겠다는 코드이다. 2 라인은 hello.go 파일을 생성하고, atom 편집기로 편집하겠다는 의미이다. atom 편집기에 아래 코드를 넣고 저장해 보자. 12345package mainimport &quot;fmt&quot;func main() &#123; fmt.Printf(&quot;hello, world\\n&quot;)&#125; 빌드 후 실행해 보자. 12go build./hello hello, world 텍스트가 나오면 성공이다.","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"https://d2fault.github.io/tags/Ethereum/"},{"name":"Hyperledger","slug":"Hyperledger","permalink":"https://d2fault.github.io/tags/Hyperledger/"},{"name":"GO","slug":"GO","permalink":"https://d2fault.github.io/tags/GO/"},{"name":"개발환경","slug":"개발환경","permalink":"https://d2fault.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD/"},{"name":"설치","slug":"설치","permalink":"https://d2fault.github.io/tags/%EC%84%A4%EC%B9%98/"}]},{"title":"[Blockchain] 외환송금 핀테크 스타트업 - 가상화폐 규제와 위기","slug":"20180308-fintech-foregin-exchange-transactions-by-blockchain","date":"2018-03-08T04:22:50.000Z","updated":"2021-03-04T05:31:55.915Z","comments":true,"path":"2018/03/08/20180308-fintech-foregin-exchange-transactions-by-blockchain/","link":"","permalink":"https://d2fault.github.io/2018/03/08/20180308-fintech-foregin-exchange-transactions-by-blockchain/","excerpt":"","text":"개요 2017년, 정부는 소액해외송금업자를 모집하기 위한 법률을 개정한다.[1] 법률 개정은 IT 강국 대한민국의 기술력으로 핀테크를 리딩하겠단 의지로 보였다. 핀테크 스타트업은 법안 개정을 반겼고, 수혜를 기대했다. 그러나 기대도 잠시, 가상화폐가 뜨겁게 달아오름과 동시에 피해자가 속출했다. 정부는 과열을 막기 위해 가상화폐 신규 계좌 생성을 막았으며, 이 물결은 가상화폐 기반 해외송금 스타트업에게 파도가 되어 밀려왔다. 결국 2018년, '가상화폐 기반 해외송금 서비스’는 모두 죽어 버렸다. 17.07.15 소액해외송금업 등록 시작 조건: 자기 자본 20억 이상, 부채 비율 200% 이내, 한국은행과 외한 전선망이 연결되어야 하며, 외환 전문 인력과 전산 설비를 갖춰야 한다. 해외송금 사업의 당국 허가 必 송금 방식은 풀링, 페어링, 네팅, 블록체인 등 제한 없음 (기존 은행에서 사용하던 방식은 스위프트) 송금 한도: 건당 $3,000 이하, 연간 누계 $20,000까지 2018년 초, 정부의 가상통화 규제 소액해외송금 등록 시 업무 취급 범위에 가상화폐가 포함될 경우 인가 받기가 어려워짐 -&gt; 가상통화를 이용한 해외 송금 서비스 급감(핀테크 지원센터에 외환송금으로 등록된 스타트업: 2017 2분기 40여곳 -&gt; 2018 1분기 8곳) -&gt; 그마저도 가상화폐를 버렸다. 규제 이후 스타트업 상황 와이어바알리 해외 송금 서비스 제공 중 블록체인 대신 POLi Payments 이용하여 송금 코인플러그 KB국민은행과 함께 블록체인 해외송금 서비스 개발에 착수했으나, 정부 규제로 수면 위로 나오지 못함 블루팬 블록체인, 가상화폐를 이용한 해외 송금 서비스 홈페이지는 존재하나 실제 송금을 위한 로그인 및 회원가입 버튼을 찾을 수 없음 센트비 가상화폐 기반의 해외 송금 서비스였으나, 규제 이후 업무 취급 범위 수정(가상화폐 방식을 제외하고, 송금대행업체와의 계약을 통한 해외송금) 스트리미 스트림와이어(블록체인 해외 송금 솔루션) 2015년부터 개발 중이라 밝혔으나, 공개 X 옴니뱅크 2017년 이후 기사 X, 홈페이지 X 머니택 2017년 이후 기사 X, 홈페이지 존재하나 정상 동작 X 서비스명 '텔레트랜스퍼’로 핑거에서 라이선스를 확보(2017년 9월 27일)하여 서비스 중임 프리펀딩 방식의 해외 송금 서비스 앱스토어와 구글 플레이스토어에서 다운할 수 있음 문의 사항: rele@finger.co.kr 혹은 https://www.facebook.com/rele.vn 가온페이 공개된 정보 X(기사 X, 홈페이지 X) 마치며 언제부턴가 정부에서는 스타트업, 벤처, 창업을 독려했다. 덕분에 실제로 창업에 뛰어든 개발자들도 심심찮게 볼 수 있었다. 그러나 결론은? 채 일 년도 안 되어 바뀐 규제로 몇 년을 투자하여 개발한 서비스는 세상에 나오기도 전에, 혹은 나오자마자 사라져야만 했다. 자국민의 자산 보호, 좋은 명목이다. 보호해야 마땅하다. 그러나 '금지’가 최선은 아닐 것이다. 가상화폐가 곧 위험은 아닌데 말이다. 오히려 나는 이런 정부의 강력한 규제가 더 큰 불안감을 조성하는 것으로 보인다. 눈앞의 나무를 보기보다 전체적인 숲을 보아야 할 것이다. 코인은 위험하니까 송금 서비스도 안 된다는 논리는 무슨 논리인지… 내가 보기에 코인은 그저 송금을 위한 수단으로밖에 보이지 않는다. 투기가 아닌 수단! 수단!!! 아마 송금은 이런 방식으로 진행될 것 같다. 만약 30만원을 달러로 송금한다면 30만 원 만큼의 코인을 구매하고, 이 코인을 미국으로 보낸다. 미국에서는 그 코인을 팔아서 달러로 바꾸겠지? 코인은 등락이 심하니까, 분명 개발자들은 이 폭을 완충시키는 코드를 작성했을 것이다. 자문은 전문가에게 구했을 거고… 대부분의 해외송금 스타트업에 경제 전문가가 있는 이유도 이 때문이리라. 고가와 저가의 평균가보다 조금 높은 금액으로 기준을 책정, 뭐 이런 방식을 택하지 않을까? 주식이나 펀드에서 분할로 매수하는 것과 같이… 송금할 때 코인을 실시간으로 구매하는 것이 아니고, 낮은 가격에서 대량으로 코인을 구매한 다음에 중간 정도의 가격을 유저에게 제시하는? 알고리즘은 대충 그런 방식이겠지, 뭐. 수정된 내용의 대부분이 제2장에 포함되어 있음 ↩︎","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"핀테크","slug":"핀테크","permalink":"https://d2fault.github.io/tags/%ED%95%80%ED%85%8C%ED%81%AC/"},{"name":"스타트업","slug":"스타트업","permalink":"https://d2fault.github.io/tags/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85/"},{"name":"코인","slug":"코인","permalink":"https://d2fault.github.io/tags/%EC%BD%94%EC%9D%B8/"}]},{"title":"[Diary] 복싱 다이어리를 만들어야 하나","slug":"20180306-diary","date":"2018-03-06T13:35:31.000Z","updated":"2021-03-04T05:31:55.914Z","comments":true,"path":"2018/03/06/20180306-diary/","link":"","permalink":"https://d2fault.github.io/2018/03/06/20180306-diary/","excerpt":"","text":"근육통 때문에 너무 괴롭다 종아리, 허벅지, 등, 어깨, 팔, 갈비뼈 사이사이의 근육까지 모두 뭉쳐 버렸다. 첫날에 그렇게 굴렀으니 당연한 결과이겠지만, 뭔가 억울하다. 그래도 꽤 오래 운동하긴 했었는데 그게 다 없어졌다는 뜻인 것 같아서. -_- 복싱을 처음 시작했을 때 다이어리를 작성하는 것이 도움이 될 거란 얘길 봤었다. 그래서 지금부터 해 보려고 한다. 복싱 다이어리~! 카테고리를 나눌까 고민도 많이 했지만, 그냥 태그에만 복싱을 넣기로 결정했다. ㅋㅋㅋ 괜히 카테고리 늘리기 싫어서. (블록체인 카테고리도 마음에 안 드는 마당에…) 스트레칭 - 줄넘기 2라운드 - 체력 운동(복근) - 쉐도우복싱 1라운드 - 스피드백 1라운드 - 미트 1라운드 - 샌드백 1라운드 - 쉐도우복싱 2라운드 - 줄넘기 3라운드 - 스트레칭 오늘도 갔다, 복싱! 수요일과 목요일엔 못 간다. 선약 오버야… 왜 운동 시작하니까 평일에 일이 생기는 건데. ㅠㅠ 할 때 훅 해야 근육이 풀리는데… 내일도 근육통에 시달릴 것 같다. 아, 배까지 아프겠네!","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Diary","slug":"Anything/Diary","permalink":"https://d2fault.github.io/categories/Anything/Diary/"}],"tags":[{"name":"일상","slug":"일상","permalink":"https://d2fault.github.io/tags/%EC%9D%BC%EC%83%81/"},{"name":"복싱","slug":"복싱","permalink":"https://d2fault.github.io/tags/%EB%B3%B5%EC%8B%B1/"}]},{"title":"[JavaScript] 자바스크립트의 제어문","slug":"20180306-javascript-statements","date":"2018-03-06T00:07:05.000Z","updated":"2021-03-04T05:31:55.914Z","comments":true,"path":"2018/03/06/20180306-javascript-statements/","link":"","permalink":"https://d2fault.github.io/2018/03/06/20180306-javascript-statements/","excerpt":"","text":"if문 if문은 if (condition) statement1 else statement2으로 사용한다. condition에는 조건이 들어가며, 조건이 성립할 경우 statement1을 수행하고 그렇지 않다면 statement2를 수행한다. 다음 예시를 보자. 123456789if(i == 20180308) &#123; alert(&quot;비투비 정일훈 솔로 데뷔&quot;);&#125;else if(i == 20180319) &#123; alert(&quot;헤헤 내 생일이다&quot;);&#125;else &#123; alert(&quot;덕계못 타파&quot;);&#125; 위의 예시에서는 else if를 사용했는데, if의 조건은 성립하지 않지만 else if의 조건을 성립할 경우 else 대신 수행한다. switch-case문 if문과 비슷하며 다음과 같이 사용할 수 있다. 123456789101112var i = 25switch(i) &#123; case 25: alert(&quot;25&quot;); break; case 35: alert(&quot;35&quot;); break; case 45: alert(&quot;45&quot;); break;&#125; 라인 5, 8, 11에 있는 break문을 넣지 않는다면 break를 만나는 곳까지 쭉 실행하게 된다. 고로, switch-case문에서는 break를 잊지 않도록 조심해야 한다. do-while문 do-while은 종료 조건을 평가하기 전 루프를 실행한다. 루프 본문은 최소 한 번 이상 실행된다. 실제로는 다음과 같이 사용한다. 1234var i = 0;do &#123; i += 2;&#125; while(i &lt; 10); i += 2는 종료 조건인 i &lt; 10을 실행하기 전 먼저 수행된다. while문 while은 조건을 먼저 평가하고 그 이후 루프를 실행한다. 실제 사용은 다음과 같다. 1234var i = 0;while(i &lt; 10) &#123; i += 2;&#125; 이 예제에서는 i &lt; 10일 때에만 i += 2가 실행된다. for문 for문도 평가 후 루프를 실행한다. for문에서는 루프에 들어가기 전 변수를 초기화할 수 있으며, 루프 후의 코드도 지정할 수 있다. 실제 사용은 다음과 같이 한다. 1234var count = 10;for (var i = 0; i&lt; count; i++) &#123; alert(i);&#125; 변수 초기화는 2 라인의 var i = 0이고, 루프 후의 코드는 동일 라인의 i++라고 할 수 있다. 변수 초기화, 조건, 그리고 루프 후의 코드는 생략 가능하다. 만약 다음과 같이 모두를 생략하면 어떻게 될까? 1234var message = &quot;엄청나게 졸리다&quot;;for (;;) &#123; alert(message);&#125; for (;;)는 무한 루프[1]를 의미한다. 이 코드는 무한정 message가 담긴 alert를 띄우게 된다. for-in문 객체의 프로퍼티를 순회하는데 사용하는 엄격한 반복문이다. 문법은 다음과 같다. 123for (변수 in 객체) &#123; 구문&#125; 예제를 보자. 1234var array = [10, 11, 12];for (property in array)&#123; console.log(&quot;name: &quot; + property + &quot;; value: &quot; + array[property]);&#125; 위 코드의 실행 결과는 다음과 같다. 123name: 0; value: 10name: 1; value: 11name: 2; value: 12 ✯ 이 포스트의 모든 내용은 프론트엔드 개발자를 위한 자바스크립트 프로그래밍(인사이트) 책을 참고하여 작성되었습니다. while(1), while(true), for(;;)는 모두 무한 루프이다. ↩︎","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"JavaScript","slug":"Programming/JavaScript","permalink":"https://d2fault.github.io/categories/Programming/JavaScript/"}],"tags":[{"name":"문법","slug":"문법","permalink":"https://d2fault.github.io/tags/%EB%AC%B8%EB%B2%95/"}]},{"title":"[Diary] 복싱 다시 시작","slug":"20180305-diary","date":"2018-03-05T13:31:52.000Z","updated":"2021-03-04T05:31:55.913Z","comments":true,"path":"2018/03/05/20180305-diary/","link":"","permalink":"https://d2fault.github.io/2018/03/05/20180305-diary/","excerpt":"","text":"구르고, 구르고, 구르고… 다이어트를 의도한 건 아닌데 살이 안 빠지면 이상한 수준이다. 아침, 점심 만땅으로 먹고 저녁은 시리얼… 배고파 죽는 줄 알았다. 왜 해가 떴을 때 많이 먹어도 때가 되면 배가 고프지요? 아무튼, 여덟 시 조금 넘어서부터 시작한 복싱[1]은 아홉 시 반이 되어서야 끝났다. 집에는 열 시 넘어서 도착했다. 오랜만에 왔다고 봐주는 건 없었다. 처음으로 운동하다 쥐가 났다. 하필이면 양 허벅지가 동시에 이러기 있어? 쥐쥐쥐쥐쥐![2] 하면서 주저앉았다. ㅋㅋㅋㅋㅋ 스트레칭 - 줄넘기 2라운드 - 마운틴클라이머 1라운드 - 줄넘기 1라운드 - 쉐도우복싱 1라운드 - 미트 1라운드 - 스피드백 - 쉐도우복싱 1라운드 - 버피테스트 1라운드 - 쉐도우복싱 1라운드 - 줄넘기 2라운드 - 스트레칭 하필 사람 많을 때 가서는… 체력 운동 대신이면 뭐 해요! 엄청 힘든데! 죽는 줄 알았는데! 아프다니까 괜찮다는데! 내가 안 괜찮은데![3] 내일 출근은 할 수 있으려나… 무려 서너 달만에 재등록 ↩︎ 소녀시대인 줄… ↩︎ 그래도 뿌듯하고 즐거운 시간이었다 -_- ;; ↩︎","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Diary","slug":"Anything/Diary","permalink":"https://d2fault.github.io/categories/Anything/Diary/"}],"tags":[{"name":"일상","slug":"일상","permalink":"https://d2fault.github.io/tags/%EC%9D%BC%EC%83%81/"},{"name":"복싱","slug":"복싱","permalink":"https://d2fault.github.io/tags/%EB%B3%B5%EC%8B%B1/"}]},{"title":"[JavaScript] 자바스크립트의 연산자","slug":"20180305-javascript-oprator","date":"2018-03-05T02:37:14.000Z","updated":"2021-03-04T05:31:55.914Z","comments":true,"path":"2018/03/05/20180305-javascript-oprator/","link":"","permalink":"https://d2fault.github.io/2018/03/05/20180305-javascript-oprator/","excerpt":"","text":"연산자 ECMAScript의 연산자는 문자열, 숫자, Boolean, 객체까지 데이터를 폭넓게 조작할 수 있다. 증감 연산자 증감 연산자는 C 언어에서 차용한 것이며, 피연산자의 앞과 뒤 어디에나 샤용할 수 있다. ++는 1을 더하고, --는 1을 뺀다. 12345var age = 29;++age; // age = age + 1; 과 동일var count = 20;--count; // count = count - 1; 과 동일 단항 플러스와 단항 마이너스 단항 플러스와 마이너스는 기호를 변수 앞에 써서 나타낸다. 12var num = 25;num = +num; // 여전히 25 단항 플러스를 숫자가 아닌 값에 적용하면 Number()[1]와 동일하게 동작한다. false와 true는 각각 0과 1로 바뀌고, 문자열은 이전 포스팅의 규칙을 따른다. 단항 플러스를 여러 데이터 타입이 적용한 코드는 다음과 같다. 1234567891011121314151617var s1 = &quot;01&quot;;var s2 = &quot;1.1&quot;;var s3 = &quot;z&quot;;var b = false;var f = &quot;1.1&quot;;var o = &#123; valueOf: function() &#123; return -1; &#125;&#125;;s1 = +s1; // 숫자 1s2 = +s2; // 숫자 1.1s3 = +s3; // NaNb = +b // 숫자 0f = +f; // 숫자 1.1 그대로o = +o; // 숫자 -1 단항 마이너스는 보통 수의 부호를 바꾸는 용도로 쓰인다. 1234567891011121314151617var s1 = &quot;01&quot;;var s2 = &quot;1.1&quot;;var s3 = &quot;z&quot;;var b = false;var f = &quot;1.1&quot;;var o = &#123; valueOf: function() &#123; return -1; &#125;&#125;;s1 = -s1; // 숫자 -1s2 = -s2; // 숫자 -1.1s3 = -s3; // NaNb = -b; // 숫자 0f = -f; // -1.1o = -o; // 숫자 1 단항 플러스와 마이너스는 주로 간단한 계산에 사용하지만 변환 용도로도 사용할 수 있다. 이외에 자주 쓰는 연산자 논리 연산자 연산자 의미 !a 논리 NOT a &amp;&amp; b 논리 AND a || b 논리 OR 사칙연산 연산자 의미 a * b 곱셈 a / b 나눗셈 a % b 나머지 a + b 덧셈 a - b 뺄셈 관계 연산자 연산자 의미 a &gt; b 초과 a &lt; b 미만 a &gt;= b 이상 a &lt;= b 이하 a == b, a === b[2] 동일 a != b, a !== b[3] 비동일 ✯ 이 포스트의 모든 내용은 프론트엔드 개발자를 위한 자바스크립트 프로그래밍(인사이트) 책을 참고하여 작성되었습니다. 형 변환 함수이다. ↩︎ ==는 데이터 타입을 변환하고 비교하고, ===는 형 변환 없이 비교. ===의 경우 데이터 타입까지 같아야만 true를 반환. ↩︎ !=는 데이터 타입을 변환하고 비교하고, !==는 형 변환 없이 비교. !==로 비교하는 경우, 데이터 타입만 달라도 true 반환. ↩︎","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"JavaScript","slug":"Programming/JavaScript","permalink":"https://d2fault.github.io/categories/Programming/JavaScript/"}],"tags":[{"name":"문법","slug":"문법","permalink":"https://d2fault.github.io/tags/%EB%AC%B8%EB%B2%95/"}]},{"title":"[JavaScript] 자바스크립트의 문자 리터럴과 객체 타입","slug":"20180305-javascript-string-literal","date":"2018-03-05T01:12:35.000Z","updated":"2021-03-04T05:31:55.914Z","comments":true,"path":"2018/03/05/20180305-javascript-string-literal/","link":"","permalink":"https://d2fault.github.io/2018/03/05/20180305-javascript-string-literal/","excerpt":"","text":"문자 리터럴 아래의 표는 문자 리터럴 중 자주 쓰이는 리터럴을 정리한 것이다. 리터럴 의미 \\n 줄바꿈 \\t 탭 \\b 백스페이스 \\r 캐리지 리턴 \\f 폼 피드 \\ 역슬래시 ', &quot; 작은따옴표, 큰따옴표 \\xnn 16진수 코드 'nn’로 표현한 문자. 'n’은 0부터 f까지의 16진수이다. 문자 리터럴은 문자열 어디에든 쓸 수 있으며, 다음과 같이 한 문자로 취급된다. 12var text = &quot;This is the letter sigma: \\u03a3.&quot;;alert(text.length); // 28 이스케이프 문자를 표현하기 위해 \\u03a3 여섯 글자를 썼지만 문자열 text의 길이[1]는 28이다. 문자열의 성질 ECMAScript에서 변수에 저장된 문자열을 바꾸려면 다음과 같이 기존의 문자열에 새 문자열을 채워야 한다. 12var lang = &quot;정일훈 솔로 앨범 BIG WAVE\\s&quot;lang = lang + &quot;대박 각&quot; 문자열로 변환 값을 문자열로 만들 때에는 toString() 메서드나 String() 함수를 사용할 수 있다. toString()은 값에 해당하는 문자열을 단순 반환한다. 1234var age = 11;var ageAsString = age.toString(); // 문자열 &quot;11&quot;var found = true;var foundAsString = found.toString(); // 문자열 &quot;true&quot; 숫자에서 호출할 때에는 toString()에서 '진법’을 나타내는 매개변수를 하나 사용할 수 있다. toString()은 기본적으로 10진법의 숫자를 반환하는데, 2, 8, 16, 기타 유효한 형식을 반환할 수도 있다. 12345var num = 10;alert(num.toString()); // &quot;10&quot;alert(num.toString(2)); // &quot;1010&quot;alert(num.toString(8)); // &quot;12&quot;alert(num.toString(16)); // &quot;a&quot; 만약 toString() 메서드를 호출할 값이 null이나 undefined일 가능성이 있다면 String()을 사용해도 된다. String()은 값의 타입에 관계없이 항상 문자열을 반환하는 형 변환 함수이다. String() 함수는 null은 &quot;null&quot;로, undefined는 &quot;undefined&quot;로 반환한다. 객체 타입 객체는 다음과 같이 만들 수 있다. 1var o = new Object(); Object 타입의 인스턴스는 Object 타입의 프로퍼티와 메서드를 모두 상속한다. ✯ 이 포스트의 모든 내용은 프론트엔드 개발자를 위한 자바스크립트 프로그래밍(인사이트) 책을 참고하여 작성되었습니다. 문자열의 길이는 length로 구할 수 있다. length는 숫자 문자열에 포함된 16비트 문자의 개수를 반환한다. 만약 문자열에 2바이트 문자가 들어 있다면 length 프로퍼티가 정확히 반환하지 못할 수도 있다. ↩︎","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"JavaScript","slug":"Programming/JavaScript","permalink":"https://d2fault.github.io/categories/Programming/JavaScript/"}],"tags":[{"name":"문법","slug":"문법","permalink":"https://d2fault.github.io/tags/%EB%AC%B8%EB%B2%95/"}]},{"title":"[JavaScript] 자바스크립트의 숫자 타입","slug":"20180228-javascript-number-type","date":"2018-02-28T07:53:25.000Z","updated":"2021-03-04T05:31:55.913Z","comments":true,"path":"2018/02/28/20180228-javascript-number-type/","link":"","permalink":"https://d2fault.github.io/2018/02/28/20180228-javascript-number-type/","excerpt":"","text":"숫자 타입 가장 기본적인 숫자 리터럴 형식은 10진법이다. 1var intNum = 7; // 정수 정수는 8진수[1]나 16진수로도 초기화할 수 있다. 단, 8진수 리터럴의 경우 첫 숫자가 반드시 0이어야 하며 16진수 리터럴의 경우 첫 두 문자에 반드시 0x를 써야 한다. 12var octalNum = 070 // 8진법으로 쓴 56var hexNum = 0xA // 16진수로 쓴 10 8진수, 16진수와는 상관없이 실제 계산할 때에는 10진수로 변환하여 계산한다. 부동소수점 다음과 같이 사용할 수 있다. 123var floatNum1 = 1.1;var floatNum2 = 3.24;var floatNum3 = .7; // 유효하나 권장하지 않는다. 부동소수점 숫자를 저장할 때에는 정수 저장에 비해 메모리를 두 배로 소모한다. 만약 소수점 뒤에 숫자가 없다면 해당 숫자는 정수로 변환된다. 굉장히 크거나 작은 숫자를 표기할 때에는 'e-표기법[2]’을 쓴다. 이 표기법은 e 앞의 숫자에 10을 e 뒤의 숫자만큼 곱하는 것이다. 31,250,000은 var floatNum = 3.125e7;로 표기할 수 있으며, 0.0000003은 var floatnum = 3e-7;로 표기할 수 있다. 그러나 부동소수점 숫자는 사칙 연산에 있어 부정확하다. 예를 들어, 0.1과 0.2를 더하면 0.30000000000000004를 반환한다. 고로 다음의 코드와 같은 형식을 사용해서는 안 된다. 123if(a + b == 0.3) &#123; // 이렇게 작성하면 안 된다. alert(&quot;0.3!&quot;);&#125; 숫자 범위 ECMAScript로 표현할 수 있는 최솟값은 Number 객체의 MIN_VALUE 프로퍼티(Number.MIN_VALUE)에 저장된다. 이 값은 브라우저마다 다르지만 보통 5e-324이다. 최댓값은 MAX_VALUE 프로퍼티에 저장되며, 보통 1.7976931348623157e+308이다. 계산 결과가 범위를 벗어날 때에는 양수는 Infinity로, 음수는 -Infinity로 변환된다. 만약, 특정 변수가 유한한 숫자임을 확인하고 싶다면 다음과 같이 사용하면 된다. 12var result = Number.MAX_VALUE + Number.MAX_VALUE;alert(isFinite(result)); // false 드문 경우이긴 하나, 굉장히 크거나 작은 숫자를 계산할 때에는 반드시 모니터링해야 한다. NaN 숫자형 값 중 NaN[3]이란 특별한 값이 있다. 숫자를 반환할 것으로 의도한 조작이 실패했을 때 반환하는 값이다. ECMAScript에서는 숫자를 0으로 나누려 할 때 NaN을 반환[4]한다. NaN에는 몇 가지 특징이 있다. NaN이 포함된 조작(NaN/10 등의 조작)은 항상 NaN을 반환한다. NaN은 어떤 값과도 일치하지 않는다. alert(NaN == NaN);의 결과는 false이다. 때문에 ECMAScript에서는 isNaN() 함수를 제공한다. 1234alert(isNaN(NaN)); // truealert(isNaN(10)); // false: 10은 숫자.alert(isNaN(&quot;blue&quot;)) // true: &quot;blue&quot;를 숫자로 바꿀 수 없다.alert(isNaN(true)); // false: 숫자 1로 바꿀 수 있다. 숫자 변환 함수 Number(), parseInt(), parseFloat()는 숫자가 아닌 값을 숫자로 바꾼다. Number() boolean 값은 1과 0(true, false)으로 바꿔 반환한다. 정수는 정수로 반환한다. null은 0으로 반환한다. undefined는 NaN으로 반환한다. 매개변수로 문자열을 넘겼다면 문자열 구성이 모두 숫자 -&gt; 숫자 반환 부동소수점 -&gt; 앞의 정수만 반환 문자열이 16진수 -&gt; 해당하는 10진수 반환 빈 문자열 -&gt; 0 반환 이외의 경우 -&gt; NaN 반환 1234var num1 = Number(&quot;Hello World&quot;); // NaNvar num2 = Number(&quot;&quot;); // 0var num3 = Number(&quot;000011&quot;); // 11var num4 = Number(true); // 1 parseInt() 첫 문자가 숫자라면 10, 8, 16진수를 인식하고 그에 맞게 변환한다. 만약 숫자+문자의 형태라면, 앞의 숫자만 반환한다. 123456var num1 = parseInt(&quot;7BTOB&quot;); // 7var num2 = parseInt(&quot;&quot;); // NaNvar num3 = parseInt(&quot;0xA&quot;); // 16진수 10var num4 = parseInt(22.5); // 22var num5 = parseInt(&quot;70&quot;); // 70var num6 = parseInt(&quot;0xf&quot;); // 16진수 15 숫자형의 형식이 다양해 혼란을 야기할 수 있으므로 parseInt()에는 진법을 나타내는 두 번째 매개변수를 넘길 수 있다. 만약 파싱하려는 값이 16진수임을 알고 있다면 var num = parseInt(&quot;0xAF&quot;, 16)[5]과 같이 16진수임을 명확하게 알릴 수 있다. parseFloat() 이 함수는 문자열에서 잘못된 부동소수점 숫자를 만날 때까지 파싱한다. 예를 들어, &quot;12.3.21&quot;을 넘길 경우 12.3만 반환한다. 예시는 다음과 같다. 123456var num1 = parseFloat(&quot;7BTOB&quot;); // 7var num2 = parseFloat(&quot;0xA&quot;); // 0var num3 = parseFloat(&quot;22.5&quot;); // 22.5var num4 = parseFloat(&quot;12.3.21&quot;); // 12.3var num5 = parseFloat(&quot;03.21&quot;); // 3.21var num6 = parseFloat(&quot;3.125e7&quot;); // 31250000 ✯ 이 포스트의 모든 내용은 프론트엔드 개발자를 위한 자바스크립트 프로그래밍(인사이트) 책을 참고하여 작성되었습니다. 스트릭트 모드에서는 8진법 리터럴을 허용하지 않아 문법 에러가 발생한다. ↩︎ 지수 표기법 ↩︎ Not a Number ↩︎ 다른 프로그래밍 언어에서는 일반적으로 에러를 반환한다. ↩︎ 16진수임을 표기했기에 문자열에 0x가 포함되지 않아도 정상 동작한다. ↩︎","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"JavaScript","slug":"Programming/JavaScript","permalink":"https://d2fault.github.io/categories/Programming/JavaScript/"}],"tags":[{"name":"문법","slug":"문법","permalink":"https://d2fault.github.io/tags/%EB%AC%B8%EB%B2%95/"}]},{"title":"[JavaScript] 자바스크립트의 데이터 타입","slug":"20180228-javascript-data-type","date":"2018-02-28T01:13:18.000Z","updated":"2021-03-04T05:31:55.912Z","comments":true,"path":"2018/02/28/20180228-javascript-data-type/","link":"","permalink":"https://d2fault.github.io/2018/02/28/20180228-javascript-data-type/","excerpt":"","text":"데이터 타입 ECMAScript의 데이터 타입은 Undefined, Null, Boolean, 숫자, 문자열 그리고 객체로 이루어져 있다. ECMAScript에서는 개발자 임의로 데이터 타입을 정의할 수 없으므로 모든 변수는 여섯 가지 타입 중 하나에 속한다고 할 수 있다. typeof 연산자 변수에 typeof 연산자를 사용하면 다음 중 하나를 반환한다. 정의되지 않은 변수: “undefined” 불리언: “boolean” 문자열: “string” 함수를 제외한 객체 또는 null: “object” 함수: “function” typeof 연산자는 변수의 데이터 타입을 알아낼 때 아래와 같이 사용한다. 1234var message = &quot;정일훈 mini album big wave 대박 각&quot;;alert(typeof message); // &quot;string&quot;alert(typeof(message)); // &quot;string&quot;alert(typeof 95); // &quot;number&quot; 개인적으로 3 라인의 방식(typeof())을 선호한다. Undefined 타입 자바스크립트는 변수 초기화를 지원한다. 변수를 선언했으나 별도의 초기화가 없었다면 undefined가 자동으로 할당된다. 12var message;alert(message == undefined); // true Null 타입 null은 빈 객체를 가리키는 포인터이다. 변수를 초기화할 때 해당 변수가 객체를 가리키게 할 생각이라면 다른 문자 대신 null을 사용하는 것이 좋다.\u0003 12var car = null;alert(typeof(car)); // &quot;object&quot; null은 다음과 같은 상황에 사용된다. 1234var car = null;if(car != null) &#123; // car가 사용되는 코드를 적으면 된다.&#125; car가 null이라면 객체가 비었다는 뜻이므로 조건에 부합하지 않는다. 고로, if(car != null)의 의미는, 객체가 사용되었다면이 된다. Boolean 타입 boolean 타입은 true, false 둘 중 하나의 리터럴 값을 갖는다. 이 값은 숫자와는 다르다. true는 1이 아니며, false는 0이 아니다. 할당 방법은 다음과 같다. 12var isOkay = true;var isThere = false; boolean은 단 두 가지 값만 갖지만 ECMAScript에서는 모든 값을 불리언으로 표현할 수 있다. 값을 불리언으로 변환하려면 다음의 함수를 사용하면 된다. 12var message = &quot;비투비 정규 2집은 언제 나오나요&quot;;var messageAsBoolean = Boolean(message); // True 단, 값을 true, false로 변환하는 규칙은 데이터 타입과 값마다 다르다. 아래의 표를 참고하자. 데이터 타입 true로 변환되는 값 false로 변환되는 값 불리언 true flase 문자열 비어 있지 않은 모든 문자열 “”(빈 문자열) 숫자 0이 아닌 모든 숫자(무한대 포함) 0, NaN 객체 모든 객체 null Undefined 해당 없음 undefined ✯ 이 포스트의 모든 내용은 프론트엔드 개발자를 위한 자바스크립트 프로그래밍(인사이트) 책을 참고하여 작성되었습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"JavaScript","slug":"Programming/JavaScript","permalink":"https://d2fault.github.io/categories/Programming/JavaScript/"}],"tags":[{"name":"문법","slug":"문법","permalink":"https://d2fault.github.io/tags/%EB%AC%B8%EB%B2%95/"}]},{"title":"[JavaScript] 자바스크립트의 변수","slug":"20180227-javascript-variable","date":"2018-02-27T06:50:19.000Z","updated":"2021-03-04T05:31:55.911Z","comments":true,"path":"2018/02/27/20180227-javascript-variable/","link":"","permalink":"https://d2fault.github.io/2018/02/27/20180227-javascript-variable/","excerpt":"","text":"변수 변수를 정의할 때에는 var 연산자 다음에 변수 이름을 쓴다. var는 키워드이며, 변수 이름은 식별자이다. 1var message; message 변수에는 어떤 값이든 할당할 수 있다. 변수를 초기화하지 않으면 특별한 값인 undefined가 할당[1]된다. 1var message = &quot;hi&quot;; 위의 코드는 변수 message 안에 문자열 &quot;hi&quot;를 저장한 것이다. 하지만 이렇게 하였다고 변수 message의 타입이 문자열이라고 할 수 없다. javascript에서는 변수에 저장된 값과 타입 모두 바꿀 수 있다. 12var message = &quot;hi&quot;;message = 1024; // 유효하지만 권장하지 않는다. 함수 내에서 변수 선언 시 var 키워드를 생략하면 전역변수(global)가 된다. 12345function test() &#123; message = &quot;hi&quot; // message 변수는 전역변수이다.&#125;test();alert(message); 여럿의 변수를 한 번에 선언하고 싶을 때에는 쉼표를 사용하면 된다. 물론 초기화도 가능하다. 123var message = &quot;hi&quot;, isThere = false, age = 26; ✯ 이 포스트의 모든 내용은 프론트엔드 개발자를 위한 자바스크립트 프로그래밍(인사이트) 책을 참고하여 작성되었습니다. undefined로의 변수 초기화를 지원한다. ↩︎","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"JavaScript","slug":"Programming/JavaScript","permalink":"https://d2fault.github.io/categories/Programming/JavaScript/"}],"tags":[{"name":"문법","slug":"문법","permalink":"https://d2fault.github.io/tags/%EB%AC%B8%EB%B2%95/"}]},{"title":"[JavaScript] 자바스크립트 기초 문법","slug":"20180227-javascript-basic-gramma","date":"2018-02-27T05:37:02.000Z","updated":"2021-03-04T05:31:55.911Z","comments":true,"path":"2018/02/27/20180227-javascript-basic-gramma/","link":"","permalink":"https://d2fault.github.io/2018/02/27/20180227-javascript-basic-gramma/","excerpt":"","text":"대소문자 구분 ‘어디서든’ 대소문자를 구분한다. temp와 Temp는 다른 변수이다. 키워드인 typeof는 함수 이름에 쓸 수 없지만, typeOf는 쓸 수 있다. 식별자[1] 식별자는 다음 형식에 따라 한 개 이상의 문자로 표기한다. 첫 번째 문자는 반드시 글자나 언더바(_), 달러 기호($) 중 하나여야 한다. 다른 문자에는 글자나 밑줄, 달러 기호, 숫자를 자유롭게 쓸 수 있다. 글자에는 확장 ASCII나 유니코드 문자를 쓸 수 있으나, 권장하지 않는다. ECMAScript[2] 식별자는 관습적으로 다음과 같은 카멜 케이스[3]를 사용한다. 123firstSecondmyAnimaldoSomethingImportant 주석 한 줄 주석과 블록 주석 모두 C언어 스타일로 표기한다. 123456// 한 줄 주석/* * 혹은 이렇게 * 여러 줄에 걸쳐서 */ 4~5 라인의 *는 가독성을 위해 추가한 것이지만, 기업에서는 이 형태를 선호한다. 문장 각 문장은 세미콜론으로 종료한다. 생략해도 자바스크립트 엔진이 문장의 끝을 판단하지만, 권장하지는 않는다. 12var sum = a + b // 유효하지만 권장하지 않는다.var diff = a - b; // 권장하는 form 또한 아래와 같이 제어문의 문장이 하나일지라도 코드 블록을 사용하길 권한다. 123if(test) &#123; alert(test);&#125; ✯ 이 포스트의 모든 내용은 프론트엔드 개발자를 위한 자바스크립트 프로그래밍(인사이트) 책을 참고하여 작성되었습니다. 변수나 함수, 프로퍼티, 함수 매개변수의 이름. ↩︎ 자바스크립트의 핵심을 가상 언어로 정의. (ECMAScript는 가상 언어이다.) ↩︎ 첫 글자는 소문자로, 다음 단어의 첫 글자를 대문자로 쓰는 표기법. ↩︎","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"JavaScript","slug":"Programming/JavaScript","permalink":"https://d2fault.github.io/categories/Programming/JavaScript/"}],"tags":[{"name":"문법","slug":"문법","permalink":"https://d2fault.github.io/tags/%EB%AC%B8%EB%B2%95/"}]},{"title":"[JavaScript] HTML 안의 자바스크립트","slug":"20180227-javascript-in-html","date":"2018-02-27T01:39:32.000Z","updated":"2021-03-04T05:31:55.911Z","comments":true,"path":"2018/02/27/20180227-javascript-in-html/","link":"","permalink":"https://d2fault.github.io/2018/02/27/20180227-javascript-in-html/","excerpt":"","text":"개요 자바스크립트는 등장과 동시에 HTML에 포함되었다. 자바스크립트는 HTML 페이지 렌더링을 방해하지 않으며 공존해야만 했다. 넷스케이프의 주도 아래 오늘날까지 살아남은 규칙을 소개한다. 아래의 규칙은 HTML 명세에 공식적으로 문서화된 내용이다. &lt;script&gt; 요소는 인라인 스크립트와 외부 스크립트 두 가지로 사용할 수 있다. 1. 인라인 스크립트 12345&lt;script type=&quot;text/javascript&quot;&gt; function hello() &#123; alert(&quot;hello!&quot;); &#125;&lt;/script&gt; 위의 코드와 같이 &lt;script&gt; 요소 안에 직접 작성한 것을 말한다. 단, 여기에서 주의할 점이 있다. 인라인 스크립트를 사용할 경우 문자열 &lt;/script&gt;는 사용할 수 없다. 12345&lt;script type=&quot;text/javascript&quot;&gt; function hello() &#123; alert(&quot;&lt;/script&gt;&quot;); &#125;&lt;/script&gt; alert 안의 &quot;&quot;를 문자열이 아닌 닫는 태그로 인식하기 때문에 벌어지는 일이다. 이럴 때에는 ‘/’ 문자를 ‘\\’(역슬래시)와 함께 사용하여 해결할 수 있다. 12345&lt;script type=&quot;text/javascript&quot;&gt; function hello() &#123; alert(&quot;&lt;\\/script&gt;&quot;); &#125;&lt;/script&gt; 2. 외부 스크립트 자바스크립트를 외부 파일에서 불러오려면 src 속성을 사용해야 한다. 1234// 1. 태그로 닫기&lt;script type=&quot;text/javascript&quot; src=&quot;example.js&quot;&gt;&lt;/script&gt;// 2. 인라인으로 닫기(IE에서는 제대로 처리되지 않을 때가 있다고 한다.)&lt;script type=&quot;text/javascript&quot; src=&quot;example.js&quot;/&gt; 위의 코드는 외부 파일은 example.js를 페이지로 불러온다. 이 파일 안에는 절대 &lt;script&gt;, &lt;/script&gt; 태그가 들어가서는 안 되며, 자바스크립트 코드만 들어 있어야 한다. 무엇보다 js 파일을 내려받아 실행한다면, 모든 인라인 코드는 무시된다는 점은 잊어선 안 된다. 어디에 위치시켜야 하는가? 전통적으로 js 파일은 &lt;head&gt; 요소 내에 위치시켰다. 그러나 자바스크립트 파일 해석이 끝날 때까지 페이지 렌더링이 지연되기 때문에 일반적으로 &lt;body&gt; 요소 안에, 콘텐츠 마지막에 쓴다. 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;페이지 제목입니다.&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;페이지 콘텐츠 내용을 적고&lt;/p&gt; &lt;!--페이지 콘텐츠--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;example1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;example1.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 혹은 defer[1] 속성을 사용하는 방법이 있다. 이 속성은 스크립트에서 페이지 구조를 바꾸지 않는다고 명시하는 것이다. 페이지 전체를 파싱한 후 스크립트를 실행해도 상관없기 때문에, 브라우저는 defer 요소를 만나는 즉시 코드를 내려받지만 실행은 지연한다. 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;페이지 제목입니다.&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; defer src=&quot;example1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; defer src=&quot;example1.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--페이지 콘텐츠--&gt; &lt;/body&gt;&lt;/html&gt; 그러나 인터넷 익스플로러 4, 파이어폭스 3.5, 사파리 5, 크롬 7 이상에서만 동작하기 때문에 여전히 스크립트는 페이지 맨 마지막에 놓는 것이 최상이다. 비동기 스크립트 async[2] 속성은 defer와 비슷하게 스크립트를 처리한다. 외부 스크립트에만 적용되며, 브라우저에게 파일을 즉시 내려받으라고 지시한다. 다만, defer와 다르게, 스크립트가 마크업 순서대로 실행된다는 보장이 없다. 즉, javascript 파일 사이에 의존성이 있으면 안 된다. example1.js가 자바스크립트 라이브러리 파일이고, example2.js파일이 해당 라이브러리를 이용한다면 example2.js 파일이 제대로 실행되지 않을 수도 있다. async 속성은 순서에 상관없이 실행해도 좋다는 의미를 내포한다. 선생님, 자바스크립트 지원하지 않는 브라우저는요? 요즘에도 그런 브라우저가 있겠냐만은, 초기 브라우저를 사용하는 유저가 남아 있을 수 있다. 자바스크립트를 지원하지 않는데 어떻게 서비스를 해요? 네, 그래서 자바스크립트를 사용할 수 없을 때 메시지를 남길 수 있는 요소를 제공합니다. 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;페이지 제목입니다.&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; defer src=&quot;example1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; defer src=&quot;example1.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;p&gt;해당 브라우저는 자바스크립트를 지원하지 않습니다. 브라우저 업데이트 이후에 다시 시도해 주세요.&lt;/p&gt; &lt;/noscript&gt; &lt;/body&gt;&lt;/html&gt; &lt;noscript&gt; 요소를 사용하면 간단하게 해결할 수 있다. 스크립트가 활성화된 브라우저에서는 절대 표시되지 않는다. 어쩌란 말이냐 자바스크립트는 외부 파일로 정의하여 사용하는 것을 권장한다. 이유는 다음과 같다. 관리하기 쉽다. 코드를 HTML 여기저기 뿌리는 것보다 directory 하나에 모으는 것이 관리에 더 용이하다. 캐싱이 된다. 서로 다른 페이지에서 같은 파일을 사용한다면 js 파일은 한 번만 내려받기 때문에 페이지 로딩 시간이 줄어든다. ✯ 이 포스트의 모든 내용은 프론트엔드 개발자를 위한 자바스크립트 프로그래밍(인사이트) 책을 참고하여 작성되었습니다. XHTML 문서에서는 defer=“defer” 형식으로 써야 한다. ↩︎ XHTML 문서에서는 async=“async” 형식으로 써야 한다. ↩︎","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"JavaScript","slug":"Programming/JavaScript","permalink":"https://d2fault.github.io/categories/Programming/JavaScript/"}],"tags":[{"name":"문법","slug":"문법","permalink":"https://d2fault.github.io/tags/%EB%AC%B8%EB%B2%95/"}]},{"title":"[JavaScript] 자바스크립트를 시작하며","slug":"20180227-start-javascript","date":"2018-02-27T00:51:20.000Z","updated":"2021-03-04T05:31:55.912Z","comments":true,"path":"2018/02/27/20180227-start-javascript/","link":"","permalink":"https://d2fault.github.io/2018/02/27/20180227-start-javascript/","excerpt":"","text":"왜 자바스크립트를 시작하는가 영어와 자바스크립트의 공통점이 뭔지 알아? 해야 할 걸 알면서도 하지 않았다는 거야… 자바스크립트를 해야 하는 이유는 언제나 충분했다. 그저 웹 프론트엔드가 극혐이라고 생각해서(브라우저 호환성 ㅂㄷㅂㄷ) 모르는 척했을 뿐이다. 왜 그랬을까… 그래도 후회는 안 해! 대세인 이더리움에도 자바스크립트가 쓰인다면서요? Go lang, Python, C++ 수많은 다른 언어들은 언제 시작하나 싶지만 일단 걱정은 미뤄두고 이 글을 기점으로 자바 스크립트를 본격적으로 시작하려 한다. 목표는 프론트엔드 개발자를 위한 자바스크립트 프로그래밍(JavaScript for Web Developers) 책을 모두 읽고 정리하는 것이다. 목표는 항상 크게, 크게! ^^; 포스팅이 중간에 끊길 수도 있고, 갑자기 바빠질 수도 있고, 많은 장애물이 생길 가능성이 아주 아주 아주 높지만 그럼에도 불구하고 시작하고 본다!(시작이 반이랬다.) 어디까지나 공부하고 잊어버릴 미래의 나를 위해 하는 포스팅! 고고! 'ㅅ’b","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"JavaScript","slug":"Programming/JavaScript","permalink":"https://d2fault.github.io/categories/Programming/JavaScript/"}],"tags":[]},{"title":"[Diary] 이런 저런 그런 생각들","slug":"20180226-diary","date":"2018-02-26T01:14:22.000Z","updated":"2021-03-04T05:31:55.911Z","comments":true,"path":"2018/02/26/20180226-diary/","link":"","permalink":"https://d2fault.github.io/2018/02/26/20180226-diary/","excerpt":"","text":"통달한 듯한 관조적 태도 '내가 맞고 넌 틀려’의 태도는 언제 겪어도 끔찍하다. 그렇다고 전부 틀린 말은 아니었다. 삶이 모두에게 버겁다는 건 변하지 않는 사실이니까. 다정하고 좋은 사람이라고 했다. ‘정말?’ 나는 되묻지 않았다. 보고, 듣고, 느낀 것으로 충분하다. 누가 그에게 권리를 주었는가 내 잣대는 내 잣대일 뿐이다. 나와 다르다는 이유로 누구를 가르칠, 버릇을 고칠, 바꿀 권리는 없다. 태도를 고치겠다는 명분으로 무례하게 굴 당위성 또한 당연히 없다. 맨스플레인은 정말 지긋지긋해. 자기 반성 그래서 나는 오늘 또 반성한다. 나는항상좋은사람이었는가나보다남에게더엄격하진않았는가무의식중에상처를주진않았는가편견에사로잡혀있지는않았나… 그리고 문득 든 생각. 어디까지 배려이고, 어디까지 코르셋일까.","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Diary","slug":"Anything/Diary","permalink":"https://d2fault.github.io/categories/Anything/Diary/"}],"tags":[{"name":"일상","slug":"일상","permalink":"https://d2fault.github.io/tags/%EC%9D%BC%EC%83%81/"},{"name":"생각","slug":"생각","permalink":"https://d2fault.github.io/tags/%EC%83%9D%EA%B0%81/"}]},{"title":"[Github×Hexo] 폰트 바꾸기(Hueman Theme)","slug":"20180221-hexo-change-font-hueman-theme-version","date":"2018-02-21T00:37:44.000Z","updated":"2021-03-04T05:31:55.910Z","comments":true,"path":"2018/02/21/20180221-hexo-change-font-hueman-theme-version/","link":"","permalink":"https://d2fault.github.io/2018/02/21/20180221-hexo-change-font-hueman-theme-version/","excerpt":"","text":"블로그 기본 폰트 변경하기 그 어디에도 테마에 폰트 변경하는 방법은 써 있지 않아 직접 작성하는 포스트! 다른 테마 적용법은 있어도, hueman 적용법은 없는 거 실화냐… 폰트 변경에 사용되는 파일은 단 두 가지이다. head.ejs파일과, _variables.styl파일. 이 두 가지만 수정하면 아주 쉽고 깔끔하게 끝난다. 두 파일의 경로는 다음과 같다. 에디터에 열어두고 수정을 시작해 보자. [블로그 루트 디렉토리]/themes/hueman/layout/common/head.ejs [블로그 루트 디렉토리]/themes/hueman/source/css/_variables.styl head에 웹폰트 url 추가하기 먼저, head에 웹폰트 url을 추가한다. &lt;%- css('웹폰트 url') %&gt; 형식을 따르면 된다. 웹폰트 url을 지우고, 원하는 폰트의 url을 넣은 뒤 head 파일에 추가한다. 해당 코드는 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot;&gt; 코드 아래에 추가하면 된다. 아래의 코드는 이 블로그에 적용된 본문 글꼴(나눔스퀘어라운드)과 코드창 글꼴(나눔고딕코딩)의 예시이다. 1234&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot;&gt;&lt;%- css(&#x27;https://cdn.rawgit.com/innks/NanumSquareRound/master/nanumsquareround.css&#x27;) %&gt; &lt;%- css(&#x27;https://fonts.googleapis.com/earlyaccess/nanumgothiccoding.css&#x27;) %&gt;&lt;%- css(&#x27;css/style&#x27;) %&gt; 웹폰트 적용하기 적용하는 방법은 아주 간단하다. 폰트의 재사용성(^^)을 높이기 위해 변수 하나에 모든 폰트를 때려박기 때문이다. 다음의 순서로 수정하면 된다. _variables.styl 파일에서 font-sans나 font-mono를 검색한다. font-sans는 본문 폰트이고, font-mono 는 코드 블록 내의 폰트이다. 변수 오른쪽(=를 기준으로 우변)에 작성된 코드를 지운다. 주석을 추천한다. 원하는 폰트명을 적는다. 저장한다. 예시는 다음과 같다. 123456// Fontsfont-sans = &#x27;Montserrat&#x27;, &quot;NanumSquareRound&quot;, &quot;Malgun Gothic&quot;, &quot;맑은 고딕&quot;, &quot;돋움&quot;, dotum, sans-serif//font-sans = &quot;Titillium Web&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;Microsoft Yahei&quot;, sans-seriffont-serif = Georgia, &quot;Times New Roman&quot;, seriffont-mono = &quot;Nanum Gothic Coding&quot;, &quot;NanumSquareRound&quot;, Consolas, monospace//font-mono = &quot;Source Code Pro&quot;, Consolas, Monaco, Menlo, Consolas, monospace 변경 사항을 hexo server로 로컬에서 확인해 보고, 정상적으로 변경되었다면 블로그에 반영하자. localhost에서는 보이는데 블로그로 접속하면 안 보인다면? 높은 확률로 캐시 때문에 일어난 문제. 브라우저 캐시 날리면 됩니다. ^^b 그래도 안 된다면? 폰트 이름 맨 뒤에 세미콜론 붙이신 건 아닌지 확인해 주세요. 자주 사용되는 웹폰트 URL 아래의 웹폰트는 블로그에서 쓰기 좋은 폰트들이다. 아래의 url을 적용하고, 폰트 이름을 괄호 안에 있는 것으로 지정하면(예- font-sans = &quot;Nanum Barun Gothic&quot;, sans-serif) 바로 사용할 수 있다. 나눔바른고딕(Nanum Barun Gothic) https://cdn.jsdelivr.net/font-nanum/1.0/nanumbarungothic/nanumbarungothic.css 나눔스퀘어(Nanum Square) https://cdn.rawgit.com/hiun/NanumSquare/master/nanumsquare.css 나눔스퀘어라운드(NanumSquareRound) https://cdn.rawgit.com/innks/NanumSquareRound/master/nanumsquareround.css 나눔고딕코딩(Nanum Gothic Coding) https://fonts.googleapis.com/earlyaccess/nanumgothiccoding.css 나눔손글씨붓(Nanum Brush Script) https://fonts.googleapis.com/earlyaccess/nanumbrushscript.css 나눔손글씨펜(Nanum Pen Script) https://fonts.googleapis.com/earlyaccess/nanumbrushscript.css 나눔명조(Nanum Myeongjo) http://fonts.googleapis.com/earlyaccess/nanummyeongjo.css 이롭게바탕(Iropke Batang) https://cdn.rawgit.com/jmnote/IropkeBatang/master/iropkebatang.css KoPub 돋움(KoPub Dotum) https://cdn.jsdelivr.net/font-kopub/1.0/kopubdotum.css KoPub 바탕(KoPub Batang) https://fonts.googleapis.com/earlyaccess/kopubbatang.css 제주고딕(Jeju Gothic) http://fonts.googleapis.com/earlyaccess/jejugothic.css 제주 한라산(Jeju Hallasan) http://fonts.googleapis.com/earlyaccess/jejuhallasan.css 제주 명조(Jeju Myeongjo) http://fonts.googleapis.com/earlyaccess/jejumyeongjo.css 한나(Hanna) http://fonts.googleapis.com/earlyaccess/hanna.css","categories":[{"name":"Blog","slug":"Blog","permalink":"https://d2fault.github.io/categories/Blog/"},{"name":"Hexo","slug":"Blog/Hexo","permalink":"https://d2fault.github.io/categories/Blog/Hexo/"}],"tags":[]},{"title":"[Blockchain] ICO 사례(4)","slug":"20180220-blockchain-ico-case","date":"2018-02-20T07:53:01.000Z","updated":"2021-03-04T05:31:55.906Z","comments":true,"path":"2018/02/20/20180220-blockchain-ico-case/","link":"","permalink":"https://d2fault.github.io/2018/02/20/20180220-blockchain-ico-case/","excerpt":"","text":"TE-FOOD 블록체인 기반 식품 추적 및 안전 개선 플랫폼 성과 식품 추적/식별 용이 소비자에게 원산지 정보를 투명하게 제공 블록체인 기반으로 무결성 보장(유통 경로 임의 수정 불가) 표준 인터페이스 제공(어떤 물류에도 적용 가능) 2016년부터 베트남 전역(호치민)에서 돼지, 달걀 등 농장부터 소매까지 전체 공급망 추적 시스템 제공 플랫폼 판매(민간 기업/공공기관 모두 이 시스템을 사용할 수 있다.) 2018.02.22~2018.03.22 ICO 예정 마치며 충분히 수요가 있을 프로젝트인 것 같다. 원산지에 관한 관심은 날이 갈수록 높아지고, 인증 마크만으로는 신뢰할 수 없는 세상이 되어가니까. 이 회사는 인증 단에서 Tag, RFID, QR Code 등 여러 방식을 사용한다. 산업에 따라 적절한 것을 선택하면 된다. 최종적으로 어떤 User가 되든 End 단에서, TE-FOOD의 Application으로 QR코드만 리딩하면 기록된 모든 정보를 볼 수 있다. 이 정보는 블록체인에 올라가기 때문에 무결성을 보장한다. 코인 없이 돌아가는 블록체인 사례를 드디어 찾았다.","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"ICO","slug":"ICO","permalink":"https://d2fault.github.io/tags/ICO/"}]},{"title":"[Github×Hexo] Hexo 사용 시 설치하면 좋은 플러그인","slug":"20180220-hexo-essential-plugin","date":"2018-02-20T05:03:55.000Z","updated":"2021-03-04T05:31:55.910Z","comments":true,"path":"2018/02/20/20180220-hexo-essential-plugin/","link":"","permalink":"https://d2fault.github.io/2018/02/20/20180220-hexo-essential-plugin/","excerpt":"","text":"Hexo의 꿀 플러그인(Plugin) 소개 블로그 포스트는 본디 나에게도, 남에게도 도움이 되어야 한다. 이번 포스트에서는 검색 엔진 최적화를 돕는, 나 빼고 다 사용하고 있는 꿀 플러그인을 소개할 것이다. hexo-auto-canonical 각 포스트에 자동으로 표준 링크를 만들어 준다. Install Hexo가 설치된 폴더에 접근해서 다음 명령어를 실행한다. 1$ npm install hexo-auto-canonical --save hueman theme 기준, themes/hueman/layout/common/head.ejs 파일을 연다. &lt;%- meta(page) %&gt; 코드 아래에 &lt;%- autoCanonical(config, page) %&gt; 코드를 추가한다. 변경 사항을 디플로이하고, 개발자 도구를 열어 보면 canonical 속성이 생긴 것을 확인할 수 있다. hexo-generator-seo-friendly-sitemap 자동으로 sitemap.xml을 만들어 준다. 크롤러의 효율적인 크롤링을 돕는다. Install Hexo가 설치된 폴더에 접근해서 다음 명령어를 실행한다. 1$ npm install hexo-generator-seo-friendly-sitemap --save 블로그 폴더의 _config.yml파일을 열고, 최하단에 아래의 코드를 추가한다. 123# sitemap auto generatorsitemap: path: sitemap.xml 블로그url/sitemap.xml에 접속하여 파일이 보이면 성공! hexo-generator-feed 자동으로 Atom 1.0 이나 RSS 2.0 피드를 생성한다. Install Hexo가 설치된 폴더에 접근해서 다음 명령어를 실행한다. 1$ npm install hexo-generator-feed --save 블로그 폴더의 _config.yml파일을 열고, 최하단에 아래의 코드를 추가한다. 12345678# rss feed auto generatorfeed:# feed type (atom &#x2F; rss2)type: rss2# feed path (Default: atom.xml &#x2F; rss2.xml)path: rss2.xml# 최신 포스트의 수 설정. (0 또는 false 입력시 전체 포스트)limit: 20 블로그url/rss2.xml에 접속하여 파일이 보이면 성공!","categories":[{"name":"Blog","slug":"Blog","permalink":"https://d2fault.github.io/categories/Blog/"},{"name":"Hexo","slug":"Blog/Hexo","permalink":"https://d2fault.github.io/categories/Blog/Hexo/"}],"tags":[]},{"title":"[Diary] Hexo 블로그 '다시' 시작하기","slug":"20180219-diary","date":"2018-02-19T08:36:52.000Z","updated":"2021-03-04T05:31:55.909Z","comments":true,"path":"2018/02/19/20180219-diary/","link":"","permalink":"https://d2fault.github.io/2018/02/19/20180219-diary/","excerpt":"","text":"Hexo, 수정과 수정의 무한 굴레 공부한 것들을 블로그에 적겠다고 다짐한 게 구정 전이었나 보다. 일 년 정도 손 놓고 있던 블로그의 글들을 정리하고(draft로 꾸깃꾸깃~) 자잘한 것들을 연동했다. 일단 오늘은 한 개 반 정도의 포스트를 완료했군. ㅋㅋ(앗, 다이어리 포함하면 두 개 반! ㅋㅋㅋ) 그럼 출근 후 나머지 시간에는 무얼 했느냐? 자잘한 문제들을 고쳤다. -_- disqus 동작에 오류가 생긴다거나, 블로그의 html 파일이 모두 0 bytes가 된다거나(그래서 로컬에 hexo를 다시 설치했다. 이후에 버전 컨트롤용 repo에 다시 push), favicon 설정이 제대로 안 되는 문제(알고 보니 png 파일을 엉뚱한 곳에다가 붙여넣고 있었음. ㅋㅋ) 등 이상한 문제들의 연속이었다. 그래도 이 모든 역경을 무사히 이겨냈고, 구글 애널리틱스 연결과 네이버사이트 등록까지 모두 마쳤다. 몰랐는데, hexo의 큰 장점 중 하나는 sitemap과 rss를 자동으로 만들어 주는 플러그인을 제공한다는 것이다. 렬루 편해! 설치하고 _config.yml 파일에 추가만 하면 끝~! 룰루~ 그런데 아직 문제가 하나 남아 있다. 마크다운 에디터로 Typora를 사용하는 중인데, mark(하이라이트)가 잘 먹지 않는다. 에디터에서는 제대로 보이는 하이라이트가(단축키는 ==) 페이지에서는 그냥 ==로 보인다. -_- 덕분에 mark 태그로 붙이고 있다. ㅋㅋㅋ 하아. 그럼에도 불구하고 참 깔끔하고 편안한 툴이라 잘 사용하고 있습니다. Typora 짱! 이미 손에 익어 버려서 다른 에디터 못 쓰겠다. ㅋㅋㅋ","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Diary","slug":"Anything/Diary","permalink":"https://d2fault.github.io/categories/Anything/Diary/"}],"tags":[{"name":"일상","slug":"일상","permalink":"https://d2fault.github.io/tags/%EC%9D%BC%EC%83%81/"}]},{"title":"[Github×Hexo] 포스트 퍼블리싱하기","slug":"20180219-hexo-publish-post","date":"2018-02-19T00:45:09.000Z","updated":"2021-03-04T05:31:55.904Z","comments":true,"path":"2018/02/19/20180219-hexo-publish-post/","link":"","permalink":"https://d2fault.github.io/2018/02/19/20180219-hexo-publish-post/","excerpt":"","text":"포스트 퍼블리싱하기 포스트 작성의 마지막 단계, 퍼블리싱이다. 모든 내용을 draft에 작성한 후 파일을 post로 옮기는 작업이다. 두 가지 방법이 있다. 명령어로 퍼블리싱하기 1hexo publish &lt;포스트명&gt; 위의 명령어로 간단히 퍼블리싱할 수 있지만, 주로 사용하지는 않는다. 포스트명을 정확히 적어야 한다는 단점이 있기 때문이다. 직접 파일 옮기기 덜 개발자스럽지만, 이 방법을 선호한다. source/_drafts 경로에 저장된 draft 파일을 source/_posts에 옮기는 것이다. Drag and Drop으로 아주 쉽게 옮겨진다. (^^)v 포스트 발행하기(디플로이) _config.yml 파일에 자신의 github 주소를 입력한다. 1234deploy: type: git repo: [이곳에 주소를 넣으면 된다.] branch: master 정적 파일을 생성한 후, 1hexo generate 발행한다. 1hexo deploy 발행할 때 변경 사항은 자동으로 반영되지만, 혹시 변경되지 않을까 걱정된다면 발행 전 아래의 명령어를 사용해 보자. 1hexo clean generate와 deploy는 단축 명령을 허용한다. 정리하자면, 블로그 글을 퍼블리싱 할 때에는 다음과 같이 사용하면 된다. 12hexo cleanhexo d -g Error가 발생한다면? ERROR Deployer not found: git 에러가 발생한다면 아마 두 가지 이유 중 하나일 것이다. _config.yml 파일 안에 있는 deploy 설정이 안 되어 있을 것이다. 1234deploy: repo: git repo의 url을 넣어 주면 된다. type: git branch: master 위와 같이 설정하면 된다. hexo-deployer-git이 설치되지 않았을 것이다. 1$ npm install hexo-deployer-git --save blog의 최상단 폴더에서 위의 명령어를 실행하면 된다.","categories":[{"name":"Blog","slug":"Blog","permalink":"https://d2fault.github.io/categories/Blog/"},{"name":"Hexo","slug":"Blog/Hexo","permalink":"https://d2fault.github.io/categories/Blog/Hexo/"}],"tags":[]},{"title":"[Github×Hexo] 블로그 초안(draft) 작성하기","slug":"20180214-hexo-write-draft","date":"2018-02-14T01:32:17.000Z","updated":"2021-03-04T05:31:55.910Z","comments":true,"path":"2018/02/14/20180214-hexo-write-draft/","link":"","permalink":"https://d2fault.github.io/2018/02/14/20180214-hexo-write-draft/","excerpt":"","text":"지원하는 문서 방식 Hexo는 다음의 세 가지를 지원한다. 초안(Draft) 포스트를 발행하기 전 작성할 수 있는 초안. 포스트를 작성할 때에는 초안을 먼저 작성하고, 이후에 포스트로 발행하면 된다. 포스트(Post) 홈페이지에 게시되는 기본적인 글이다. 페이지(Page) 해당 페이지에 직접 접근해야 볼 수 있는 페이지를 작성할 때 사용한다. (사용해 본 적은 없다.) 레이아웃 변경하기 나는 주로 초안 작성-확인-포스트 작성-발행의 순서로 작업한다. 이때, Hexo는 아주 중요한 ‘레이아웃’ 기능을 제공한다. [hexo blog가 설치된 디렉토리]/scaffolds 경로에 접근해 보자. draft, page, post 총 세 가지의 마크다운 파일이 있을 것이다. page는 사용하지 않는 관계로, dratf와 post의 레이아웃을 다음처럼 수정하였다. 123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags:--- draft나 post를 만들 때 지정하는 제목이 title에 들어가고, 생성 시간이 자동으로 date에 입력된다. categories나 tags는 직접 입력할 수 있다. 카테고리 안의 새로운 카테고리를 생성하고 싶다면 두 가지를 적으면 된다. 예를 들어, Blog 카테고리 안의 Hexo를 만들고 싶다면 이렇게 수정하면 된다. 12345678---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:- Blog- Hexotags:--- 초안(Draft) 작성하기 그렇다면 이것을 활용해서 초안을 작성해 보자. 초안을 생성하는 코드는 다음과 같다. 1hexo new draft &quot;제목&quot; 제목이 곧 블로그의 url이 된다. 절대 한글로 적어서는 안 된다. 한글로 잘못 적었다가 문제 해결한다고 고생했던 기억이 있다. 그렇다면 실제 블로그에 나타날 제목은 어떻게 바꾸느냐! 생성된 마크다운 파일을 수정하면 된다. [hexo blog가 설치된 디렉토리]/source/_draft 경로에 우리가 만든 markdown 파일이 있다. 파일을 열어 레이아웃의 title 부분을 수정하면 블로그에 노출되는 제목이 바뀐다. 제목을 &quot;오늘의 일기&quot;로 바꾸고 싶다면 아래와 같이 수정하면 된다. 123456---title: &quot;오늘의 일기&quot;date: 2018-02-14 18:24:25categories:tags:--- 내용을 적고 저장해 보자. draft의 내용을 브라우저로 확인하기 위해서는 어떻게 해야 할까? hexo server 명령으로는 확인할 수 없다. 정식으로 포스트를 발행한 것이 아니기 때문이다. 이럴 때, draft를 브라우저에서 확인할 수 있도록 하는 명령어가 있다. 1hexo server --draft 이렇게 뒤에 draft를 붙여 주면 초안 파일도 로컬 서버에서 확인할 수 있다.","categories":[{"name":"Blog","slug":"Blog","permalink":"https://d2fault.github.io/categories/Blog/"},{"name":"Hexo","slug":"Blog/Hexo","permalink":"https://d2fault.github.io/categories/Blog/Hexo/"}],"tags":[]},{"title":"[Blockchain] ICO 사례(3)","slug":"20180209-blockchain-ico-case","date":"2018-02-09T07:05:07.000Z","updated":"2021-03-04T05:31:55.903Z","comments":true,"path":"2018/02/09/20180209-blockchain-ico-case/","link":"","permalink":"https://d2fault.github.io/2018/02/09/20180209-blockchain-ico-case/","excerpt":"","text":"Power Ledger 블록체인 기반 에너지 거래 플랫폼 2016년 5월에 공식 결성 자동으로 전력을 교환하는 합의 시스템과 실시간으로 지불할 수 있는 결제 시스템 제공 성과 개인 간 P2P 에너지 교환 지원 입주자에게 아파트에서 생성한 재생 에너지를 투명하게 배분할 수 있는 상업용 관리 시스템 개발 및 배치 지속 가능한 도시를 조성하기 위해 부동산 개발업자와의 협력(목표: 100% 재생 에너지 사용 달성) 사업 확장을 위한 노력 국영기업, 공기업(전력 관련)과의 파트너십 체결 부동산 개발업자와의 파트너십을 통한 자사의 에너지 플랫폼 제공 마치며 블록체인의 특성인 ‘투명성’, '무결성’에 포커스한 '거래 플랫폼’들이 많이 생기는 듯하다. 클라우드도, 에너지도 결국 끝은 '거래’이다. ICO를 위해서는 '코인’을 발행해야 하고, 코인과 거래는 뗄 수 없는 관계이기에 그런 것일까? 블록체인의 끝이 코인은 아닐 것인데 말이다. 역설적이다. 블록체인을 응용한 기술 중 하나가 코인이라더니, 코인을 제외한 기획은 없다. 혹은 있는데 찾지 못하거나. 누군가 나에게 답을 주었으면 좋겠다. 도대체 블록체인이 뭔데? 코인 빼면 시체야?","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"ICO","slug":"ICO","permalink":"https://d2fault.github.io/tags/ICO/"}]},{"title":"[Blockchain] ICO 사례(2)","slug":"20180202-blockchain-ico-case","date":"2018-02-02T05:44:42.000Z","updated":"2021-03-04T05:31:55.901Z","comments":true,"path":"2018/02/02/20180202-blockchain-ico-case/","link":"","permalink":"https://d2fault.github.io/2018/02/02/20180202-blockchain-ico-case/","excerpt":"","text":"개요 2015년, 소프트웨어마에스트로 과정을 하며 블록체인의 개념을 처음 들었다. 모르겠고, 나라면 이걸 만들래! 라고 낸 아이디어가 바로 블록체인을 접목시킨 클라우드 시스템(이하 블록 클라우드)이었다. 굳이 명명하자면 그렇다. 우리는 현실적인 한계로 생각에 그쳤지만, 이것을 실제로 만든 곳이 생겨났다. 왜 블록 클라우드인가? 블록 클라우드는 리소스 추가 없이, 유휴 리소스를 연결하여 새로운 클라우드 시장을 만든다. 최대 장점은 고비용 저효율을 해결할 수 있다는 것이다. 고비용 저효율은 HPC(High Performance Compution)나 Cloud의 고질적 문제로 지적되어 왔다. 여기에서 Fog &amp; Edge Computing이라는 재미있는 개념이 등장한다. 구름(Cloud)보다 아랫단에 존재하여 안개(Fog)라는 이름을 갖게 되었다. 현재 클라우드 시스템에는 Fog가 없다. 데이터를 가져오고 싶을 때에는 클라우드에 직접 접근해야 한다. 당연히 트래픽도 크고, 대기 시간도 길다. 여기에 위의 사진과 같이 Fog를 적용한다면? Fog Level에서 데이터를 가져오므로 트래픽과 대기 시간이 감소하며, QoS도 향상될 것이다. 즉, 데이터가 네트워크 가장자리에 있더라도 프로세싱 인텔리전스를 이동할 수 있다. 4차 산업혁명 기술로 거론되는 5G의 상용화와 더불어 Fog Computing을 적용한 클라우드 또한 빠르게 확산될 것이다. IEXEC 목표: 빅데이터, HPC Application, Data set, Computing Resource가 블록체인 상에서 수익을 창출하는, 탈중앙화된 인프라외 시장 네트워크의 미래 선도 블록체인 기반의 클라우드를 통한 컴퓨팅 리소스 거래 Ethereum 계약 기반, 고성능 컴퓨팅 서비스 제공 데스크톱 그리드 컴퓨팅 기술 이용, 인터넷 상에 쉬고 있는 컴퓨팅 자원을 모아 슈퍼 컴퓨터로 활용 현재 개발된 수준: 커뮤니티 에디션 배포된 클라우드를 만들기 위한 오픈소스 소프트웨어 개발. Dapps가 off-chain 컴퓨팅 리소스에 접근, 거래 결과를 스마트 계약으로 재전송. 마치며 블록체인은 P2P 기술이다. 그 말인 즉, End 유저들을 ‘곧바로’ 연결한다는 거다. 아무것도 거치지 않고! 공개 장부에 얽매여 P2P를 절대로 잊어서는 안 된다. 얼마나 더 빠르고 효율적으로 그들은 '연결’하느냐가 바로 개발자가 풀어야 할 숙제 아닐까. 그것과 더불어 블록체인에 ‘무엇을 올릴’ 것인지까지.","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"ICO","slug":"ICO","permalink":"https://d2fault.github.io/tags/ICO/"}]},{"title":"[Blockchain] ICO 사례(1)","slug":"20180126-blockchain-ico-case","date":"2018-01-26T01:52:32.000Z","updated":"2021-03-04T05:31:55.902Z","comments":true,"path":"2018/01/26/20180126-blockchain-ico-case/","link":"","permalink":"https://d2fault.github.io/2018/01/26/20180126-blockchain-ico-case/","excerpt":"","text":"블록체인 적용 사업화 사례 ICOKR을 참고하여 관심이 가는 블록체인 사례를 아주 간략하게 정리해 보려고 한다. 다양한 것들을 많이 접하다 보면 아이디어가 나오지 않을까? Edge Security 암호화 지갑 서비스 Edge 단에서의 보안(先 암호화, 後 전송) Blockchain 암호화를 이용한 데이터 유출 방지 플랫폼 내역이 공개되어도 개인 키를 가지지 않은 해커는 어떤 이득도 취할 수 없다. Poly Swarm Blockchain의 '투명성’을 이용, 보안 전문가의 활동 내역 공개 보안 전문가를 고용하고자 하는 유저는 두 가지 중 하나를 선택할 수 있다. 자동 전문가 추천 원하는 전문가 선택(Blockchain Data 열람) 전문가에게는 자신만의 신뢰성 높은 포트폴리오를 가질 수 있게 한다.(Blockchain Data의 투명성) Block Armour 보안 플랫폼 제공 액세스 및 ID 관리, IoT 보안, 데이터/정보의 무결성 암호화 인증(해시 함수 기반, 기타 ID 검증 방법과 함께 이중 인증) 분산 아키텍처(P2P) 제공 Guardtime 블록체인으로 보안을 강화한 다양한 플랫폼 제공 IoT(데이터 스트림에 관한 End to End 보관 체인, 장치의 인증 및 실시간 검증 등) 클라우드 보증(Exabyte 규모의 무결성 제공) 국방 및 항공 우주(차세데 침입 방지 하드웨어 및 무결성 솔루션 제공) 마치며 4차 산업혁명, 5G, AI 등의 이야기 속에서 등장한 Blockchain! 혜안이 부족하여 지금 당장 블록체인이 무엇이다! 라고 말할 수는 없지만, 대세의 기술은 맞는 듯하다. 조금 과장하자면 4차 산업혁명의 근간이 될 수도 있을 것 같다. 확실한 건, 우리가 생각하는 모든 것들을 블록체인 위에 올릴 수 있다는 것이다. (돈이 될 것이라고는 안 했다.ㅋㅋ) 아무도 모르게 다가오는 4차 산업혁명이 플랫폼 사업의 2차 대전이 될 것이라 생각한다. 지금 우리는, 블록체인 위에 '무엇’을 올릴지 수없이 고민하고 또 고민해야 할 것이다. 뭐, 이러다가 조용히 사라질 기술인지도 모르겠다.","categories":[{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"}],"tags":[{"name":"ICO","slug":"ICO","permalink":"https://d2fault.github.io/tags/ICO/"}]},{"title":"[Github×Hexo] 블로그 테마 적용하기","slug":"20171124-hexo-apply-theme","date":"2017-11-24T10:20:57.000Z","updated":"2021-03-04T05:31:55.897Z","comments":true,"path":"2017/11/24/20171124-hexo-apply-theme/","link":"","permalink":"https://d2fault.github.io/2017/11/24/20171124-hexo-apply-theme/","excerpt":"","text":"블로그 테마 적용하기 블로그에 글을 올리기 전에 테마를 적용해 보자. 테마 다운받기 첫 번째 포스팅에서 테마에 관련하여 언급했다. 현재 내가 사용하는 테마는 hueman이고, 추천 테마는 hueman을 포함한 두 가지이다. 테마는 만들 수도 있지만 보통은 검색해서 적용하는 듯하다. 추천 테마 세 가지는 아래 링크에서 다운할 수 있다. hueman maupassant icarus 테마 적용하기 다운한 테마를 다음의 경로에 넣어 준다. /blog/themes/다운한 테마 디렉토리 ex) /blog/themes/hueman 아래의 코드로 변경 사항을 확인해 본다. 첫 명령어의 경우, 이미 blog 경로에 있다면 생략하면 된다. server를 돌리고 로컬호스트에 접속해 보면 테마가 적용되어 있을 것이다. 12cd bloghexo server 커스터마이징 블로그 커스터마이징 커스터마이징은 config.yml 파일로 할 수 있다. 단, 이 파일이 두 경로에 존재함을잊어서는 안 된다. 먼저, 테마가 아닌 블로그를 커스터마이징 해 보자. /blog/_config.yml 경로의 config.yml을 수정하면 된다. 1234567# Sitetitle: 개발 블로그subtitle: Hong&#x27;s IT Blogdescription: author: Honglanguage: entimezone: Asia/Seoul 테마 커스터마이징 우리가 다운한 테마는 꽤 많은 부분을 커스터마이징 할 수 있다. 다음의 경로에 있는 파일을 확인해 보자. /blog/themes/다운한 테마 디렉토리/_config.yml ex) /blog/themes/human/_config.yml 이 경로의 _config.yml 파일을 수정하면 커스터마이징이 가능하다. 대표적으로 logo, theme_color, thumbnail, links, widgets 등이 있다. 특히 sidebar의 위치를 취향에 맞게 right나 left로 지정할 수 있다.","categories":[{"name":"Blog","slug":"Blog","permalink":"https://d2fault.github.io/categories/Blog/"},{"name":"Hexo","slug":"Blog/Hexo","permalink":"https://d2fault.github.io/categories/Blog/Hexo/"}],"tags":[]},{"title":"[Github×Hexo] 블로그 개설하기","slug":"20170817-hexo-create-blog","date":"2017-08-17T10:11:40.000Z","updated":"2021-03-04T05:31:55.899Z","comments":true,"path":"2017/08/17/20170817-hexo-create-blog/","link":"","permalink":"https://d2fault.github.io/2017/08/17/20170817-hexo-create-blog/","excerpt":"","text":"블로그 개설하기 본격적으로 Github와 Hexo를 이용해서 블로그를 만들어 보자. 1. github에 repository 생성하기 이 단계에서 중요한 건 딱 하나! repo 이름이다. 블로그명.github.io 주소를 사용하고 싶다면 repo name을 원하는 주소로 지정할 것! 즉, 이 블로그의 repository 이름은 d2fault.github.io이다. 2. Node.js와 hexo 설치하기 node.js는 설치되어 있어야 합니다. 구글링 최고! ‘node.js 설치’ 검색하시면 아주 많은 블로그가……. hexo는 다음의 명령어들로 엄 청 간 단 하 게 설치할 수 있다. 맨 마지막의 server 명령어는 local server를 돌리게 해 준다. 1234npm install hexo-cli -ghexo init blogcd bloghexo server 3. 블로그가 만들어졌나 확인하기 위에서 local server를 돌리는 중이기에, localhost:4000에 접속해 보면 된다. 기본적으로 제공하는 post가 나오면 성공!","categories":[{"name":"Blog","slug":"Blog","permalink":"https://d2fault.github.io/categories/Blog/"},{"name":"Hexo","slug":"Blog/Hexo","permalink":"https://d2fault.github.io/categories/Blog/Hexo/"}],"tags":[]},{"title":"[Diary] 티스토리 블로그 채굴하기","slug":"20170806-diary","date":"2017-08-06T12:56:55.000Z","updated":"2021-03-04T05:31:55.898Z","comments":true,"path":"2017/08/06/20170806-diary/","link":"","permalink":"https://d2fault.github.io/2017/08/06/20170806-diary/","excerpt":"","text":"포스팅이 살아 있을지도 모른다는 작은 기대로 운영하던 블로그에 들어갔다. 대박!!! 게시글이 있어!!! 악성 코드 문제 때문에 블로그 주소가 블락되긴 했지만, admin으로 들어가니 살아 있긴 했다. 블로그가 통으로 날아간 줄 알았는데. ㅋㅋ 이십 대 초반의 내가 열심히 적던 포스팅이 살아 있다는 것만으로도 위로이다. 이 글들을 어떻게 이 블로그로 데리고 올지가 미지수이지만, 최소 몇 십 개의 포스팅은 벌었단 약간의 안도감이. ㅋㅋ 정말 기초적이고, 또 기초적인 내용들 뿐이지만 다시 보면 모르겠지.(ㅠㅠ) 심지어 안드로이드 포스팅은 하나도 없는 거 실화냐고! 일단, Hexo 관련 포스트를 많이 빼 놓고 하나씩 마크다운으로 정리해야겠다. 취미 카테고리도 만들어서 영화, 드라마, 음악 전부 게시글로 남겨야지. 기분이 매우 매우 괜찮다.","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Diary","slug":"Anything/Diary","permalink":"https://d2fault.github.io/categories/Anything/Diary/"}],"tags":[{"name":"일상","slug":"일상","permalink":"https://d2fault.github.io/tags/%EC%9D%BC%EC%83%81/"}]},{"title":"[Github×Hexo] 블로그 시작 준비하기","slug":"20170803-hexo-preparing-to-start","date":"2017-08-03T05:22:56.000Z","updated":"2021-03-04T05:31:55.897Z","comments":true,"path":"2017/08/03/20170803-hexo-preparing-to-start/","link":"","permalink":"https://d2fault.github.io/2017/08/03/20170803-hexo-preparing-to-start/","excerpt":"","text":"블로그 시작 준비하기 우연히 본 한 블로그에서 30분이면 github X hexo 블로그 개설이 가능하다는 말만 믿고 시작했다. ‘포스팅 길이도 짧고, 진짜 30분이면 되겠네!’ 는 나의 착각이었지만. 일단, 이 삽질을 정리하는 것만으로도 꽤 도움이 될 것 같아서 차근차근 정리해 보고자 한다. 아! 저는 MacOS를 사용하고 있습니다. 필수 요소 다음 세 사이트는 블로그 만들기를 위해 꼭 필요하다. Github Hexo Disqus Hexo는 정적 블로그를 예쁘게 만들어 줄 하나의 프레임워크이다. Github는 블로그가 ‘올라갈’ 저장소, Disqus는 블로그에 '댓글 달기 기능’을 넣기 위해 꼭 필요하다. 대부분의 블로그에서 Disqus는 선택 사항이라고 이야기하지만, 솔직히 그렇잖아요. 댓글창 없는 블로그라뇨? 네? 그러니 한 번에 가입하고 시작하는 게 최고 편합니다. Github와 Hexo, 시작 전 팁 아래의 리스트는 24 시간의 삽질을 통해 얻은 팁. 만약 블로그를 다시 만든다면, 리스트에 있는 것들은 꼭 꼭 지키면서 만들 것이다. Github repository를 두 개 만든다. 블로그 본체가 될 repo 하나와, 어디서든 hexo를 사용할 수 있는 업로드형 repo 하나. 일반적인 블로그는 언제든 그 사이트에 들어가서 수정하면 되지만, 정적 블로그인 hexo는 설정 파일들(지금부터 만들어 볼)이 있어야지만 블로그의 내용을 수정할 수 있다. 고로, repo를 두 개로 관리하면 언제 어디서든지 pull과 push로 포스팅 생성, 수정, 삭제가 가능하다. themes 폴더의 경우, fork로 관리하면 편하다. fork에 익숙하지 않을 경우 블로그 폴더 전체를 클라우드와 연결해 두는 것을 추천한다. 게시글 포스팅 전에 기본 테마에서 벗어나자. 테마는 먼저 정하는 게 좋다. 그래야 흐름 안 끊기고 블로그 만들 수 있음. 현재 적용한 테마는 hueman이고, 대부분의 개발 블로그에서 이 테마를 사용한다. 블로그 내부 게시글 검색 가능하고, 카테고리로 dropdown 메뉴도 만들어지고……. 여러모로 편리한 테마인 듯. 테마는 만들 수도 있지만 보통은 검색해서 적용하는 것 같다. 기술 블로그에 어울릴 것 같은 테마는 대락 다음의 두 가지. (여러 가지 확인했지만 내부 검색 기능이 있고 깔끔한 테마가 생각보다 많지 않음.) human maupassant 나만의 블로그 로고가 필요하다면? 미리 만들자. (닉네임과 블로그 이름 등, 자잘한 것들도 포함.) 테마에 로고를 바로 적용, 배포하기 위해서는 미리 만드는 게 편하다. 만약 테마의 로고 사이즈가 120 * 80이라면, 실제 로고 사이즈는 120의 배수 * 80의 배수로 만들 것. 사이즈가 다르면 뭉개지고, 120 * 80으로 맞추면 픽셀이 깨져서 보인다. 나는 두 배로 잡아서 240 * 160으로 만들었던 듯. 현재 블로그 로고가 별로인 이유: 미리 안 만들어서. git과 node.js가 설치되어 있지 않다면 hexo 설치 전에 미리 설치한다. 블로그 개설 준비 시에 여러 블로그를 참고하기보다 한 블로그를 따른다. 혹은 많은 글들을 미리 훑어보고 전반적인 흐름을 인지한 후에 시작한다. 참고했던 블로그는 다음과 같다. Eric Han’s IT Blog Powered by Hexo Sixth Challenge v.6.2.24 컴공녀의 개발 블로그 꿈꾸는 태태태의 공간 1, 3 번의 블로그를 주로 읽었던 것 같다. 1 번 블로그에 굉장히 잘 정리되어 있었다. (너무 당연하지만) Github, Disqus에 미리 가입한다. 포스팅 이후에 404가 나온다? 다음과 같은 이유일 수 있다. 포스트가 없는 상태에서 hello-world.md 파일을 지울 경우 404를 뿜는다! 첫 포스팅 전까지는 hello-world.md 파일 유지를 추천. (어떤 블로그에도 없던 내용…….) local에서 테스트 할 때엔 포스트를 제대로 읽지만, git에 올려서 확인하면 index.html이 없다며 404가 나타난다면?! 아마 99%의 확률로 파일명이 '한글’일 것. 직접 테스트한 결과이다. 역시 파일명은 영어. 무조건 영어. 대신 파일 내용 안의 title은 한글로 적어도 상관없다. (너무 당연한 이야기라 어떤 블로그에도 없던 사항. 나는 왜 당연한 것을 두고 삽질을 하였나……………) 마크다운 파일 이름은 ‘영어’ 혹은 '숫자’이어야 하며, 꼭 '소문자’를 사용하자. 대문자로 사용할 경우 hexo-autonofollow 플러그인 사용에 문제가 생긴다. (문제: hexo-autonofollow이 만드는 url은 모두 소문자로 이루어진다. 대문자로 만들면 웹에서 검색되는 url과 실제 접근해야 하는 url이 달라진다. 404 not found 보고 싶으시면 대문자 사용하시면 됩니다.) 마크다운 에디터 추천 그리고 추가적으로, Hexo에 글을 포스팅 할 때 마크다운은 필수라고 해도 과언이 아니다. 마크다운을 편하게 쓰도록 도와주는 에디터가 여럿 존재하므로 취향에 맞춰서 골라 사용하면 된다. 아래 세 가지가 눈에 들어왔던 깔끔한 에디터. Typora (현재 사용 중인 에디터.) Writed (사용했던 에디터. 앱을 지우지는 않았지만 Typora에 일시 정착.) Atom (텍스트 에디터인 아톰을 마크다운 에디터로 사용할 수도 있다. 한번 써 보고 싶은 생각이 들긴 함.)","categories":[{"name":"Blog","slug":"Blog","permalink":"https://d2fault.github.io/categories/Blog/"},{"name":"Hexo","slug":"Blog/Hexo","permalink":"https://d2fault.github.io/categories/Blog/Hexo/"}],"tags":[]},{"title":"[Diary] 개발 블로그 다시 시작","slug":"20170803-diary","date":"2017-08-02T17:42:12.000Z","updated":"2021-03-04T05:31:55.897Z","comments":true,"path":"2017/08/03/20170803-diary/","link":"","permalink":"https://d2fault.github.io/2017/08/03/20170803-diary/","excerpt":"","text":"분명 30분이면 만드는 블로그라고 해서 시작한 건데 엄청난 삽질의 연속이었다. 이런 시행착오를 정리해야 두 번의 실수는 안 할 텐데. (라고 쓰고 다음 번에 같은 일이 발생할 때 보려고라고 읽음. ㅋㅋ) 대학교 재학 중에 티스토리 블로그에 꽤 많은 포스팅을 했었던 것으로 기억한다. 그래 봐야 50 개도 채 안 되는 포스트였겠지만. 중요한 건, 관리하지 않는 사이에 그만……. 해킹과 악성 코드 때문에 블로그가 강제로 폐쇄됐고, 데이터는 분명 백업했던 것 같은데 어디에 있는지 찾을 수가 없다. 너무 아까워!!! 아무튼, 이런 경험으로 블로그 시작을 자꾸 미루다가 지금까지 왔다. brunch도 잠깐, 텀블러도 잠깐 썼지만 전부 마음에 쏙 들지 않아서 금방 시들해진 게 팩트. ㅠ 아직 만져야 할 것들이 많지만 만들었다는 것에 의의를 두어야지. 설렘 반, 귀찮음 반이지만 잘 다듬어 보자~!","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Diary","slug":"Anything/Diary","permalink":"https://d2fault.github.io/categories/Anything/Diary/"}],"tags":[{"name":"일상","slug":"일상","permalink":"https://d2fault.github.io/tags/%EC%9D%BC%EC%83%81/"}]},{"title":"[C/C++] 파일 입출력","slug":"20161010-c-fileio","date":"2016-10-10T14:42:12.000Z","updated":"2021-03-04T05:31:55.896Z","comments":true,"path":"2016/10/10/20161010-c-fileio/","link":"","permalink":"https://d2fault.github.io/2016/10/10/20161010-c-fileio/","excerpt":"","text":"XCode로 파일입출력 공부하기 C언어 기억이 하나도 안 나서 특히 안 나는 부분만 공부하려고 한다. 첫번째 순서는 바로 파일 입출력! 그렇게 어렵지는 않다. 파일을 읽기 위해서는 '파일 포인터’를 사용해야 하는데, 선언하는 방법은 다음과 같다. FILE *fp; 파일 포인터 선언 끝! 하지만 여기서 *pt는 null 포인터이다. 초기화를 해 주어야 한다. fp = fopen(&quot;파일명&quot;, &quot;모드&quot;); 모드는 기본적으로 세 가지가 있다. &quot;r&quot; // 읽기 모드 파일이 없을 경우 에러가 발생한다. &quot;w&quot; // 쓰기 모드 파일이 없으면 생성한다. 파일이 있으면 내용을 덮어씌운다. &quot;a&quot; // 추가 모드 파일이 없으면 생성한다. 파일이 있으면 맨 뒤에 추가한다. 아무튼, 이렇게 하면 파일 포인터 초기화까지 완료! 이기는 함. 근데 그대로 컴파일하면 아무 일도 일어나지 않는다. 파일의 내용을 printf로 한번 찍어 주는 게 좋을 듯하다 ‘ㅅ’)/ 반복문을 사용한다. 파일의 끝은 EOF(end of file)로 판독하면 된다. 12while(fscanf(fp, &quot;%d&quot;, &amp;data) != EOF) printf(&quot;%d&quot;, data); int형으로 이루어진 파일을 읽을 것이기 때문에 data는 int형으로 선언했고, 읽어오는 fscanf도 %d로 받았다. 그리고 아주 무난하게 돌렸는데… 파일 포인터인 fp가 null이었다. 두둥. 분명히 소스 코드가 있는 곳에 해당 txt 파일이 존재했는데도 불구, 읽히지 않았다. 이럴 때 답은 뭐? 구글링 ‘ㅅ’! 설마설마 했는데 역시나. 파일 경로를 풀로 적어줘야 하는 것이었다. -ㅅ-… 원래의 내 코드는 다음과 같았다. 아! fopen을 했으면 close도 있겠죠? 파일을 열었으면 꼭 닫아 줍시다! fclose(fp); 한 줄이면 됩니다! 1234567891011#include &lt;stdio.h&gt;int main(void) &#123; int data; FILE *fp; fp = fopen(&quot;sample_input.txt&quot;, &quot;r&quot;); while(fscanf(fp, &quot;%d&quot;, &amp;data) != EOF)&#123; printf(&quot;%d&quot;, data); &#125; fclose(fp); return 0;&#125; 그리고 변경(최종) 코드는 다음과 같다. 123456789101112#include &lt;stdio.h&gt;int main(void) &#123; int data; FILE *fp; fp = fopen(&quot;/Users/(블라블라)/Desktop/(블라블라)/Easy/1/1/sample_input.txt&quot;, &quot;r&quot;); // 개인 정보를 보호하기 위한 블라블라 처리입니다 &#x27;^&#x27;* while(fscanf(fp, &quot;%d&quot;, &amp;data) != EOF)&#123; printf(&quot;%d&quot;, data); &#125; fclose(fp); return 0;&#125; 이렇게 간단하게 읽어오기는 정말로 끝! 약 2년만에 C 하려니까 잊어버린 게 너무 많다. 잊지 말아야 할 것들을 차근차근 정리하는 버릇을 들여야겠다. 😄","categories":[{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"C/C++","slug":"Programming/C-C","permalink":"https://d2fault.github.io/categories/Programming/C-C/"}],"tags":[{"name":"파일입출력","slug":"파일입출력","permalink":"https://d2fault.github.io/tags/%ED%8C%8C%EC%9D%BC%EC%9E%85%EC%B6%9C%EB%A0%A5/"}]},{"title":"[Review] 블루투스 이어폰 리뷰(엠지텍 MB-E80)","slug":"20160823-review-bluetooth-earphone-mb-e80-mgtec","date":"2016-08-23T05:21:59.000Z","updated":"2021-03-04T05:31:55.892Z","comments":true,"path":"2016/08/23/20160823-review-bluetooth-earphone-mb-e80-mgtec/","link":"","permalink":"https://d2fault.github.io/2016/08/23/20160823-review-bluetooth-earphone-mb-e80-mgtec/","excerpt":"","text":"왜 이어폰을 구매해야 했는가? 이어폰을 고장냈다. 불과 한 달 사이에 두 개를. 하나는 한 쪽에서 음악이 아예 나오지 않았고(블루투스 이어폰), 나머지 하나(샤오미 이어폰)는 모든 음악이 MR로 들렸다.(노래방 야호-_-) 블루투스 이어폰을 써 본 사람은 알 거다. 한 번 쓰면 벗어날 수 없어! 난 블루투스 이어폰의 노예야! 그래서 돈이 좀 들더라도 블루투스 이어폰을 사겠다고 결심했다. 응, 다음은 정보 검색~ 학생이기에! 학생이라서! 가성비가 좋은 이어폰이 나에겐 최적의 이어폰이었다. 잘 고장내기도 하고… ㅠㅠ 너무 비싼 건 부담되고, Briz의 저렴이 이어폰(30000원 이하)을 살까도 했는데 약간의 부정적 후기가 내 지름신을 멈추게 만들었다. 물론, 블루투스 이어폰으로 고작 2-3만원 선에서 음질을 따진다는 건 좀 웃긴 일이기도 하지만. ^^;; 왜 MB-E80인가? 후기를 검색하다가 우연히 MB-E80을 알게 됐다. 왜 이렇게 후기가 많은가 했더니, 이벤트를 하고 있단다. 어떤 이벤트냐고? 하나, 모든 구매 고객에게 2000mA짜리 보조배터리를 증정한다. 둘, 블로그에 리뷰를 쓰면 이어폰을 하나 더 준다. 그렇다. 나는 이어폰을 하나 더 받기 위해 귀찮음을 무릅쓰고 리뷰를 작성하고 있다. (왜? 나는 돈이 없는 학생이니까 ㅠ) 아무튼, 가격 조건을 만족했고(하나를 더 받는다면 개당 22000원 꼴로 산 격이니까) 성능만 테스트하면 되는 상황이었다. 무엇보다 엠지텍은 외장하드로 꽤나 유명한 회사이기에, 믿고 구매할 수 있었다. 리뷰를 해 볼까? 아래는 받은 이어폰 사진이다. 전반적으로 깔끔! 선물용으로도 괜찮을 듯하다. 역시 이어폰이니 음질이 짱짱 중요하겠지? 음질 자체는 나쁘지 않았으나 저음에서 뭉개지는 현상을 보였다. 여성 가수들이 부른 어쿠스틱한 곡들의 음은 뭉개지지 않는 편이다. 베이스음을 사랑하는 유저들에겐 적합하지 않은 이어폰이란 생각이 들었다. 해결하고자 EQ를 마구마구 움직여 보았지만 별 효과는 없었다. 그리고, 하나 더! 귀에 들어가는 실리콘? 이 좋은 편은 아니다. 살짝 딱딱해서 나는 귀에 끼어 보지도 않고 기존에 쓰던 실리콘으로 교체했다. 여분의 실리콘을 많이 주셨는데 나중에 잃어 버리면… 그때 써 보는 걸로… 귀에 거는 부분은 안쪽으로 굽혀서 사용하면 된다. 그래야 귀에 걸린다. 굽히지 않고 그대로 걸면 귓바퀴 바깥쪽으로 나도는 현상을 느낄 수 있다 -ㅅ- 음질을 꽤나 포기하고 산 이어폰이었기 때문에 대체적으로 만족! 가성비 굿이라는 게 바로 이런 건가? 블루투스 이어폰 입문자에게 무난하게 사용할 수 있는 아이템으로 추천한다. 기대하지 않고 받아보면 쓸만하단 생각 할 수 있을 것! 끝으로 리뷰를 써서 이어폰을 하나 더 받았고, 아직까지(2018.05.14) 나는 이 이어폰을 사용하고 있다. 기존에 쓰던 이어폰은 내 실수(출근할 때 귀에 거는 부분을 잡고 뛰다가 한 쪽에서 소리 안 나오게 됨)로 구석에 처박혔지만 나에게는 하나가 더 있었으니까! 이거 감안해도 이어폰 하나에 1년 이상 사용한 거라 아주 만족스럽다. 한 달에 대충 2000원 꼴로 이어폰 쓴 거네! 배터리는 꽤 오래 가는 편(4~5시간)이다. 불편한 점이 있다면 통화할 때? 상대방이 내 목소리를 잘 못들어서 마이크가 있는 왼쪽 이어폰을 빼서 입에 대고 통화해야 한다. ^^;; 깔깔. 엠지텍에서 코드 프리 이어폰(완전 무선 이어폰)도 두 개나 만들었는데, 사실 이 이어폰(W1500) 노리는 중. 역시 나는 블루투스의 노예다! 경쟁 상대는 삼성의 기어 아이콘 X~! 노이즈 조절이 된다고 해서 고민 중. ㅋㅋ 아무튼, 엠지텍은 가성비 갑의 기업이다. 완전 강추. 아빠한테 이 이어폰(W1500) 추천했으니 아빠 사면 써 보고 결정해야지. ^^","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"블루투스이어폰","slug":"블루투스이어폰","permalink":"https://d2fault.github.io/tags/%EB%B8%94%EB%A3%A8%ED%88%AC%EC%8A%A4%EC%9D%B4%EC%96%B4%ED%8F%B0/"},{"name":"후기","slug":"후기","permalink":"https://d2fault.github.io/tags/%ED%9B%84%EA%B8%B0/"},{"name":"엠지텍","slug":"엠지텍","permalink":"https://d2fault.github.io/tags/%EC%97%A0%EC%A7%80%ED%85%8D/"}]},{"title":"[Movie] 이프 온리(If Only)","slug":"20121217-movie-review-if-only","date":"2012-12-16T17:26:10.000Z","updated":"2021-03-04T05:31:55.885Z","comments":true,"path":"2012/12/17/20121217-movie-review-if-only/","link":"","permalink":"https://d2fault.github.io/2012/12/17/20121217-movie-review-if-only/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 줄거리 남주와 여주가 잠에서 깨어 애정행각을 벌이는 것으로 영화가 시작된다. 처음 부분만 봐도 남자는 이성적이고 여자보단 자신의 일에 더 관심이 있음을 알 수 있다. 남자는 여자가 3년간 준비한 졸업 연주회도 기억하지 못한다. 그 모습에 여자는 상처를 받는다. 남자는 오늘 투자자들과의 중요한 미팅이 있었다. 투자를 받느냐, 그렇지 못하느냐가 남자에게 달려 있었다. 그는 열심히 준비했다. 중요한 날 서류를 두고 간 남자를 위해 서류를 챙겨 그에게 떠난다. 그러나 여자의 실수로 같은 서류를 두 개 들고오고 말았다. 결국 남자는 딜에 실패한다. 그는 여자가 일부러 그랬다고 생각한다. 여자의 연주회에 가기 위해 택시를 잡아 탄 남자. 근데 택시 기사의 질문이 심상찮다. “애정 전선의 문제?” 얼굴만 보고도 여자 친구의 직업을 맞히고, 자신의 고민을 알아냈다. &quot;계산하지 말고 사랑해.&quot; 그 한마디를 듣고 그는 여자친구의 연주회에 간다. 연주회가 끝나고 그들은 함께 저녁 식사를 한다. “오늘은 너무했어. 완전 실패야.” 여주는 미안해한다. 남자는 “조금 더 버텨보고 싶어.” 라고 말을 하지만 여자는 떠난다. “누가 예쁨 받자고 이래? 난 사랑 받고 싶다고! 난 더 이상은 버틸 수 없어.” 라는 말만 남겨두고. 여자는 택시를 잡아 탄다. 이럴 수가! 남자를 데려다 주었던 그 기사였다. “탈 거요, 말 거요. 선택은 당신이 하시오.” 11시를 알리는 종이 치는 순간, 여자친구는 문을 닫았고 택시는 그대로 출발했다. 사거리에서 신호를 기다리는 동안 “쾅!” 다른 차가 택시를 들이받았고, 그렇게 여자친구는 세상을 떠났다. 그런데… 모든 것이 꿈이었다. 남자의 비명에 여자친구는 놀라 깨었고… 그 뒤로는 알다시피 위의 내용과 동일하게 전개. 하지만 꿈을 통해 남자는 여자 없이 살 수 없다는 것과, 자신이 여자를 정말 사랑한다는 것, 또 사랑의 표현 방법을 배웠다. 그는 그녀를 살리기 위해 온 노력을 다 한다. 그리고 자신의 모든 것을 드러낸다. 과거 슬픈 기억들도 공유하고, 그녀를 위해 마음 가득한 선물도 준비한다. 가장 인상 깊었던 장면(동영상 참고)은 여기서 나온다. 그는 그녀가 몰래 써 두었던 곡의 악보를 복사하여 오케스트라 단원들에게 나눠주었고, 그녀의 꿈(많은 사람들 앞에서 노래하는 가수)을 이루어 준다. 그녀는 기립박수를 받고 자신감을 얻는다. 10시 59분. 11시면 사고가 일어남을 아는 남자는 집에 가려고 여자가 탄 택시에 같이 올라 탄다. 그리고 11시. 남자는 여자를 끌어 안아 보호했고, 결국 죽는 건 남자 혼자. 살아 남은 여자가 남자를 향해 자작곡을 선보이며 영화가 끝난다. 내가 꼽는 명장면 여주인공이 자작곡을 부르는 장면이 가장 기억에 남는다. 이 부분에서 계속 소름이 돋았다. 이 영화를 본 사람들이라면 단연코 최고로 꼽는 장면이 아닐까 싶다. 간략 리뷰와 평점 감동적이었다. 그리고 우리 나라랑 다른 문화? 라고 해야 하나. 무엇보다도 여자가 정말 사랑스러워서 평점이 올라갔다! 근데 조금 뻔한 스토리? ㅠㅠ그래서 만점을 줄 수는 없다. (8.0 / 10.0) P.S. 꼭 그 택시를 같이 탔어야만 했니? 꼭 그 시간에 귀가했어야만 했어?","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Movie] 돈의 맛","slug":"20121217-movie-review-the-taste-of-money","date":"2012-12-16T16:19:12.000Z","updated":"2021-03-04T05:31:55.886Z","comments":true,"path":"2012/12/17/20121217-movie-review-the-taste-of-money/","link":"","permalink":"https://d2fault.github.io/2012/12/17/20121217-movie-review-the-taste-of-money/","excerpt":"","text":"예고편 보기 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 리뷰 기대를 많이 하고 봤던 영화였지만 기대에 한~참 못 미치는 전개와 결말에 실망했다. 연초에 이 영화를 홍보하는 포스터와 글들을 많이 봐서 재밌겠다 싶었는데 뭔가 보고 나서 기분이 이상(?)해졌다. 꽁기한 기분은 왜 들었을까? 억지스럽다고 생각했다. 현실감이 많이 떨어졌다. 분명 상류층에서 일어날 수 있을 법한 일들인데도 저런 느낌이 강했다. 모든 장면에서 '그럴 수 있지. 그래 맞아.‘라는 생각보다 어떻게 저럴 수 있지? 라는 생각이 강했다. 영화 전반에 걸쳐서 더럽다는 느낌’만’ 들었다. 문란한 성 생활을 들먹이고 싶었다면 조금 더 현실적으로 씬을 구성해야 했다고 생각한다. 더러운 정치, 경제계를 들먹이고 싶었다면 덜 유치했어야 했다. 어쩜 이렇게 뻔할 수 있을까. 예고편보다 못한 본편이었다. 차라리 한 가지만 갖고 줄거리를 끌어갔다면 이것보다 탄탄한 내용이 나왔을 것이다. 정경계에 종사하는, 그 중에서도 상위 클래스에 속하는 사람들의 부정 부패 그리고 문란한 성 생활과 우리 나라 영화에서 빼 놓을 수 없는 애정라인, 서로에 대한 집착…이 많은 이야기를 115분 안에 담아내기란 어려웠을 것이다. 감독, 그리고 작가의 욕심이 조금 과하지는 않았나… 조심스럽게 내 의견을 적어본다. 평점 유치하고 난잡한 줄거리로 좋은 점수를 줄 수가 없다. (6.5 / 10.0)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]},{"title":"[Movie] 사랑따윈 필요없어","slug":"20121215-movie-review-love-me-not","date":"2012-12-15T12:26:50.000Z","updated":"2021-03-04T05:31:55.884Z","comments":true,"path":"2012/12/15/20121215-movie-review-love-me-not/","link":"","permalink":"https://d2fault.github.io/2012/12/15/20121215-movie-review-love-me-not/","excerpt":"","text":"예고편 보기 시험기간 전에 다운 받았는데 이제서야 보게 된 영화. 포스터가 인상 깊어서 무슨 내용일지 정말 궁금했다. 근데 보다 보니까 예전에 봤던 거긴 했는데, 결말까지 기억이 잘 안 났으므로 끝까지 다 봤다. 처음 장면에 문근영이 검은 옷을 입고 나와서 사람들 시선이 차갑고 아무도 믿을 수 없다고 말한다. 그 부분으로부터 무슨 이야기가 전개될까 호기심이 몽글몽글~ 영화 정보 이미지를 클릭하시면 네이버 영화로 이동합니다. 줄거리이자 스포일러 1등 호스트인 김주혁이 어떤 사람에게 돈을 빌리고, 그 돈을 다 값을 때까지 30일을 준다고 하며 이야기가 전개된다. 김주혁의 동료였던 사람의 핸드폰을 김주혁이 가졌고(그 친구는 죽었다.) 거기에 남겨진 음성 메세지(아버지가 돌아가셨다. 나는 변호사인데 유산의 반을 당신에게 넘겨주라고 써 있었다. 그러니 이 메세지 들으면 연락을 달라.)를 듣고 본가로 찾아간다. 김주혁의 친구는 동생이 하나 있었고, 그 동생이 문근영. (즉, 김주혁이랑 문근영은 피가 섞이지 않은 남남이다.) 김주혁과 함께 찾아간 진구는 자신이 김주혁의 비서라고 속인다.(원래 직업은 호스트) 그 집에는 대표라는 사람과 그리고 문근영을 도와주는 여선생님이 있었다. 김주혁은 철저히 자신의 신분을 문근영의 친오빠로 둔갑하여 한 집에서 같이 지내게 된다. 김주혁의 목적은 사기를 치는 것, 그래서 돈을 받는 것. 차가운 문근영을 녹이기 위해 화를 내며 훈계를 하기도, 또 친절하게 이끌기도 한다. 마지막. 결국 모든 사람들의 연기는 들통난다. 대표와 여선생의 목적은 돈과 문근영의 죽음. 문근영은 김주혁이 오빠가 아닌 것도 알아 버린다. 그 다음 날, 모든 사람에게 식사를 대접하고 이 집에서 나가달라며 요구한다. 각자에게 원하는 것들을 준다. 하지만 문근영은 김주혁을 나무라지 않는다. 그걸 보고 도와주던 여선생은 문근영에게 왜 친오빠가 아님을 알면서도 나무라지 않느냐고 묻고, 문근영은 “사랑하니까.” 라고 대답한다. 그렇게 모두 집을 떠난다. 문근영은 앓고 있던 병이 있었다. 김주혁은 집을 떠나지만 그런 문근영을 위해 수술 준비를 도맡아 한다. 그리고 그 날, 수술 동의서에 사인을 하고 편지와 받았던 돈을 남기고 떠나려 한다. 그걸 안 문근영은 클럽으로 김주혁을 찾으러 가고, 거기서 김주혁이 돈을 빌렸던 사람과 이야기를 나눈다. 김주혁은 그 사람에게 돈을 갚지 않았고 그 사람은 김주혁에게 전화를 걸어 협박한다. 화가 난 김주혁은 도피를 포기하고 클럽으로 달려갔고 결국 그 사람에게 칼을 여러 차례 맞아 쓰러진다. 문근영은 검은 옷을 입고 자신의 집 거실 바닥에 눕는다. 가구에는 흰 천이 씌워져 있었으며, 마지막에는 김주혁과 문근영이 만나 포옹하는 장면으로 영화가 끝난다. 영화 내에 계속 나오는 오르골? 이 있는데, 이 수정 안에는 나무 하나가 있었다. 마지막에 둘은 그 나무와 똑같이 생긴 나무 앞에서 포옹한다. 간략 리뷰와 평점 결말이 조금 허무했다. 둘 다 살았는지, 아님 둘 다 죽었는지 의문이 들었다. 그런데 나무와 눈이 보이는 문근영으로 미뤄보아 아마 둘 다 죽어서 만난 것이 아닌가 싶었다. 원작이 일본 영화라고 들었는데 원작을 보지 못해 비교를 할 수는 없지만 생각보다 임팩트 있던 영화는 아니었다고 생각한다. (6.0 / 10.0)","categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"}],"tags":[{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"}]}],"categories":[{"name":"Anything","slug":"Anything","permalink":"https://d2fault.github.io/categories/Anything/"},{"name":"Diary","slug":"Anything/Diary","permalink":"https://d2fault.github.io/categories/Anything/Diary/"},{"name":"Programming","slug":"Programming","permalink":"https://d2fault.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://d2fault.github.io/categories/Programming/Android/"},{"name":"Blog","slug":"Blog","permalink":"https://d2fault.github.io/categories/Blog/"},{"name":"Information","slug":"Blog/Information","permalink":"https://d2fault.github.io/categories/Blog/Information/"},{"name":"Review","slug":"Anything/Review","permalink":"https://d2fault.github.io/categories/Anything/Review/"},{"name":"Java","slug":"Programming/Java","permalink":"https://d2fault.github.io/categories/Programming/Java/"},{"name":"IT","slug":"IT","permalink":"https://d2fault.github.io/categories/IT/"},{"name":"Others","slug":"IT/Others","permalink":"https://d2fault.github.io/categories/IT/Others/"},{"name":"JavaScript","slug":"Programming/JavaScript","permalink":"https://d2fault.github.io/categories/Programming/JavaScript/"},{"name":"Blockchain","slug":"IT/Blockchain","permalink":"https://d2fault.github.io/categories/IT/Blockchain/"},{"name":"Linux","slug":"IT/Linux","permalink":"https://d2fault.github.io/categories/IT/Linux/"},{"name":"Hexo","slug":"Blog/Hexo","permalink":"https://d2fault.github.io/categories/Blog/Hexo/"},{"name":"C/C++","slug":"Programming/C-C","permalink":"https://d2fault.github.io/categories/Programming/C-C/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://d2fault.github.io/tags/%ED%9A%8C%EA%B3%A0/"},{"name":"design","slug":"design","permalink":"https://d2fault.github.io/tags/design/"},{"name":"module","slug":"module","permalink":"https://d2fault.github.io/tags/module/"},{"name":"goodnote","slug":"goodnote","permalink":"https://d2fault.github.io/tags/goodnote/"},{"name":"굿노트","slug":"굿노트","permalink":"https://d2fault.github.io/tags/%EA%B5%BF%EB%85%B8%ED%8A%B8/"},{"name":"템플릿","slug":"템플릿","permalink":"https://d2fault.github.io/tags/%ED%85%9C%ED%94%8C%EB%A6%BF/"},{"name":"contentprovider","slug":"contentprovider","permalink":"https://d2fault.github.io/tags/contentprovider/"},{"name":"contentobserver","slug":"contentobserver","permalink":"https://d2fault.github.io/tags/contentobserver/"},{"name":"process","slug":"process","permalink":"https://d2fault.github.io/tags/process/"},{"name":"task","slug":"task","permalink":"https://d2fault.github.io/tags/task/"},{"name":"리뷰","slug":"리뷰","permalink":"https://d2fault.github.io/tags/%EB%A6%AC%EB%B7%B0/"},{"name":"android","slug":"android","permalink":"https://d2fault.github.io/tags/android/"},{"name":"책","slug":"책","permalink":"https://d2fault.github.io/tags/%EC%B1%85/"},{"name":"kotlin","slug":"kotlin","permalink":"https://d2fault.github.io/tags/kotlin/"},{"name":"sdk","slug":"sdk","permalink":"https://d2fault.github.io/tags/sdk/"},{"name":"architect","slug":"architect","permalink":"https://d2fault.github.io/tags/architect/"},{"name":"java","slug":"java","permalink":"https://d2fault.github.io/tags/java/"},{"name":"customdialog","slug":"customdialog","permalink":"https://d2fault.github.io/tags/customdialog/"},{"name":"fullscreen","slug":"fullscreen","permalink":"https://d2fault.github.io/tags/fullscreen/"},{"name":"audiofocus","slug":"audiofocus","permalink":"https://d2fault.github.io/tags/audiofocus/"},{"name":"webview","slug":"webview","permalink":"https://d2fault.github.io/tags/webview/"},{"name":"bitmask","slug":"bitmask","permalink":"https://d2fault.github.io/tags/bitmask/"},{"name":"enumset","slug":"enumset","permalink":"https://d2fault.github.io/tags/enumset/"},{"name":"해커톤","slug":"해커톤","permalink":"https://d2fault.github.io/tags/%ED%95%B4%EC%BB%A4%ED%86%A4/"},{"name":"매시업","slug":"매시업","permalink":"https://d2fault.github.io/tags/%EB%A7%A4%EC%8B%9C%EC%97%85/"},{"name":"coroutine","slug":"coroutine","permalink":"https://d2fault.github.io/tags/coroutine/"},{"name":"Android","slug":"Android","permalink":"https://d2fault.github.io/tags/Android/"},{"name":"context","slug":"context","permalink":"https://d2fault.github.io/tags/context/"},{"name":"dispatchers","slug":"dispatchers","permalink":"https://d2fault.github.io/tags/dispatchers/"},{"name":"영화","slug":"영화","permalink":"https://d2fault.github.io/tags/%EC%98%81%ED%99%94/"},{"name":"adb","slug":"adb","permalink":"https://d2fault.github.io/tags/adb/"},{"name":"git","slug":"git","permalink":"https://d2fault.github.io/tags/git/"},{"name":"tip","slug":"tip","permalink":"https://d2fault.github.io/tags/tip/"},{"name":"자격 증명","slug":"자격-증명","permalink":"https://d2fault.github.io/tags/%EC%9E%90%EA%B2%A9-%EC%A6%9D%EB%AA%85/"},{"name":"코틀린","slug":"코틀린","permalink":"https://d2fault.github.io/tags/%EC%BD%94%ED%8B%80%EB%A6%B0/"},{"name":"deview","slug":"deview","permalink":"https://d2fault.github.io/tags/deview/"},{"name":"clean code","slug":"clean-code","permalink":"https://d2fault.github.io/tags/clean-code/"},{"name":"refactoring","slug":"refactoring","permalink":"https://d2fault.github.io/tags/refactoring/"},{"name":"redis","slug":"redis","permalink":"https://d2fault.github.io/tags/redis/"},{"name":"sentinel","slug":"sentinel","permalink":"https://d2fault.github.io/tags/sentinel/"},{"name":"node.js","slug":"node-js","permalink":"https://d2fault.github.io/tags/node-js/"},{"name":"express","slug":"express","permalink":"https://d2fault.github.io/tags/express/"},{"name":"ejs","slug":"ejs","permalink":"https://d2fault.github.io/tags/ejs/"},{"name":"consolidate","slug":"consolidate","permalink":"https://d2fault.github.io/tags/consolidate/"},{"name":"mustache","slug":"mustache","permalink":"https://d2fault.github.io/tags/mustache/"},{"name":"일상","slug":"일상","permalink":"https://d2fault.github.io/tags/%EC%9D%BC%EC%83%81/"},{"name":"Tip","slug":"Tip","permalink":"https://d2fault.github.io/tags/Tip/"},{"name":"블루투스이어폰","slug":"블루투스이어폰","permalink":"https://d2fault.github.io/tags/%EB%B8%94%EB%A3%A8%ED%88%AC%EC%8A%A4%EC%9D%B4%EC%96%B4%ED%8F%B0/"},{"name":"후기","slug":"후기","permalink":"https://d2fault.github.io/tags/%ED%9B%84%EA%B8%B0/"},{"name":"엠지텍","slug":"엠지텍","permalink":"https://d2fault.github.io/tags/%EC%97%A0%EC%A7%80%ED%85%8D/"},{"name":"코인","slug":"코인","permalink":"https://d2fault.github.io/tags/%EC%BD%94%EC%9D%B8/"},{"name":"토큰이코노미","slug":"토큰이코노미","permalink":"https://d2fault.github.io/tags/%ED%86%A0%ED%81%B0%EC%9D%B4%EC%BD%94%EB%85%B8%EB%AF%B8/"},{"name":"token economy","slug":"token-economy","permalink":"https://d2fault.github.io/tags/token-economy/"},{"name":"research","slug":"research","permalink":"https://d2fault.github.io/tags/research/"},{"name":"빅스비","slug":"빅스비","permalink":"https://d2fault.github.io/tags/%EB%B9%85%EC%8A%A4%EB%B9%84/"},{"name":"시리","slug":"시리","permalink":"https://d2fault.github.io/tags/%EC%8B%9C%EB%A6%AC/"},{"name":"Hyperledger","slug":"Hyperledger","permalink":"https://d2fault.github.io/tags/Hyperledger/"},{"name":"Fabric","slug":"Fabric","permalink":"https://d2fault.github.io/tags/Fabric/"},{"name":"powerpoint","slug":"powerpoint","permalink":"https://d2fault.github.io/tags/powerpoint/"},{"name":"ppt","slug":"ppt","permalink":"https://d2fault.github.io/tags/ppt/"},{"name":"exel","slug":"exel","permalink":"https://d2fault.github.io/tags/exel/"},{"name":"개발환경","slug":"개발환경","permalink":"https://d2fault.github.io/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD/"},{"name":"설치","slug":"설치","permalink":"https://d2fault.github.io/tags/%EC%84%A4%EC%B9%98/"},{"name":"CentOS","slug":"CentOS","permalink":"https://d2fault.github.io/tags/CentOS/"},{"name":"m4","slug":"m4","permalink":"https://d2fault.github.io/tags/m4/"},{"name":"autoconf","slug":"autoconf","permalink":"https://d2fault.github.io/tags/autoconf/"},{"name":"automake","slug":"automake","permalink":"https://d2fault.github.io/tags/automake/"},{"name":"ssh","slug":"ssh","permalink":"https://d2fault.github.io/tags/ssh/"},{"name":"Composer","slug":"Composer","permalink":"https://d2fault.github.io/tags/Composer/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://d2fault.github.io/tags/Tutorial/"},{"name":"인코딩","slug":"인코딩","permalink":"https://d2fault.github.io/tags/%EC%9D%B8%EC%BD%94%EB%94%A9/"},{"name":"branch","slug":"branch","permalink":"https://d2fault.github.io/tags/branch/"},{"name":"복구","slug":"복구","permalink":"https://d2fault.github.io/tags/%EB%B3%B5%EA%B5%AC/"},{"name":"ICO","slug":"ICO","permalink":"https://d2fault.github.io/tags/ICO/"},{"name":"특허","slug":"특허","permalink":"https://d2fault.github.io/tags/%ED%8A%B9%ED%97%88/"},{"name":"지적재산권","slug":"지적재산권","permalink":"https://d2fault.github.io/tags/%EC%A7%80%EC%A0%81%EC%9E%AC%EC%82%B0%EA%B6%8C/"},{"name":"커피","slug":"커피","permalink":"https://d2fault.github.io/tags/%EC%BB%A4%ED%94%BC/"},{"name":"나노프레소","slug":"나노프레소","permalink":"https://d2fault.github.io/tags/%EB%82%98%EB%85%B8%ED%94%84%EB%A0%88%EC%86%8C/"},{"name":"Ethereum","slug":"Ethereum","permalink":"https://d2fault.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"https://d2fault.github.io/tags/Solidity/"},{"name":"명령어","slug":"명령어","permalink":"https://d2fault.github.io/tags/%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"name":"문법","slug":"문법","permalink":"https://d2fault.github.io/tags/%EB%AC%B8%EB%B2%95/"},{"name":"geth","slug":"geth","permalink":"https://d2fault.github.io/tags/geth/"},{"name":"Docker","slug":"Docker","permalink":"https://d2fault.github.io/tags/Docker/"},{"name":"Python","slug":"Python","permalink":"https://d2fault.github.io/tags/Python/"},{"name":"GO","slug":"GO","permalink":"https://d2fault.github.io/tags/GO/"},{"name":"핀테크","slug":"핀테크","permalink":"https://d2fault.github.io/tags/%ED%95%80%ED%85%8C%ED%81%AC/"},{"name":"스타트업","slug":"스타트업","permalink":"https://d2fault.github.io/tags/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85/"},{"name":"복싱","slug":"복싱","permalink":"https://d2fault.github.io/tags/%EB%B3%B5%EC%8B%B1/"},{"name":"생각","slug":"생각","permalink":"https://d2fault.github.io/tags/%EC%83%9D%EA%B0%81/"},{"name":"파일입출력","slug":"파일입출력","permalink":"https://d2fault.github.io/tags/%ED%8C%8C%EC%9D%BC%EC%9E%85%EC%B6%9C%EB%A0%A5/"}]}